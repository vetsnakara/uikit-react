(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactUikit"] = factory(require("react"), require("react-dom"));
	else
		root["ReactUikit"] = factory(root["React"], root["ReactDOM"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/components/Avatar/Avatar.jsx":
/*!******************************************!*\
  !*** ./src/components/Avatar/Avatar.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Avatar: function() { return /* binding */ Avatar; },
/* harmony export */   AvatarSize: function() { return /* binding */ AvatarSize; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["src", "className", "rounded", "size"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var AvatarSize = {
  Big: "big",
  Medium: "medium",
  Small: "small",
  Smallest: "smallest"
};

// todo: useMemo, forwardRef ?

var Avatar = function Avatar(_ref) {
  var src = _ref.src,
    className = _ref.className,
    rounded = _ref.rounded,
    size = _ref.size,
    props = _objectWithoutProperties(_ref, _excluded);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("avatar", className, _defineProperty({
    avatar_rounded: rounded
  }, "avatar_".concat(size), size));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
    className: classNames,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("img", _objectSpread({
      className: "avatar__image",
      src: src
    }, props))
  });
};

/***/ }),

/***/ "./src/components/Avatar/index.js":
/*!****************************************!*\
  !*** ./src/components/Avatar/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Avatar: function() { return /* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.Avatar; },
/* harmony export */   AvatarSize: function() { return /* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.AvatarSize; }
/* harmony export */ });
/* harmony import */ var _Avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Avatar */ "./src/components/Avatar/Avatar.jsx");


/***/ }),

/***/ "./src/components/Badge/Badge.jsx":
/*!****************************************!*\
  !*** ./src/components/Badge/Badge.jsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Badge: function() { return /* binding */ Badge; },
/* harmony export */   BadgeMaxWidth250: function() { return /* binding */ BadgeMaxWidth250; },
/* harmony export */   BadgeVariant: function() { return /* binding */ BadgeVariant; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var BadgeVariant = {
  Success: "success",
  Error: "error",
  Warning: "warning",
  Danger: "danger",
  Transparent: "transparent"
};
var BadgeMaxWidth250 = 250;
var Badge = function Badge(_ref) {
  var className = _ref.className,
    icon = _ref.icon,
    variant = _ref.variant,
    round = _ref.round,
    maxWidth = _ref.maxWidth,
    closeable = _ref.closeable,
    onClose = _ref.onClose,
    children = _ref.children;
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("badge", className, _defineProperty(_defineProperty(_defineProperty({}, "badge_".concat(variant), variant), "badge_max-width-".concat(maxWidth), maxWidth), "badge_round", round));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: classNames,
    children: [icon && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
      className: "icon badge__icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("use", {
        href: "uikit/icon/icons.svg#".concat(icon)
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("span", {
      className: "badge__text",
      children: children
    }), closeable && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("button", {
      type: "button",
      className: "badge__button-icon",
      onClick: onClose,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
        className: "badge__close icon icon_s",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("use", {
          href: "uikit/icon/icons.svg#close"
        })
      })
    })]
  });
};

/***/ }),

/***/ "./src/components/Badge/index.js":
/*!***************************************!*\
  !*** ./src/components/Badge/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Badge: function() { return /* reexport safe */ _Badge__WEBPACK_IMPORTED_MODULE_0__.Badge; },
/* harmony export */   BadgeMaxWidth250: function() { return /* reexport safe */ _Badge__WEBPACK_IMPORTED_MODULE_0__.BadgeMaxWidth250; },
/* harmony export */   BadgeVariant: function() { return /* reexport safe */ _Badge__WEBPACK_IMPORTED_MODULE_0__.BadgeVariant; }
/* harmony export */ });
/* harmony import */ var _Badge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Badge */ "./src/components/Badge/Badge.jsx");


/***/ }),

/***/ "./src/components/Box/index.js":
/*!*************************************!*\
  !*** ./src/components/Box/index.js ***!
  \*************************************/
/***/ (function() {



/***/ }),

/***/ "./src/components/Button/Button.jsx":
/*!******************************************!*\
  !*** ./src/components/Button/Button.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: function() { return /* binding */ Button; },
/* harmony export */   ButtonTheme: function() { return /* binding */ ButtonTheme; },
/* harmony export */   ButtonVariant: function() { return /* binding */ ButtonVariant; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["variant", "theme", "wide", "icon", "type", "className", "children"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




// todo: Button as link
// todo: use Button.Variant
// todo: change order of memo and forwardRef ???
// todo: create helper for generate new component (cli, snippet)


var ButtonVariant = {
  Secondary: "secondary",
  Plain: "plain"
};
var ButtonTheme = {
  Destruct: "desctuct"
};
var ButtonPropTypes = {
  theme: prop_types__WEBPACK_IMPORTED_MODULE_3__.string.isRequired
};

/**
 * Button
 *
 * @param {{
 *     variant?: "secondary" | "plain",
 *     theme?: string,
 *     wide?: boolean,
 *     icon?: string,
 *     type?: string
 * } & import('react').HTMLAttributes<HTMLButtonElement>} props
 */
var Button = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function (_ref, ref) {
  var variant = _ref.variant,
    theme = _ref.theme,
    wide = _ref.wide,
    icon = _ref.icon,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? "button" : _ref$type,
    className = _ref.className,
    children = _ref.children,
    buttonProps = _objectWithoutProperties(_ref, _excluded);
  console.log("useEffect", react__WEBPACK_IMPORTED_MODULE_1__.useEffect);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    console.log("--- effect");
  }, []);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("button", _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "button_".concat(variant), variant), "button_".concat(theme), theme), "button_wide", wide), "button_icontext", icon && children), "button_icon", icon && !children), className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("button", _objectSpread(_objectSpread({
    ref: ref,
    className: classNames,
    type: type
  }, buttonProps), {}, {
    children: [icon && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("svg", {
      className: "icon button__icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("use", {
        href: "uikit/icon/icons.svg#".concat(icon)
      })
    }), children]
  }));
});

// Button.Variant = ButtonVariant;

// const _Button = forwardRef(Button);

// Object.assign(_Button, {
//     displayName: "Button",
//     propTypes: ButtonPropTypes,
// });

// export { _Button as Button };

/***/ }),

/***/ "./src/components/Button/index.js":
/*!****************************************!*\
  !*** ./src/components/Button/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: function() { return /* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.Button; },
/* harmony export */   ButtonTheme: function() { return /* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.ButtonTheme; },
/* harmony export */   ButtonVariant: function() { return /* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.ButtonVariant; }
/* harmony export */ });
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button */ "./src/components/Button/Button.jsx");


/***/ }),

/***/ "./src/components/Card/Card.jsx":
/*!**************************************!*\
  !*** ./src/components/Card/Card.jsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Card: function() { return /* binding */ Card; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["children", "className", "theme"],
  _excluded2 = ["className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var Card = function Card(_ref) {
  var children = _ref.children,
    className = _ref.className,
    theme = _ref.theme,
    props = _objectWithoutProperties(_ref, _excluded);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("card", className, _defineProperty({}, "card_".concat(theme), theme));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread(_objectSpread({
    className: classNames
  }, props), {}, {
    children: children
  }));
};
var CardFooter = function CardFooter(_ref2) {
  var className = _ref2.className,
    props = _objectWithoutProperties(_ref2, _excluded2);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread({
    className: classnames__WEBPACK_IMPORTED_MODULE_0___default()("card__footer-interface", className)
  }, props));
};
Card.Footer = CardFooter;

/***/ }),

/***/ "./src/components/Card/index.js":
/*!**************************************!*\
  !*** ./src/components/Card/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Card: function() { return /* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_0__.Card; }
/* harmony export */ });
/* harmony import */ var _Card__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Card */ "./src/components/Card/Card.jsx");


/***/ }),

/***/ "./src/components/Checkbox/Checkbox.jsx":
/*!**********************************************!*\
  !*** ./src/components/Checkbox/Checkbox.jsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Checkbox: function() { return /* binding */ Checkbox; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "./src/components/Checkbox/context.js");
/* harmony import */ var _CheckboxGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CheckboxGroup */ "./src/components/Checkbox/CheckboxGroup.jsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["label", "title", "error", "className", "onChange"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var CheckboxVariant = {
  Checkbox: "checkbox",
  Switch: "switch"
};

// todo: is needed required?

var Checkbox = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, extRef) {
  var label = props.label,
    title = props.title,
    error = props.error,
    className = props.className,
    onChange = props.onChange,
    otherProps = _objectWithoutProperties(props, _excluded);
  var checkboxProps = _objectSpread({}, otherProps);
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_2__.useFormControlRef)(extRef, function (el) {
      return {
        el: el,
        getValue: function getValue() {
          return el.checked;
        },
        setValue: function setValue() {
          var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          el.checked = checked;
        }
      };
    }),
    ref = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;
  var onCheckboxChange = function onCheckboxChange(event) {
    onChange === null || onChange === void 0 || onChange(ref.current.getValue(), event);
  };
  checkboxProps.onChange = onCheckboxChange;

  //! use defaultValue for consistency (useForm)
  if (checkboxProps.defaultValue) {
    checkboxProps.defaultChecked = checkboxProps.defaultValue;
  }
  var groupContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_3__.CheckboxGroupContext);
  if (groupContext) {
    var _props$disabled, _props$variant;
    checkboxProps.name = groupContext.name;
    checkboxProps.disabled = (_props$disabled = props.disabled) !== null && _props$disabled !== void 0 ? _props$disabled : groupContext.disabled;
    checkboxProps.variant = (_props$variant = props.variant) !== null && _props$variant !== void 0 ? _props$variant : groupContext.variant;
    checkboxProps.onChange = function (event) {
      var _groupContext$onChang;
      onCheckboxChange === null || onCheckboxChange === void 0 || onCheckboxChange(event);
      (_groupContext$onChang = groupContext.onChange) === null || _groupContext$onChang === void 0 || _groupContext$onChang.call(groupContext, event);
    };
    if (groupContext.value) {
      checkboxProps.checked = groupContext.value.includes(checkboxProps.value);
    }
    if (groupContext.defaultValue) {
      checkboxProps.defaultChecked = groupContext.defaultValue.includes(checkboxProps.value);
    }
  }
  var _checkboxProps$varian = checkboxProps.variant,
    variant = _checkboxProps$varian === void 0 ? CheckboxVariant.Checkbox : _checkboxProps$varian;
  var labelClassNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()(variant, className, {
    checkbox_error: error
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("label", {
    className: labelClassNames,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input", _objectSpread({
      type: "checkbox",
      ref: callbackRef
    }, checkboxProps)), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
      className: "".concat(variant, "__label"),
      children: label
    }), title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
      className: "".concat(variant, "__title"),
      children: title
    }), error && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
      className: "checkbox__error",
      children: error
    })]
  });
}));
Checkbox.Group = _CheckboxGroup__WEBPACK_IMPORTED_MODULE_4__.CheckboxGroup;
Checkbox.Variant = CheckboxVariant;

/***/ }),

/***/ "./src/components/Checkbox/CheckboxGroup.jsx":
/*!***************************************************!*\
  !*** ./src/components/Checkbox/CheckboxGroup.jsx ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxGroup: function() { return /* binding */ CheckboxGroup; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context */ "./src/components/Checkbox/context.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }




// todo: optimize renders for controlled variant
// todo: show error (if any) on last Radio only
// todo: create Radios from items list prop

var CheckboxGroup = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, extRef) {
  var name = props.name,
    value = props.value,
    defaultValue = props.defaultValue,
    disabled = props.disabled,
    variant = props.variant,
    className = props.className,
    children = props.children,
    _props$component = props.component,
    Component = _props$component === void 0 ? "div" : _props$component;
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_1__.useFormControlRef)(extRef, function (el) {
      return {
        el: el,
        getValue: function getValue() {
          var checkboxNodes = _toConsumableArray(el.querySelectorAll("[type='checkbox']"));
          var values = _toConsumableArray(checkboxNodes).map(function (_ref) {
            var value = _ref.value,
              checked = _ref.checked;
            return checked ? value : null;
          }).filter(Boolean);
          return values;
        },
        setValue: function setValue() {
          var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          //! DRY
          var checkboxNodes = _toConsumableArray(el.querySelectorAll("[type='checkbox']"));
          checkboxNodes.forEach(function (node) {
            node.checked = values.includes(node.value);
          });
        }
      };
    }),
    ref = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;
  var onCheckboxChange = function onCheckboxChange(event) {
    var _props$onChange;
    var checkboxNodes = ref.current.el.querySelectorAll("[type='checkbox']");
    var values = _toConsumableArray(checkboxNodes).map(function (_ref2) {
      var value = _ref2.value,
        checked = _ref2.checked;
      return checked ? value : null;
    }).filter(Boolean);
    ref.current.el.value = values; // ref points to div

    (_props$onChange = props.onChange) === null || _props$onChange === void 0 || _props$onChange.call(props, values, event);
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, {
    ref: callbackRef,
    className: className,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_context__WEBPACK_IMPORTED_MODULE_2__.CheckboxGroupContext.Provider, {
      // todo: memo?
      value: {
        name: name,
        value: value,
        defaultValue: defaultValue,
        variant: variant,
        disabled: disabled,
        onChange: onCheckboxChange
      },
      children: children
    })
  });
}));

/***/ }),

/***/ "./src/components/Checkbox/context.js":
/*!********************************************!*\
  !*** ./src/components/Checkbox/context.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxGroupContext: function() { return /* binding */ CheckboxGroupContext; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var CheckboxGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createContext();

/***/ }),

/***/ "./src/components/Checkbox/index.js":
/*!******************************************!*\
  !*** ./src/components/Checkbox/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Checkbox: function() { return /* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.Checkbox; }
/* harmony export */ });
/* harmony import */ var _Checkbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Checkbox */ "./src/components/Checkbox/Checkbox.jsx");


/***/ }),

/***/ "./src/components/DateInput/DateInput.jsx":
/*!************************************************!*\
  !*** ./src/components/DateInput/DateInput.jsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateInput: function() { return /* binding */ DateInput; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Input */ "./src/components/Input/index.js");
/* harmony import */ var _useDatepicker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useDatepicker */ "./src/components/DateInput/useDatepicker.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





// todo: default masks - 99.99.9999 or 99.99.9999 - 99.99.9999

var DateInput = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref, extRef) {
  var className = _ref.className,
    props = _objectWithoutProperties(_ref, _excluded);
  var _useDatepicker = (0,_useDatepicker__WEBPACK_IMPORTED_MODULE_3__.useDatepicker)(extRef, props),
    callbackRef = _useDatepicker.callbackRef,
    handleChange = _useDatepicker.handleChange;
  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()("input_date", className);
  var inputProps = _.omit(props, ["value", "defaultValue", "onChange", "onBlur", "datepickerOptions"]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Input__WEBPACK_IMPORTED_MODULE_2__.Input, _objectSpread({
    ref: callbackRef,
    className: classes,
    onChange: handleChange
  }, inputProps));
}),
//! для колбэков нужно использовать useCallback при передаче в компонент (добавить в гайд по разработке компонентов)
//! использовать deepEqual только для options и items (для остальных - поверхностное сравнение) ???
_.isEqual);

/***/ }),

/***/ "./src/components/DateInput/index.js":
/*!*******************************************!*\
  !*** ./src/components/DateInput/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateInput: function() { return /* reexport safe */ _DateInput__WEBPACK_IMPORTED_MODULE_0__.DateInput; }
/* harmony export */ });
/* harmony import */ var _DateInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DateInput */ "./src/components/DateInput/DateInput.jsx");


/***/ }),

/***/ "./src/components/DateInput/useDatepicker.js":
/*!***************************************************!*\
  !*** ./src/components/DateInput/useDatepicker.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useDatepicker: function() { return /* binding */ useDatepicker; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



// const DEFAULT_DATE_VALUE = "";
// const DEFAULT_DATE_RANGE = [];

var DEFAULT_DATE_FORMMAT = "DD.MM.YYYY";
var DEFAULT_MULTIPLE_DATES_SEPARATOR = " - ";
var DATE_SELECT_EVENT = "DATE_SELECT_EVENT";
var defaultOptions = {
  autoClose: true,
  keyboardNav: false,
  multipleDatesSeparator: DEFAULT_MULTIPLE_DATES_SEPARATOR
};

// todo: update plugin to use silent option?
// todo: check different time formats
// todo: process minMaxDate (can input date < minDate by hand!)
// todo: в неконтр. варианте сделать так, чтобы через ref в range mode отдавался массив дат-строк
// todo: return focus to input after setting date by hand input

//! sort dates array on return outside (can be [1985, 1984] when type by hand in reverse order and plugin changes order by himself)

var useDatepicker = function useDatepicker(extRef, _ref) {
  var value = _ref.value,
    defaultValue = _ref.defaultValue,
    name = _ref.name,
    onChange = _ref.onChange,
    onBlur = _ref.onBlur,
    _ref$datepickerOption = _ref.datepickerOptions,
    options = _ref$datepickerOption === void 0 ? defaultOptions : _ref$datepickerOption,
    _ref$format = _ref.format,
    format = _ref$format === void 0 ? DEFAULT_DATE_FORMMAT : _ref$format;
  var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  // note: Input passes to callback ref object { el, setValue, ...}, not DOM input element
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_1__.useFormControlRef)(extRef, function (_ref2) {
      var el = _ref2.el;
      return {
        el: el,
        getValue: function getValue() {
          var parsedDateValue = getDateValueFromString(el.value);
          var _getValidatedDate = getValidatedDate(parsedDateValue),
            dateValue = _getValidatedDate.dateValue;
          return dateValue;
        },
        setValue: setDate
      };
    }),
    ref = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var $el = $(ref.current.el);
    $el.datepicker(_objectSpread(_objectSpread(_objectSpread({}, defaultOptions), options), {}, {
      onSelect: function onSelect(value) {
        if (context.silent) return;
        var dateSelectEvent = {
          target: {
            name: name
          },
          type: DATE_SELECT_EVENT
        };
        handleChange(value, dateSelectEvent);
      },
      onHide: function onHide(inst /* not used */, isFinished) {
        if (isFinished) return;
        onBlur === null || onBlur === void 0 || onBlur({
          target: {
            name: name
          }
        });
      }
    }));

    // set date from input value if it exists
    var val = $el.val();
    if (val) setDate(val, {
      parse: true
    });
    return function () {
      $el.data("datepicker").destroy();
    };
  }, [JSON.stringify(options), onChange]);

  // for controlled input
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var dateValue = value || defaultValue; // todo?: don't use default value here
    if (!dateValue) return;
    setDate(dateValue);
    if (context.openOnInit) {
      context.openOnInit = false;
      var dp = $(ref.current.el).data("datepicker");
      dp.show();
    }
  }, [value]);

  // set date on value change
  // !!! handleChange gets (value, event) because is passed to <Input/> component (not to primitive <input/>)
  var handleChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (value, event) {
    var date = setDate(value, {
      parse: true
    });
    onChange === null || onChange === void 0 || onChange(date, event);

    // if event - date is changed by hand (typing in input)
    if (event.type !== DATE_SELECT_EVENT) {
      var dp = $(ref.current.el).data("datepicker");
      dp.show(); // for uncontrolled component - open calendar
      context.openOnInit = true; // for controlled component - open calendar on next render
    }
  }, []); // todo: deps?

  /**
   * Parse to [d1, d2]
   * @param {*} value
   * @returns
   */
  var getDateValueFromString = function getDateValueFromString(value) {
    // todo: optimize get separator
    var separator = (options === null || options === void 0 ? void 0 : options.multipleDatesSeparator) || DEFAULT_MULTIPLE_DATES_SEPARATOR;
    return options !== null && options !== void 0 && options.range ? value.split(separator).filter(Boolean) : value;
  };
  var getValidatedDate = function getValidatedDate(value) {
    var isRange = Array.isArray(value);
    return isRange ? getValidatedDateRange(value) : getValidatedDateSingle(value);
  };
  var getValidatedDateSingle = function getValidatedDateSingle(value) {
    if (value === "") return {
      isValid: true,
      dateValue: value,
      dateObj: null
    };
    var mDate = moment(value, format, true);
    var isValid = mDate.isValid();
    return {
      isValid: isValid,
      dateValue: isValid ? value : null,
      dateObj: isValid ? mDate.toDate() : null
    };
  };
  var getValidatedDateRange = function getValidatedDateRange(value) {
    if (value.length === 0) return {
      isValid: true,
      dateValue: [],
      dateObj: []
    };
    var _value = _slicedToArray(value, 2),
      valueBegin = _value[0],
      valueEnd = _value[1];
    var mDateBegin = moment(valueBegin, format, true);
    var mDateEnd = moment(valueEnd, format, true);
    var isDateBeginValid = mDateBegin.isValid();
    var isDateEndValid = mDateEnd.isValid();
    var isValid = isDateBeginValid && isDateEndValid;
    return {
      isValid: isValid,
      dateValue: isValid ? [valueBegin, valueEnd] : null,
      dateObj: isValid ? [mDateBegin.toDate(), mDateEnd.toDate()] : null
    };
  };
  var setDate = function setDate(value) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$parse = _ref3.parse,
      parse = _ref3$parse === void 0 ? false : _ref3$parse;
    //? call selectDate two times ??? (see below)
    if (!value) selectDate(); // reset date

    if (parse) value = getDateValueFromString(value);
    var _getValidatedDate2 = getValidatedDate(value),
      isValid = _getValidatedDate2.isValid,
      dateValue = _getValidatedDate2.dateValue,
      dateObj = _getValidatedDate2.dateObj;
    if (isValid) selectDate(dateObj);
    return dateValue;

    /**
     * todo
     * @param {*} date
     */
    function selectDate(date) {
      var dp = $(ref.current.el).data("datepicker");
      context.silent = true;
      dp.clear();
      if (date) dp.selectDate(date);
      context.silent = false;

      // update date in calendar dropdown
      // note: dp.setViewDate(date.toDate()) in new version();
      if (Array.isArray(date)) {
        var _date = _slicedToArray(date, 2),
          firstDate = _date[0],
          secondDate = _date[1];
        var isSame = moment(firstDate).isSame(moment(secondDate));
        var isBefore = moment(firstDate).isBefore(moment(secondDate));
        var isSameOrBefore = isSame || isBefore;
        dp.date = isSameOrBefore ? firstDate : secondDate;
      } else {
        dp.date = date;
      }
    }
  };
  return {
    callbackRef: callbackRef,
    handleChange: handleChange
  };
};

/***/ }),

/***/ "./src/components/Definitions/Definitions.jsx":
/*!****************************************************!*\
  !*** ./src/components/Definitions/Definitions.jsx ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Definitions: function() { return /* binding */ Definitions; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["items", "variant", "fixWidth", "reverse", "className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



var DefinitionsVariant = {
  Row: "row",
  RowTable: "row-table"
};
var DefinitionsWidth = {
  W150: 150,
  W200: 200,
  W250: 250,
  W300: 300
};

// todo: what to use for key?

var Definitions = function Definitions(_ref) {
  var _ref$items = _ref.items,
    items = _ref$items === void 0 ? [] : _ref$items,
    variant = _ref.variant,
    fixWidth = _ref.fixWidth,
    _ref$reverse = _ref.reverse,
    reverse = _ref$reverse === void 0 ? false : _ref$reverse,
    className = _ref.className,
    props = _objectWithoutProperties(_ref, _excluded);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("definitions", className, _defineProperty(_defineProperty(_defineProperty({}, "definitions_".concat(variant), Boolean(variant)), "definitions_fix-width-".concat(fixWidth), variant === DefinitionsVariant.RowTable && Boolean(fixWidth)), "definitions_reverse", reverse));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread(_objectSpread({
    className: classNames
  }, props), {}, {
    children: items.map(function (item, index) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefinitionsItem, _objectSpread({}, item), index);
    })
  }));
};

// todo: do same for Button and other components
Definitions.Variant = DefinitionsVariant;
Definitions.Width = DefinitionsWidth;
var DefinitionsItem = function DefinitionsItem(_ref2) {
  var term = _ref2.term,
    desc = _ref2.desc;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: "definitions__item",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("dt", {
      className: "definitions__key",
      children: term
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("dd", {
      className: "definitions__value",
      children: desc
    })]
  });
};

/***/ }),

/***/ "./src/components/Definitions/index.js":
/*!*********************************************!*\
  !*** ./src/components/Definitions/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Definitions: function() { return /* reexport safe */ _Definitions__WEBPACK_IMPORTED_MODULE_0__.Definitions; }
/* harmony export */ });
/* harmony import */ var _Definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Definitions */ "./src/components/Definitions/Definitions.jsx");


/***/ }),

/***/ "./src/components/Dropdown/Dropdown.jsx":
/*!**********************************************!*\
  !*** ./src/components/Dropdown/Dropdown.jsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dropdown: function() { return /* binding */ Dropdown; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _DropdownItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DropdownItem */ "./src/components/Dropdown/DropdownItem.jsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["id"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var Dropdown = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref) {
  var _ref$items = _ref.items,
    items = _ref$items === void 0 ? [] : _ref$items,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options,
    toggle = _ref.toggle,
    className = _ref.className,
    onSelect = _ref.onSelect;
  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var $toggle = $(ref.current);
    if (!$toggle.data("toggle")) {
      console.error("Dropdown toggle element should have attribute 'data-toggle=\"dropdown\"'");
    }
    $toggle.dropdown(options);
  }, []);
  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()("dropdown", className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
    className: classes,
    children: [toggle(ref), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      className: "dropdown-menu dropdown-menu-left",
      children: items.map(function (_ref2) {
        var id = _ref2.id,
          itemProps = _objectWithoutProperties(_ref2, _excluded);
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_DropdownItem__WEBPACK_IMPORTED_MODULE_2__.DropdownItem, _objectSpread({
          onClick: function onClick() {
            return onSelect(id);
          }
        }, itemProps), id);
      })
    })]
  });
});

/***/ }),

/***/ "./src/components/Dropdown/DropdownItem.jsx":
/*!**************************************************!*\
  !*** ./src/components/Dropdown/DropdownItem.jsx ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DropdownItem: function() { return /* binding */ DropdownItem; },
/* harmony export */   DropdownItemType: function() { return /* binding */ DropdownItemType; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["type", "text", "icon", "href", "className", "onClick"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




var DropdownItemType = {
  Button: "button",
  Link: "link"
};
var itemClass = "dropdown-item";
var DropdownItem = function DropdownItem(_ref) {
  var _ref$type = _ref.type,
    type = _ref$type === void 0 ? DropdownItemType.Button : _ref$type,
    text = _ref.text,
    icon = _ref.icon,
    href = _ref.href,
    className = _ref.className,
    onClick = _ref.onClick,
    props = _objectWithoutProperties(_ref, _excluded);
  var content = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {
    children: [icon && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
      className: "icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("use", {
        href: "uikit/icon/icons.svg#".concat(icon)
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("span", {
      className: "dropdown-item__text",
      children: text
    })]
  });
  var classes = _defineProperty(_defineProperty({}, DropdownItemType.Button, classnames__WEBPACK_IMPORTED_MODULE_0___default()(itemClass, className)), DropdownItemType.Link, classnames__WEBPACK_IMPORTED_MODULE_0___default()(itemClass, "link", "content_muted", className));
  var element = _defineProperty(_defineProperty({}, DropdownItemType.Button, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("button", _objectSpread(_objectSpread({
    className: classes[type],
    onClick: onClick
  }, props), {}, {
    children: content
  }))), DropdownItemType.Link,
  /*#__PURE__*/
  // todo: use Link
  (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("a", _objectSpread(_objectSpread({
    href: href,
    className: classes[type]
  }, props), {}, {
    children: content
  })));
  return element[type];
};

/***/ }),

/***/ "./src/components/Dropdown/index.js":
/*!******************************************!*\
  !*** ./src/components/Dropdown/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dropdown: function() { return /* reexport safe */ _Dropdown__WEBPACK_IMPORTED_MODULE_0__.Dropdown; },
/* harmony export */   DropdownItemType: function() { return /* reexport safe */ _DropdownItem__WEBPACK_IMPORTED_MODULE_1__.DropdownItemType; }
/* harmony export */ });
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dropdown */ "./src/components/Dropdown/Dropdown.jsx");
/* harmony import */ var _DropdownItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DropdownItem */ "./src/components/Dropdown/DropdownItem.jsx");



/***/ }),

/***/ "./src/components/File/File.jsx":
/*!**************************************!*\
  !*** ./src/components/File/File.jsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: function() { return /* binding */ File; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
/* harmony import */ var _FilePreview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FilePreview */ "./src/components/File/FilePreview.jsx");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./src/components/File/constants.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["title", "labelIcon", "labelText", "description", "error", "file", "onChange"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





// todo: select multiple files


var File = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref, extRef) {
  var title = _ref.title,
    _ref$labelIcon = _ref.labelIcon,
    labelIcon = _ref$labelIcon === void 0 ? "clip" : _ref$labelIcon,
    _ref$labelText = _ref.labelText,
    labelText = _ref$labelText === void 0 ? "Прикрепить" : _ref$labelText,
    description = _ref.description,
    error = _ref.error,
    _ref$file = _ref.file,
    initFile = _ref$file === void 0 ? null : _ref$file,
    onChange = _ref.onChange,
    otherProps = _objectWithoutProperties(_ref, _excluded);
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initFile),
    _useState2 = _slicedToArray(_useState, 2),
    file = _useState2[0],
    setFile = _useState2[1];
  var currFileRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null); //?! is needed (use inputRef???)
  var actionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_1__.useFormControlRef)(extRef, function (el) {
      return {
        el: el,
        getValue: function getValue() {
          return currFileRef.current;
        },
        setValue: function setValue(file) {
          if (file) {
            // todo: combine setFile and currFileRef.current set to one func
            setFile(file);
            currFileRef.current = file;
            return;
          }

          // reset
          setFile(null);
          currFileRef.current = null;
        }
      };
    }),
    inputRef = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;

  // handle add/change
  var handleChange = function handleChange(event) {
    var _el$files$;
    var el = event.target;

    //???
    if (actionRef.current === _constants__WEBPACK_IMPORTED_MODULE_3__.FileAction.Change && !el.files.length) return;
    var file = (_el$files$ = el.files[0]) !== null && _el$files$ !== void 0 ? _el$files$ : null;
    setFile(file);
    currFileRef.current = file;
    onChange === null || onChange === void 0 || onChange(file, event);
  };
  var handleAction = function handleAction(event) {
    var el = event.target;
    var inputEl = inputRef.current.el;
    if (el !== inputEl) {
      event.preventDefault();
      event.stopPropagation();
    }
    var action = el.dataset.action;
    if (!action) return;

    // save current action
    actionRef.current = action;
    switch (action) {
      case _constants__WEBPACK_IMPORTED_MODULE_3__.FileAction.Add:
      case _constants__WEBPACK_IMPORTED_MODULE_3__.FileAction.Change:
        inputEl.click();
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_3__.FileAction.Remove:
        inputEl.value = null;
        inputEl.dispatchEvent(new Event("change", {
          bubbles: true
        })); //??? bubbles

        break;
    }
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("label", {
    className: "upload",
    onClick: handleAction,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("input", _objectSpread({
      type: "file",
      ref: callbackRef,
      className: "upload__control",
      onChange: handleChange
    }, otherProps)), !file && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("span", {
      "data-action": _constants__WEBPACK_IMPORTED_MODULE_3__.FileAction.Add,
      className: "upload__label button button_plain button_icontext",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("svg", {
        className: "icon button__icon",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          href: "uikit/icon/icons.svg#".concat(labelIcon)
        })
      }), labelText]
    }), title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "upload__title",
      children: title
    }), error && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "upload__error",
      children: error
    }), description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "upload__description",
      children: description
    }), file && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "upload__info",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_FilePreview__WEBPACK_IMPORTED_MODULE_2__.FilePreview, {
        file: file,
        edit: true,
        remove: true
      })
    })]
  });
}));

/***/ }),

/***/ "./src/components/File/FilePreview.jsx":
/*!*********************************************!*\
  !*** ./src/components/File/FilePreview.jsx ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilePreview: function() { return /* binding */ FilePreview; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./src/components/File/constants.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





var DownloadButton = function DownloadButton(_ref) {
  var url = _ref.file.url,
    _ref$downloadName = _ref.downloadName,
    downloadName = _ref$downloadName === void 0 ? true : _ref$downloadName;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("a", {
    className: "button button_icontext button_plain",
    download: downloadName,
    href: url,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("svg", {
      className: "icon button__icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("use", {
        href: "uikit/icon/icons.svg#download"
      })
    }), "\u0421\u043A\u0430\u0447\u0430\u0442\u044C"]
  });
};
var EditButton = function EditButton() {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
    "data-action": _constants__WEBPACK_IMPORTED_MODULE_2__.FileAction.Change,
    className: "file-preview__action button button_plain",
    type: "button",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("svg", {
      className: "icon button__icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("use", {
        href: "uikit/icon/icons.svg#pen"
      })
    })
  });
};
var RemoveButton = function RemoveButton() {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
    "data-action": _constants__WEBPACK_IMPORTED_MODULE_2__.FileAction.Remove,
    className: "button-close file-preview__action",
    type: "button",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("svg", {
      className: "icon button__icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("use", {
        href: "uikit/icon/icons.svg#close"
      })
    })
  });
};
var ActionButtons = function ActionButtons(props) {
  var _props$edit = props.edit,
    edit = _props$edit === void 0 ? false : _props$edit,
    _props$remove = props.remove,
    remove = _props$remove === void 0 ? false : _props$remove,
    _props$file$url = props.file.url,
    url = _props$file$url === void 0 ? "" : _props$file$url;
  var Components = _objectSpread(_objectSpread(_objectSpread({}, edit && {
    edit: EditButton
  }), remove && {
    remove: RemoveButton
  }), url && {
    download: DownloadButton
  });
  var hasActions = Object.keys(Components).length > 0;
  return hasActions ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
    className: "file-preview__actions",
    children: Object.entries(Components).map(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        Component = _ref3[1];
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, _objectSpread({}, props), key);
    })
  }) : null;
};
var Info = function Info(_ref4) {
  var _ref4$file = _ref4.file,
    name = _ref4$file.name,
    size = _ref4$file.size;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("span", {
    className: "file-preview__wrapper",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("a", {
      className: "file-preview__name link",
      href: "#",
      target: "_blank",
      children: name
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
      className: "file-preview__data",
      children: size
    })]
  });
};
var FilePreview = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (props) {
  var file = props.file;
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("file-preview", {
    "file-preview_extended": Boolean(file.url)
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("span", {
    className: classNames,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("img", {
      className: "file-preview__type-img",
      src: "uikit/file-preview/pdf.svg",
      width: "32",
      height: "32",
      alt: "\u0424\u0430\u0439\u043B"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Info, {
      file: file
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ActionButtons, _objectSpread({}, props))]
  });
});

/***/ }),

/***/ "./src/components/File/constants.js":
/*!******************************************!*\
  !*** ./src/components/File/constants.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileAction: function() { return /* binding */ FileAction; }
/* harmony export */ });
var FileAction = {
  Add: "add",
  Change: "change",
  Remove: "remove"
};

/***/ }),

/***/ "./src/components/File/index.js":
/*!**************************************!*\
  !*** ./src/components/File/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: function() { return /* reexport safe */ _File__WEBPACK_IMPORTED_MODULE_1__.File; },
/* harmony export */   FilePreview: function() { return /* reexport safe */ _FilePreview__WEBPACK_IMPORTED_MODULE_0__.FilePreview; }
/* harmony export */ });
/* harmony import */ var _FilePreview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FilePreview */ "./src/components/File/FilePreview.jsx");
/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./File */ "./src/components/File/File.jsx");



/***/ }),

/***/ "./src/components/FileList/FileList.jsx":
/*!**********************************************!*\
  !*** ./src/components/FileList/FileList.jsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileList: function() { return /* binding */ FileList; },
/* harmony export */   getId: function() { return /* binding */ getId; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../File */ "./src/components/File/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var getId = function getId() {
  return Math.ceil(1e10 * Math.random()).toString();
};
var getFileInfo = function getFileInfo(file) {
  return _objectSpread({
    id: getId()
  }, _.pick(file, ["id", "name", "size", "type"]));
};
var mockFile = null;
var FileList = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref) {
  var title = _ref.title,
    description = _ref.description,
    _ref$files = _ref.files,
    initFiles = _ref$files === void 0 ? [] : _ref$files,
    onChange = _ref.onChange,
    _ref$max = _ref.max,
    max = _ref$max === void 0 ? Number.POSITIVE_INFINITY : _ref$max;
  //! heres is uncontrolled variant
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initFiles),
    _useState2 = _slicedToArray(_useState, 2),
    files = _useState2[0],
    setFiles = _useState2[1];
  var handleChange = function handleChange() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var file = arguments.length > 1 ? arguments[1] : undefined;
    setFiles(function (files) {
      if (!id) return [].concat(_toConsumableArray(files), [getFileInfo(file)]);else if (!file) return files.filter(function (f) {
        return f.id !== id;
      });else return files.map(function (f) {
        return f.id === id ? getFileInfo(file) : f;
      });
    });
    onChange({
      id: id,
      file: file
    });
  };
  var canAdd = files.length < max;
  var filesToRender = _toConsumableArray(files).concat(canAdd ? mockFile : []);
  return filesToRender.map(function (file, index) {
    var _ref2 = file !== null && file !== void 0 ? file : {},
      id = _ref2.id;
    var isFirst = index === 0;
    return (
      /*#__PURE__*/
      // <FilePreview file={file} />
      (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_File__WEBPACK_IMPORTED_MODULE_1__.File, {
        //??? need random id
        file: file,
        title: isFirst && title,
        description: isFirst && description,
        onChange: function onChange(newFile) {
          return handleChange(id, newFile);
        }
      }, id !== null && id !== void 0 ? id : getId())
    );
  });
});

/***/ }),

/***/ "./src/components/FileList/index.js":
/*!******************************************!*\
  !*** ./src/components/FileList/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileList: function() { return /* reexport safe */ _FileList__WEBPACK_IMPORTED_MODULE_0__.FileList; }
/* harmony export */ });
/* harmony import */ var _FileList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FileList */ "./src/components/FileList/FileList.jsx");


/***/ }),

/***/ "./src/components/Form/Form.jsx":
/*!**************************************!*\
  !*** ./src/components/Form/Form.jsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Form: function() { return /* binding */ Form; },
/* harmony export */   FormDescription: function() { return /* binding */ FormDescription; },
/* harmony export */   FormFieldset: function() { return /* binding */ FormFieldset; },
/* harmony export */   FormSection: function() { return /* binding */ FormSection; },
/* harmony export */   FormTitle: function() { return /* binding */ FormTitle; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["className", "children"],
  _excluded2 = ["className", "children"],
  _excluded3 = ["className", "children"],
  _excluded4 = ["className", "children"],
  _excluded5 = ["className", "required", "tag", "children"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


// todo: form__descripted (variant)
// todo: recreate all examples from uikit

var Form = function Form(_ref) {
  var className = _ref.className,
    children = _ref.children,
    otherProps = _objectWithoutProperties(_ref, _excluded);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("form", className, {});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("form", _objectSpread(_objectSpread({
    className: classNames
  }, otherProps), {}, {
    children: children
  }));
};
var FormSection = function FormSection(_ref2) {
  var className = _ref2.className,
    children = _ref2.children,
    otherProps = _objectWithoutProperties(_ref2, _excluded2);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("form__section", className, {});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread(_objectSpread({
    className: classNames
  }, otherProps), {}, {
    children: children
  }));
};
var FormDescription = function FormDescription(_ref3) {
  var className = _ref3.className,
    children = _ref3.children,
    otherProps = _objectWithoutProperties(_ref3, _excluded3);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("form__description", className, {});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread(_objectSpread({
    className: classNames
  }, otherProps), {}, {
    children: children
  }));
};
var FormFieldset = function FormFieldset(_ref4) {
  var className = _ref4.className,
    children = _ref4.children,
    otherProps = _objectWithoutProperties(_ref4, _excluded4);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("form__fieldset", className, {});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("fieldset", _objectSpread(_objectSpread({
    className: classNames
  }, otherProps), {}, {
    children: children
  }));
};
var FormTitle = function FormTitle(_ref5) {
  var className = _ref5.className,
    required = _ref5.required,
    _ref5$tag = _ref5.tag,
    Tag = _ref5$tag === void 0 ? "legend" : _ref5$tag,
    children = _ref5.children,
    otherProps = _objectWithoutProperties(_ref5, _excluded5);
  var mainClassName = "form__title";
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()(mainClassName, className, _defineProperty({}, "".concat(mainClassName, "_required"), required));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tag, _objectSpread(_objectSpread({
    className: classNames
  }, otherProps), {}, {
    children: children
  }));
};
Object.assign(Form, {
  Section: FormSection,
  Description: FormDescription,
  Fieldset: FormFieldset,
  Title: FormTitle
});

/***/ }),

/***/ "./src/components/Form/index.js":
/*!**************************************!*\
  !*** ./src/components/Form/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Form: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.Form; },
/* harmony export */   FormDescription: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormDescription; },
/* harmony export */   FormFieldset: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormFieldset; },
/* harmony export */   FormSection: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormSection; },
/* harmony export */   FormTitle: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormTitle; }
/* harmony export */ });
/* harmony import */ var _Form__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Form */ "./src/components/Form/Form.jsx");


/***/ }),

/***/ "./src/components/Grid/Col.jsx":
/*!*************************************!*\
  !*** ./src/components/Grid/Col.jsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Col: function() { return /* binding */ Col; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _excluded = ["className", "cssModule", "widths", "tag"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var colWidths = ["xs", "sm", "md", "lg", "xl", "xxl"];
var getColumnSizeClass = function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : "col-".concat(colWidth);
  }
  if (colSize === "auto") {
    return isXs ? "col-auto" : "col-".concat(colWidth, "-auto");
  }
  return isXs ? "col-".concat(colSize) : "col-".concat(colWidth, "-").concat(colSize);
};
var getColumnClasses = function getColumnClasses(attributes) {
  var widths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : colWidths;
  var modifiedAttributes = attributes;
  var colClasses = [];
  widths.forEach(function (colWidth, i) {
    var columnProp = modifiedAttributes[colWidth];
    delete modifiedAttributes[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    var isXs = !i;
    if (_.isObject(columnProp)) {
      var colSizeInterfix = isXs ? "-" : "-".concat(colWidth, "-");
      var colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(classnames__WEBPACK_IMPORTED_MODULE_0___default()(_defineProperty(_defineProperty(_defineProperty({}, colClass, columnProp.size || columnProp.size === ""), "order".concat(colSizeInterfix).concat(columnProp.order), columnProp.order || columnProp.order === 0), "offset".concat(colSizeInterfix).concat(columnProp.offset), columnProp.offset || columnProp.offset === 0)));
    } else {
      var _colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(_colClass);
    }
  });
  return {
    colClasses: colClasses,
    modifiedAttributes: modifiedAttributes
  };
};

// todo: rm cssModule
var Col = function Col(_ref) {
  var className = _ref.className,
    cssModule = _ref.cssModule,
    _ref$widths = _ref.widths,
    widths = _ref$widths === void 0 ? colWidths : _ref$widths,
    _ref$tag = _ref.tag,
    Tag = _ref$tag === void 0 ? "div" : _ref$tag,
    attributes = _objectWithoutProperties(_ref, _excluded);
  var _getColumnClasses = getColumnClasses(attributes, cssModule, widths),
    modifiedAttributes = _getColumnClasses.modifiedAttributes,
    colClasses = _getColumnClasses.colClasses;
  if (!colClasses.length) {
    colClasses.push("col");
  }
  var classes = classnames__WEBPACK_IMPORTED_MODULE_0___default()(className, colClasses);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tag, _objectSpread(_objectSpread({}, modifiedAttributes), {}, {
    className: classes
  }));
};

/***/ }),

/***/ "./src/components/Grid/Container.jsx":
/*!*******************************************!*\
  !*** ./src/components/Grid/Container.jsx ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Container: function() { return /* binding */ Container; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["tag", "fluid", "className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var Container = function Container(_ref) {
  var _ref$tag = _ref.tag,
    Tag = _ref$tag === void 0 ? "div" : _ref$tag,
    fluid = _ref.fluid,
    className = _ref.className,
    otherProps = _objectWithoutProperties(_ref, _excluded);
  var containerClass = "container";

  // ???
  if (fluid === true) {
    containerClass = "container-fluid";
    //todo: in uikit only fluid container (no sm, md, ...)
  } else if (fluid) {
    containerClass = "container-".concat(fluid);
  }
  var classes = classnames__WEBPACK_IMPORTED_MODULE_0___default()(className, containerClass);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tag, _objectSpread(_objectSpread({}, otherProps), {}, {
    className: classes
  }));
};

/***/ }),

/***/ "./src/components/Grid/Row.jsx":
/*!*************************************!*\
  !*** ./src/components/Grid/Row.jsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Row: function() { return /* binding */ Row; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["className", "noGutters", "tag", "widths"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



var rowColWidths = ["xs", "sm", "md", "lg", "xl", "xxl"];
var Row = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {
  var className = props.className,
    noGutters = props.noGutters,
    _props$tag = props.tag,
    Tag = _props$tag === void 0 ? "div" : _props$tag,
    _props$widths = props.widths,
    widths = _props$widths === void 0 ? rowColWidths : _props$widths,
    otherProps = _objectWithoutProperties(props, _excluded);
  var colClasses = [];
  widths.forEach(function (colWidth, i) {
    var colSize = props[colWidth];
    delete otherProps[colWidth];
    if (!colSize) {
      return;
    }
    var isXs = !i;
    // todo: no row-cols in uikit
    colClasses.push(isXs ? "row-cols-".concat(colSize) : "row-cols-".concat(colWidth, "-").concat(colSize));
  });
  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()(className, noGutters ? "gx-0" : null, "row", colClasses);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Tag, _objectSpread({
    ref: ref,
    className: classes
  }, otherProps));
});

/***/ }),

/***/ "./src/components/Grid/index.js":
/*!**************************************!*\
  !*** ./src/components/Grid/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Col: function() { return /* reexport safe */ _Col__WEBPACK_IMPORTED_MODULE_0__.Col; },
/* harmony export */   Container: function() { return /* reexport safe */ _Container__WEBPACK_IMPORTED_MODULE_2__.Container; },
/* harmony export */   Row: function() { return /* reexport safe */ _Row__WEBPACK_IMPORTED_MODULE_1__.Row; }
/* harmony export */ });
/* harmony import */ var _Col__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Col */ "./src/components/Grid/Col.jsx");
/* harmony import */ var _Row__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Row */ "./src/components/Grid/Row.jsx");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Container */ "./src/components/Grid/Container.jsx");




/***/ }),

/***/ "./src/components/GroupContainer/GroupContainer.jsx":
/*!**********************************************************!*\
  !*** ./src/components/GroupContainer/GroupContainer.jsx ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupContainer: function() { return /* binding */ GroupContainer; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");



var GroupContainer = function GroupContainer(_ref) {
  var className = _ref.className,
    children = _ref.children;
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("group-container", className);
  var modifyChildren = function modifyChildren(child) {
    var className = classnames__WEBPACK_IMPORTED_MODULE_1___default()(child.props.className, "group-container__item");
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(child, {
      className: className
    });
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
    className: classNames,
    children: react__WEBPACK_IMPORTED_MODULE_0___default().Children.map(children, modifyChildren)
  });
};

/***/ }),

/***/ "./src/components/GroupContainer/index.js":
/*!************************************************!*\
  !*** ./src/components/GroupContainer/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupContainer: function() { return /* reexport safe */ _GroupContainer__WEBPACK_IMPORTED_MODULE_0__.GroupContainer; }
/* harmony export */ });
/* harmony import */ var _GroupContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GroupContainer */ "./src/components/GroupContainer/GroupContainer.jsx");


/***/ }),

/***/ "./src/components/Input/Input.jsx":
/*!****************************************!*\
  !*** ./src/components/Input/Input.jsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Input: function() { return /* binding */ _Input; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inputmask */ "./node_modules/inputmask/dist/inputmask.js");
/* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(inputmask__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["title", "error", "type", "maskOptions", "placeholder", "onChange", "onBlur", "onSubmit", "className", "value", "defaultValue"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



//! будет тащиться в каждый бандл
//! подумать о динамически подгружаемых либах и динамически подгружаемых компонентах
 // todo: check version with existing

// todo: useInputMask hook
// todo: useDateinput hook
// todo: use const for format (and option)
// todo: use constants for input type: text, search, date
// todo: update dp to use silent option (is needed here?)
// todo: hook useInputmask

//? будет вопрос, почему просто не использовать jsdoc

/**
 * @param {{
 *    title?: string,
 *    error?: string
 *    maskOptions?: Record<"string", any>
 *    onChange?: () => {}
 *    className?: string
 *    value?: "string"
 *    defaultValue?: string
 * } & import('react').HTMLAttributes<HTMLInputElement>} props
 */
// ??? why no `placeholder` attribute ???


function Input(_ref, extRef) {
  var title = _ref.title,
    error = _ref.error,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? "text" : _ref$type,
    maskOptions = _ref.maskOptions,
    placeholder = _ref.placeholder,
    onChange = _ref.onChange,
    onBlur = _ref.onBlur,
    onSubmit = _ref.onSubmit,
    className = _ref.className,
    value = _ref.value,
    defaultValue = _ref.defaultValue,
    inputOptions = _objectWithoutProperties(_ref, _excluded);
  // todo!: вернуть назад
  // const { ref, callbackRef } = useFormControlRef(extRef, (el) => ({
  //     el,
  //     getValue: () => el.value,
  //     setValue: (value = "") => {
  //         el.value = value;
  //     },
  //     //! setError?
  // }));

  var _ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    //! don't work React onChange witn jquery inputmask
    // https://github.com/RobinHerbots/Inputmask/issues/1377
    var im = null;
    if (maskOptions) {
      im = new (inputmask__WEBPACK_IMPORTED_MODULE_2___default())(maskOptions);
      im.mask(_ref2.current.el);
    }
    return function () {
      var _im, _ref$current;
      (_im = im) === null || _im === void 0 || _im.remove(_ref2.current);
      // restore default placeholder
      if ((_ref$current = _ref2.current) !== null && _ref$current !== void 0 && _ref$current.el && placeholder) _ref2.current.el.placeholder = placeholder;
    };
  }, [JSON.stringify(maskOptions)]);
  var handleChange = function handleChange(event) {
    onChange === null || onChange === void 0 || onChange(_ref2.current.getValue(), event);
  };
  var handleKeyDown = function handleKeyDown(event) {
    if (event.key === "Enter") {
      onSubmit === null || onSubmit === void 0 || onSubmit(_ref2.current.getValue(), event);
    }
  };
  var handleBlur = function handleBlur(event) {
    onBlur === null || onBlur === void 0 || onBlur(event);
  };
  var isSearch = type === "search";
  var labelClassNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("input", {
    input_error: error,
    input_search: isSearch
  }, className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("label", {
    className: labelClassNames,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("input", _objectSpread({
      // ref={callbackRef}
      ref: function ref(el) {
        return _ref2.current = el;
      },
      type: type,
      value: value,
      defaultValue: defaultValue,
      onChange: handleChange,
      onKeyDown: handleKeyDown // for search input type
      ,
      onBlur: handleBlur,
      className: "input__control",
      autoComplete: "off",
      placeholder: placeholder
    }, inputOptions)), isSearch && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
      type: "submit",
      className: "input__search-button"
    }), title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
      className: "input__title",
      children: title
    }), error && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
      className: "input__error",
      children: error
    })]
  });
}
var _Input = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(Input), _.isEqual);


/***/ }),

/***/ "./src/components/Input/index.js":
/*!***************************************!*\
  !*** ./src/components/Input/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Input: function() { return /* reexport safe */ _Input__WEBPACK_IMPORTED_MODULE_0__.Input; }
/* harmony export */ });
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Input */ "./src/components/Input/Input.jsx");


/***/ }),

/***/ "./src/components/List/List.jsx":
/*!**************************************!*\
  !*** ./src/components/List/List.jsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   List: function() { return /* binding */ List; },
/* harmony export */   ListType: function() { return /* binding */ ListType; },
/* harmony export */   OList: function() { return /* binding */ OList; },
/* harmony export */   OrderedListType: function() { return /* binding */ OrderedListType; },
/* harmony export */   UList: function() { return /* binding */ UList; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["tag", "className"],
  _excluded2 = ["type", "letter", "bracket", "className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var ListType = {
  Ordered: "ordered",
  Unordered: "unordered"
};
var OrderedListType = {
  Bracked: "bracked",
  Letter: "letter"
};
var Item = function Item(_ref) {
  var _ref$tag = _ref.tag,
    Tag = _ref$tag === void 0 ? "li" : _ref$tag,
    className = _ref.className,
    otherProps = _objectWithoutProperties(_ref, _excluded);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("list__item", className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tag, _objectSpread({
    className: classNames
  }, otherProps));
};
var List = function List(_ref2) {
  var _ref2$type = _ref2.type,
    type = _ref2$type === void 0 ? ListType.Unordered : _ref2$type,
    letter = _ref2.letter,
    bracket = _ref2.bracket,
    className = _ref2.className,
    props = _objectWithoutProperties(_ref2, _excluded2);
  var isOrdered = type === ListType.Ordered;
  var Tag = isOrdered ? "ol" : "ul";
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("list", className, {
    list_ordered: isOrdered,
    "list_ordered-letter": letter,
    // todo: orderedListType prop
    "list_ordered-bracket": bracket
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tag, _objectSpread({
    className: classNames
  }, props));
};
var OList = function OList(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(List, _objectSpread(_objectSpread({}, props), {}, {
    type: ListType.Ordered
  }));
};
var UList = function UList(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(List, _objectSpread(_objectSpread({}, props), {}, {
    type: ListType.Unordered
  }));
};
List.Item = Item;
OList.Item = Item;
UList.Item = Item;

/***/ }),

/***/ "./src/components/List/index.js":
/*!**************************************!*\
  !*** ./src/components/List/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   List: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_0__.List; },
/* harmony export */   ListType: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_0__.ListType; },
/* harmony export */   OList: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_0__.OList; },
/* harmony export */   UList: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_0__.UList; }
/* harmony export */ });
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ "./src/components/List/List.jsx");


/***/ }),

/***/ "./src/components/Loader/Loader.jsx":
/*!******************************************!*\
  !*** ./src/components/Loader/Loader.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Loader: function() { return /* binding */ Loader; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var Loader = function Loader(_ref) {
  var className = _ref.className,
    props = _objectWithoutProperties(_ref, _excluded);
  var classes = classnames__WEBPACK_IMPORTED_MODULE_0___default()("loader", className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread({
    className: classes
  }, props));
};

/***/ }),

/***/ "./src/components/Loader/index.js":
/*!****************************************!*\
  !*** ./src/components/Loader/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Loader: function() { return /* reexport safe */ _Loader__WEBPACK_IMPORTED_MODULE_0__.Loader; }
/* harmony export */ });
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Loader */ "./src/components/Loader/Loader.jsx");


/***/ }),

/***/ "./src/components/Modal/Modal.jsx":
/*!****************************************!*\
  !*** ./src/components/Modal/Modal.jsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alert: function() { return /* binding */ Alert; },
/* harmony export */   Confirm: function() { return /* binding */ Confirm; },
/* harmony export */   Dialog: function() { return /* binding */ Dialog; },
/* harmony export */   Modal: function() { return /* binding */ Modal; },
/* harmony export */   ModalVariant: function() { return /* binding */ ModalVariant; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Portal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Portal */ "./src/components/Portal/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




// todo: close on ESC dont work
// todo: use Portal
// todo: validation
// todo: dont close on outside
// todo: theme: Danger
// todo: crt modal
// todo: close button hide
// todo: with proptypes dont need constants ???
// todo: dont close events when disabled
// todo: multiple confirm
// todo: bootstrap modal events



var ModalVariant = {
  Modal: "modal",
  Dialog: "dialog"
};

// const ModalType = {
//     Alert: "alert",
//     Confirm: "confirm",
// };

var ModalEvent = {
  Hide: "hide.bs.modal"
};
var DefaultHeaderContent = function DefaultHeaderContent(_ref) {
  var title = _ref.title,
    icon = _ref.icon,
    disabled = _ref.disabled;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
      className: "modal__header-box",
      children: [icon && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("svg", {
        className: "icon icon_brand modal__header-icon",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("use", {
          href: "/assets/redesign-theme/uikit/icon/icons.svg#".concat(icon)
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("h2", {
        className: "modal__title",
        children: title
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
      type: "button",
      disabled: disabled,
      className: "modal__close",
      "data-dismiss": "modal"
    })]
  });
};
var DefaultFooterContent = function DefaultFooterContent(_ref2) {
  var _ref2$confirmLabel = _ref2.confirmLabel,
    confirmLabel = _ref2$confirmLabel === void 0 ? "OK" : _ref2$confirmLabel,
    _ref2$cancelLabel = _ref2.cancelLabel,
    cancelLabel = _ref2$cancelLabel === void 0 ? "Отменить" : _ref2$cancelLabel,
    disabled = _ref2.disabled,
    onConfirm = _ref2.onConfirm;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
    className: "group-container",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
      type: "button",
      disabled: disabled,
      className: "button button_secondary group-container__item",
      "data-dismiss": "modal",
      title: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C \u0434\u0438\u0430\u043B\u043E\u0433\u043E\u0432\u043E\u0435 \u043E\u043A\u043D\u043E",
      children: cancelLabel
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
      type: "button",
      disabled: disabled,
      className: "button group-container__item",
      onClick: onConfirm,
      children: confirmLabel
    })]
  });
};
var renderHeader = function renderHeader(props) {
  var _props$hasHeader = props.hasHeader,
    hasHeader = _props$hasHeader === void 0 ? true : _props$hasHeader;
  return hasHeader ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
    className: "modal__header",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DefaultHeaderContent, _objectSpread({}, props))
  }) : null;
};
var renderFooter = function renderFooter(props) {
  var _props$hasFooter = props.hasFooter,
    hasFooter = _props$hasFooter === void 0 ? true : _props$hasFooter;
  return hasFooter ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
    className: "modal__footer",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DefaultFooterContent, _objectSpread({}, props))
  }) : null;
};
var renderBody = function renderBody(props) {
  var children = props.children;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
    className: "modal__body",
    children: children
  });
};

// todo: lazy
var Modal = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (props) {
  var open = props.open,
    onClose = props.onClose,
    _props$variant = props.variant,
    variant = _props$variant === void 0 ? ModalVariant.Modal : _props$variant,
    element = props.element,
    _props$lazy = props.lazy,
    lazy = _props$lazy === void 0 ? true : _props$lazy;
  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    isMounted = _useState2[0],
    setIsMounted = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!isMounted && open) {
      setIsMounted(true);
    }
  }, [open]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!ref.current) return;
    var $modal = $(ref.current);
    if (open) {
      $modal.on(ModalEvent.Hide, function () {
        return onClose === null || onClose === void 0 ? void 0 : onClose();
      });
    }
    $modal.modal(open ? "show" : "hide");
    return function () {
      return $modal.off(ModalEvent.Hide);
    };
  }, [open, isMounted]);
  var modalClassNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("modal", _defineProperty({}, "modal_dialog", variant === ModalVariant.Dialog));
  if (lazy && !isMounted) return null;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_Portal__WEBPACK_IMPORTED_MODULE_2__.Portal, {
    element: element,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      ref: ref,
      className: modalClassNames,
      tabIndex: "-1",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: "modal__content",
        children: [renderHeader(props), renderBody(props), renderFooter(props)]
      })
    })
  });
});

// todo
var Dialog = function Dialog() {};
var Alert = function Alert() {};
var Confirm = function Confirm() {};

/***/ }),

/***/ "./src/components/Modal/index.js":
/*!***************************************!*\
  !*** ./src/components/Modal/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Modal: function() { return /* reexport safe */ _Modal__WEBPACK_IMPORTED_MODULE_0__.Modal; },
/* harmony export */   ModalVariant: function() { return /* reexport safe */ _Modal__WEBPACK_IMPORTED_MODULE_0__.ModalVariant; }
/* harmony export */ });
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Modal */ "./src/components/Modal/Modal.jsx");


/***/ }),

/***/ "./src/components/Notification/Notification.jsx":
/*!******************************************************!*\
  !*** ./src/components/Notification/Notification.jsx ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Notification: function() { return /* binding */ Notification; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


// todo: title icon


var Notification = function Notification(_ref) {
  var id = _ref.id,
    title = _ref.title,
    content = _ref.content,
    icon = _ref.icon,
    _ref$visibleCloseButt = _ref.visibleCloseButton,
    visibleCloseButton = _ref$visibleCloseButt === void 0 ? true : _ref$visibleCloseButt,
    type = _ref.type;
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("notifications__card", _defineProperty({}, "notifications__card_".concat(type), type));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: classNames,
    children: [icon && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "notifications__card-icon",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
        className: "icon icon_in-text",
        id: "question",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("use", {
          href: "/assets/redesign-theme/uikit/icon/icons.svg#".concat(icon)
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "notifications__card-title",
      children: title
    }), content && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "notifications__card-content",
      children: content
    }), visibleCloseButton && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("button", {
      type: "button",
      "data-id": id,
      className: "button-close notifications__card-close",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
        className: "button__icon icon icon_m",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("use", {
          href: "/assets/redesign-theme/uikit/icon/icons.svg#close"
        })
      })
    })]
  });
};

/***/ }),

/***/ "./src/components/Notification/NotificationContainer.jsx":
/*!***************************************************************!*\
  !*** ./src/components/Notification/NotificationContainer.jsx ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotificationContainer: function() { return /* binding */ NotificationContainer; },
/* harmony export */   notification: function() { return /* binding */ notification; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Portal */ "./src/components/Portal/index.js");
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Notification */ "./src/components/Notification/Notification.jsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




// todo: title icon
// todo: content markup
// todo: removeAll
// todo: add icon

// todo: как удобно передавать настройки??? (see toastify)

// {% set classNameName = (type=="info")? "accent" : type  %}
// {% set iconAttr = (type=="success")? type : "question" %}

var Type = {
  Accent: "accent",
  Warning: "warning",
  Danger: "danger",
  Success: "success"
};
var fn = {};
var show = function show(data) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? Type.Accent : _ref$type;
  var addItem = fn.addItem;
  var id = new Date().getTime();
  var item = {
    id: id,
    title: id,
    type: type
  };
  addItem(item);

  // todo: removeTimeout
  // setTimeout(() => removeItem(id), 5000); // todo: options
};
var notification = {
  info: function info(data) {
    return show(data, {
      type: Type.Accent
    });
  },
  success: function success(data) {
    return show(data, {
      type: Type.Success
    });
  },
  danger: function danger(data) {
    return show(data, {
      type: Type.Danger
    });
  },
  warning: function warning(data) {
    return show(data, {
      type: Type.Warning
    });
  }
};
var NotificationContainer = function NotificationContainer(_ref2) {
  var element = _ref2.element;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
    _useState2 = _slicedToArray(_useState, 2),
    items = _useState2[0],
    setItems = _useState2[1];
  var addItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (item) {
    setItems(function (items) {
      return [item].concat(_toConsumableArray(items));
    });
  }, []);
  var removeItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (id) {
    setItems(function (items) {
      return items.filter(function (item) {
        return item.id !== id;
      });
    }, []);
  });
  var handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (event) {
    var _$$data = $(event.target).data(),
      id = _$$data.id;
    // todo: removeTimeout if any
    if (id) removeItem(id);
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    fn.addItem = addItem;
    fn.removeItem = removeItem;
  }, []);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_Portal__WEBPACK_IMPORTED_MODULE_1__.Portal, {
    element: element,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      className: "notifications",
      onClick: handleClose,
      children: items.map(function (item) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_Notification__WEBPACK_IMPORTED_MODULE_2__.Notification, _objectSpread(_objectSpread({}, item), {}, {
          onClose: handleClose
        }), item.id);
      })
    })
  });
};

/***/ }),

/***/ "./src/components/Notification/index.js":
/*!**********************************************!*\
  !*** ./src/components/Notification/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotificationContainer: function() { return /* reexport safe */ _NotificationContainer__WEBPACK_IMPORTED_MODULE_0__.NotificationContainer; },
/* harmony export */   notification: function() { return /* reexport safe */ _NotificationContainer__WEBPACK_IMPORTED_MODULE_0__.notification; }
/* harmony export */ });
/* harmony import */ var _NotificationContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NotificationContainer */ "./src/components/Notification/NotificationContainer.jsx");


/***/ }),

/***/ "./src/components/Pagination/Pagination.jsx":
/*!**************************************************!*\
  !*** ./src/components/Pagination/Pagination.jsx ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pagination: function() { return /* binding */ Pagination; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/components/Pagination/utils.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");



// todo: mv to shared utils?
// todo: don't show pagination if no data available (total = 0)



var PrevButton = function PrevButton(_ref) {
  var page = _ref.page,
    pages = _ref.pages;
  var isCurrentFirst = page === _.first(pages);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("pagination__item", "pagination__item_previous", {
    pagination__item_disabled: isCurrentFirst
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
    type: "button",
    className: classNames,
    "data-page": page - 1
  });
};
var NextButton = function NextButton(_ref2) {
  var page = _ref2.page,
    pages = _ref2.pages;
  var isCurrentLast = page === _.last(pages);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("pagination__item", "pagination__item_next", {
    pagination__item_disabled: isCurrentLast
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
    type: "button",
    className: classNames,
    "data-page": page + 1
  });
};
var Pages = function Pages(_ref3) {
  var page = _ref3.page,
    pages = _ref3.pages;
  return pages.map(function (currPage, index) {
    var classNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("pagination__item ", {
      pagination__item_active: currPage === page
    });
    return currPage === "…" ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
      className: "pagination__kebab",
      children: "\u2026"
    }, index) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("button", {
      "data-page": currPage,
      type: "button",
      className: classNames,
      children: currPage
    }, index);
  });
};

// todo: prevButtonText, nextButtonText
var Pagination = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref4) {
  var page = _ref4.page,
    pageSize = _ref4.pageSize,
    total = _ref4.total,
    delta = _ref4.delta,
    _ref4$arrows = _ref4.arrows,
    arrows = _ref4$arrows === void 0 ? true : _ref4$arrows,
    onPageChange = _ref4.onPageChange,
    className = _ref4.className;
  var pages = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.pagination)(page, Math.ceil(total / pageSize), delta);
  if (pages.length === 1) return null;
  var handleClick = function handleClick(event) {
    event.preventDefault();
    event.stopPropagation();
    var target = event.target;
    var selectedPage = target.dataset.page;
    if (!selectedPage) return;
    onPageChange(Number(selectedPage));
  };
  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()("pagination", className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
    className: classes,
    onClick: handleClick,
    children: [arrows && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(PrevButton, {
      page: page,
      pages: pages
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Pages, {
      page: page,
      pages: pages
    }), arrows && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(NextButton, {
      page: page,
      pages: pages
    })]
  });
});

/***/ }),

/***/ "./src/components/Pagination/index.js":
/*!********************************************!*\
  !*** ./src/components/Pagination/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pagination: function() { return /* reexport safe */ _Pagination__WEBPACK_IMPORTED_MODULE_0__.Pagination; }
/* harmony export */ });
/* harmony import */ var _Pagination__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pagination */ "./src/components/Pagination/Pagination.jsx");


/***/ }),

/***/ "./src/components/Pagination/utils.js":
/*!********************************************!*\
  !*** ./src/components/Pagination/utils.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pagination: function() { return /* binding */ pagination; }
/* harmony export */ });
/**
 * Генерирует набор страниц для пагинации
 * @param current {number} - текущая страница
 * @param total {number} - общее количество страниц
 * @param delta {number} - размер зазора вокруг текущей страницы
 * @param tail {number} - размер "хвостов"
 * @returns {[]}
 */
function pagination(current, total) {
  var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var tail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  // Prevent errors
  if (typeof total !== "number" || !total) {
    total = 1;
    console.warn("Pagination: param `total` is required. Autofixed");
  }
  if (current > total) {
    current = total;
    console.warn("Pagination: param `current` more than `total`. Autofixed");
  }

  // Pagination parts
  var lPart = [],
    rPart = [],
    Space = ["…"];

  // Make left part (with improve 1 ... 3 4)
  // Если между (current - delta) и (tail) есть 2 и более пунктов
  if (total >= 10 && current - delta - tail >= 2) {
    var lTail = _.range(1, tail + 1),
      lDelta;
    if (current > total - 3) {
      lDelta = _.range(total - 4, current);
    } else {
      lDelta = _.range(current - delta, current);
    }
    lPart = lPart.concat(lTail, Space, lDelta);
  } else {
    lPart = _.range(1, current);
  }

  // Make right part (with improve 6 7 ... 9)
  // Если между (current + delta) и (tail) есть 2 и более пунктов
  if (total >= 10 && total - 2 >= current + delta + tail - 1) {
    var rTail = _.range(1 + total - tail, 1 + total),
      rDelta;
    if (current < 4) {
      rDelta = _.range(1 + current, 6);
    } else {
      rDelta = _.range(1 + current, 1 + current + delta);
    }
    rPart = rPart.concat(rDelta, Space, rTail);
  } else {
    rPart = _.range(1 + current, 1 + total);
  }

  // Additional optimization
  // If current page + tails + deltas is more pages than total
  if (1 + (tail + delta) * 2 >= total) {
    return _.range(1, 1 + total);
  }
  return [].concat(lPart, current, rPart);
}

/***/ }),

/***/ "./src/components/Portal/Portal.jsx":
/*!******************************************!*\
  !*** ./src/components/Portal/Portal.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Portal: function() { return /* binding */ Portal; }
/* harmony export */ });
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_0__);


// todo: should have stories for Portal ???
var Portal = function Portal(_ref) {
  var children = _ref.children,
    _ref$element = _ref.element,
    element = _ref$element === void 0 ? document.body : _ref$element;
  return /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_0__.createPortal)(children, element);
};

/***/ }),

/***/ "./src/components/Portal/index.js":
/*!****************************************!*\
  !*** ./src/components/Portal/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Portal: function() { return /* reexport safe */ _Portal__WEBPACK_IMPORTED_MODULE_0__.Portal; }
/* harmony export */ });
/* harmony import */ var _Portal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Portal */ "./src/components/Portal/Portal.jsx");


/***/ }),

/***/ "./src/components/Radio/Radio.jsx":
/*!****************************************!*\
  !*** ./src/components/Radio/Radio.jsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Radio: function() { return /* binding */ Radio; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hooks_useElementRef__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../hooks/useElementRef */ "./src/hooks/useElementRef/index.js");
/* harmony import */ var _RadioGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RadioGroup */ "./src/components/Radio/RadioGroup.jsx");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./context */ "./src/components/Radio/context.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["label", "title", "error", "className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






// todo: optimize renders


var Radio = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {
  var label = props.label,
    title = props.title,
    error = props.error,
    className = props.className,
    otherProps = _objectWithoutProperties(props, _excluded);
  var innerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  var mergedRef = (0,_hooks_useElementRef__WEBPACK_IMPORTED_MODULE_2__.composeRef)(ref, innerRef);
  var groupContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_4__.RadioGroupContext);
  var onRadioChange = function onRadioChange(e) {
    var _props$onChange, _groupContext$onChang;
    (_props$onChange = props.onChange) === null || _props$onChange === void 0 || _props$onChange.call(props, e);
    groupContext === null || groupContext === void 0 || (_groupContext$onChang = groupContext.onChange) === null || _groupContext$onChang === void 0 || _groupContext$onChang.call(groupContext, e);
  };
  var radioProps = _objectSpread({}, otherProps);
  if (groupContext) {
    var _props$disabled;
    radioProps.name = groupContext.name;
    radioProps.onChange = onRadioChange;
    radioProps.disabled = (_props$disabled = props.disabled) !== null && _props$disabled !== void 0 ? _props$disabled : groupContext.disabled;
    if (groupContext.defaultValue) {
      radioProps.defaultChecked = props.value === groupContext.defaultValue;
    }
    if (groupContext.value) {
      radioProps.checked = props.value === groupContext.value;
    }
  }
  var labelClassNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("radio", className, {
    radio_error: error
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("label", {
    className: labelClassNames,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input", _objectSpread({
      type: "radio",
      ref: mergedRef
    }, radioProps)), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
      className: "radio__label",
      children: label
    }), title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
      className: "radio__title",
      children: title
    }), error && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
      className: "radio__error",
      children: error
    })]
  });
}));
Radio.Group = _RadioGroup__WEBPACK_IMPORTED_MODULE_3__.RadioGroup;

/***/ }),

/***/ "./src/components/Radio/RadioGroup.jsx":
/*!*********************************************!*\
  !*** ./src/components/Radio/RadioGroup.jsx ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadioGroup: function() { return /* binding */ RadioGroup; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context */ "./src/components/Radio/context.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }




// todo: optimize renders for controlled variant
// todo: show error (if any) on last Radio only
// todo: create Radios from items list prop

var RadioGroup = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, extRef) {
  var name = props.name,
    value = props.value,
    defaultValue = props.defaultValue,
    disabled = props.disabled,
    className = props.className,
    children = props.children,
    _props$component = props.component,
    Component = _props$component === void 0 ? "div" : _props$component;
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_1__.useFormControlRef)(extRef, function (el) {
      return {
        el: el,
        getValue: function getValue() {
          var checkedEl = el.querySelector("[type='radio']:checked");
          return checkedEl ? checkedEl.value : "";
        },
        setValue: function setValue(value) {
          if (value) {
            var node = el.querySelector("[type='radio'][value='".concat(value, "']"));
            node.checked = true;
            return;
          }

          // reset
          var nodes = _toConsumableArray(el.querySelectorAll("[type='radio']"));
          nodes.forEach(function (node) {
            node.checked = false;
          });
        }
      };
    }),
    ref = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;

  // todo: should return (value, event)
  var onRadioChange = function onRadioChange(event) {
    props === null || props === void 0 || props.onChange(ref.current.getValue(), event);
  };
  return (
    /*#__PURE__*/
    // todo: use Component in other components
    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, {
      ref: callbackRef,
      className: className,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_context__WEBPACK_IMPORTED_MODULE_2__.RadioGroupContext.Provider, {
        // todo: memo?
        value: {
          name: name,
          value: value,
          defaultValue: defaultValue,
          disabled: disabled,
          onChange: onRadioChange
        },
        children: children
      })
    })
  );
}));

/***/ }),

/***/ "./src/components/Radio/context.js":
/*!*****************************************!*\
  !*** ./src/components/Radio/context.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadioGroupContext: function() { return /* binding */ RadioGroupContext; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var RadioGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createContext();

/***/ }),

/***/ "./src/components/Radio/index.js":
/*!***************************************!*\
  !*** ./src/components/Radio/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Radio: function() { return /* reexport safe */ _Radio__WEBPACK_IMPORTED_MODULE_0__.Radio; }
/* harmony export */ });
/* harmony import */ var _Radio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Radio */ "./src/components/Radio/Radio.jsx");


/***/ }),

/***/ "./src/components/Select/Select.jsx":
/*!******************************************!*\
  !*** ./src/components/Select/Select.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Select: function() { return /* binding */ Select; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./src/components/Select/constants.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["value", "items", "selectpickerOptions", "title", "label", "placeholder", "error", "multiple", "disabled", "closeable", "noDecor", "onChange", "onClose", "className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






var defaultSelectpickerOptions = {};
var defaultItems = [];

// todo: "All" options for single/multiple select (how to set?)
// todo: empty option (how to set?)

var renderOptions = function renderOptions(items) {
  return items.map(function (_ref, index) {
    var value = _ref.value,
      label = _ref.label,
      groupItems = _ref.items,
      disabled = _ref.disabled,
      _ref$token = _ref.token,
      token = _ref$token === void 0 ? "" : _ref$token,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? "" : _ref$title,
      _ref$content = _ref.content,
      content = _ref$content === void 0 ? "" : _ref$content,
      _ref$subtext = _ref.subtext,
      subtext = _ref$subtext === void 0 ? "" : _ref$subtext,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      divider = _ref.divider,
      style = _ref.style;
    return groupItems ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("optgroup", {
      label: label,
      disabled: disabled,
      children: renderOptions(groupItems)
    }, label || index) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("option", {
      title: title,
      value: value,
      disabled: disabled,
      "data-tokens": token,
      "data-content": content,
      "data-subtext": subtext,
      "data-divider": divider,
      className: className,
      style: style,
      children: label
    }, value || "noValue".concat(index));
  });
};
var Select = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref2, extRef) {
  var value = _ref2.value,
    _ref2$items = _ref2.items,
    items = _ref2$items === void 0 ? defaultItems : _ref2$items,
    _ref2$selectpickerOpt = _ref2.selectpickerOptions,
    selectpickerOptions = _ref2$selectpickerOpt === void 0 ? defaultSelectpickerOptions : _ref2$selectpickerOpt,
    title = _ref2.title,
    label = _ref2.label,
    placeholder = _ref2.placeholder,
    error = _ref2.error,
    multiple = _ref2.multiple,
    disabled = _ref2.disabled,
    closeable = _ref2.closeable,
    noDecor = _ref2.noDecor,
    onChange = _ref2.onChange,
    onClose = _ref2.onClose,
    className = _ref2.className,
    selectOptions = _objectWithoutProperties(_ref2, _excluded);
  var ajaxOptions = selectpickerOptions.ajaxOptions,
    addItemsOptions = selectpickerOptions.addItemsOptions;
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_2__.useFormControlRef)(extRef, function (el) {
      return {
        el: el,
        getValue: function getValue() {
          var value = $(el).selectpicker("val");
          var options = el.options;
          var values = Array.from(options).filter(function (_ref3) {
            var selected = _ref3.selected;
            return selected;
          }).map(function (_ref4) {
            var value = _ref4.value;
            return value;
          });
          return multiple ? values : value;
        },
        setValue: function setValue(value) {
          var defaultValue = multiple ? [] : "";
          $(el).selectpicker("val", value !== null && value !== void 0 ? value : defaultValue);
        }
      };
    }),
    ref = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var $select = $(ref.current.el);
    window.initBootstrapSelect(ref.current.el, _.omit(selectpickerOptions, ["ajaxOptions", "addItemsOptions"]));

    // todo: init plugins in separate effects ???
    if (ajaxOptions) $select.ajaxSelectPicker(ajaxOptions);
    if (addItemsOptions) $select.addSelectPicker(addItemsOptions);

    // todo: is needed for useForm (?)
    // const { $button } = $select.data("selectpicker");
    // $button.removeAttr("tabindex");
    // $button
    //     .on("blur", () => {
    //         // console.log("blur button");
    //         onBlur?.({ target: { name: selectOptions.name } });
    //     })
    //     .on("focus", () => {
    //         // console.log("focus button");
    //     })
    //     .on("keydown", (event) => {
    //         if (event.key === " ") {
    //             $select.selectpicker("toggle");
    //         }
    //     });

    // add selectpicker event handlers
    // todo: check order of events
    Object.entries(selectOptions).forEach(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
        propName = _ref6[0],
        fn = _ref6[1];
      var _propName$split = propName.split("on"),
        _propName$split2 = _slicedToArray(_propName$split, 2),
        eventName = _propName$split2[1];
      if (!eventName) return;
      var eventNameUppercase = eventName.toUpperCase();
      if (eventNameUppercase in _constants__WEBPACK_IMPORTED_MODULE_3__.SelectEvent) {
        var selectpickerEventName = _constants__WEBPACK_IMPORTED_MODULE_3__.SelectEvent[eventNameUppercase];
        $select.on(selectpickerEventName, fn);
      }
    });
    return function () {
      var _$select$data;
      (_$select$data = $select.data("AddBootstrapSelect")) === null || _$select$data === void 0 || _$select$data.destroy();
      $select.off().selectpicker("destroy");
    };
  }, [value, placeholder, multiple, disabled,
  //! NOTE:
  //! используем JSON.stringify, чтобы предотвратить переинициализацию в случае, если произошел рендер (пропсы изменились, memo не помогло),
  //! но при этом объектный пропсы не были мемоизированы в клиентском коде (это распространияется также на Input, DateInput, где
  //! используются плагины air-datepicker и inputmask)
  JSON.stringify(items), JSON.stringify(selectpickerOptions), onChange]);
  var handleChange = function handleChange(event) {
    var _event$target = event.target,
      options = _event$target.options,
      value = _event$target.value;

    //! DRY (see ref)
    var values = Array.from(options).filter(function (_ref7) {
      var selected = _ref7.selected;
      return selected;
    }).map(function (_ref8) {
      var value = _ref8.value;
      return value;
    });
    onChange === null || onChange === void 0 || onChange(multiple ? values : value, event);
  };
  var labelClassNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("select", _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(closeable ? "select_closeable_error" : "select_error"), error), "select_closeable", closeable), "select_no-decor", noDecor), "select_required", selectOptions.required), className);
  var selectClassNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("select__control", {
    dropup: selectpickerOptions.dropupAuto === false
  });
  var isDisabled = disabled || !ajaxOptions && !items.length;

  // todo: use data-init=false

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("label", {
    className: labelClassNames,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("select", _objectSpread(_objectSpread({
      ref: callbackRef,
      className: selectClassNames,
      value: value,
      onChange: handleChange,
      multiple: multiple,
      disabled: isDisabled,
      title: placeholder
    }, _.omit(selectOptions, _constants__WEBPACK_IMPORTED_MODULE_3__.selectpickerEventHandlers)), {}, {
      children: renderOptions(items)
    })), closeable && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("button", {
      type: "button",
      className: "button button_plain button_icon select__close",
      onClick: onClose,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("svg", {
        className: "icon button__icon select__close-icon",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          href: "uikit/icon/icons.svg#close"
        })
      })
    }), title && !closeable && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "select__title",
      children: title
    }), label && !closeable && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "select__label",
      children: label
    }), error && !closeable && !noDecor && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
      className: "select__error",
      children: error
    })]
  });
}), _.isEqual);

/***/ }),

/***/ "./src/components/Select/constants.js":
/*!********************************************!*\
  !*** ./src/components/Select/constants.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SelectEvent: function() { return /* binding */ SelectEvent; },
/* harmony export */   selectpickerEventHandlers: function() { return /* binding */ selectpickerEventHandlers; }
/* harmony export */ });
var SelectEvent = {
  SHOW: "show.bs.select",
  SHOWN: "shown.bs.select",
  HIDE: "hide.bs.select",
  HIDDEN: "hidden.bs.select",
  LOADED: "loaded.bs.select",
  RENDERED: "rendered.bs.select",
  REFRESHED: "refreshed.bs.select",
  CHANGED: "changed.bs.select"
};
var selectpickerEventHandlers = Object.keys(SelectEvent).map(function (name) {
  var lcName = name.toLowerCase();
  return "on" + lcName[0].toUpperCase() + lcName.slice(1);
});

/***/ }),

/***/ "./src/components/Select/index.js":
/*!****************************************!*\
  !*** ./src/components/Select/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Select: function() { return /* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.Select; },
/* harmony export */   SelectEvent: function() { return /* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.SelectEvent; }
/* harmony export */ });
/* harmony import */ var _Select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Select */ "./src/components/Select/Select.jsx");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./src/components/Select/constants.js");



/***/ }),

/***/ "./src/components/Separator/Separator.jsx":
/*!************************************************!*\
  !*** ./src/components/Separator/Separator.jsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Separator: function() { return /* binding */ Separator; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var Separator = function Separator(_ref) {
  var className = _ref.className,
    wide = _ref.wide,
    vertical = _ref.vertical,
    children = _ref.children;
  var mainClass = "separator";
  var classes = classnames__WEBPACK_IMPORTED_MODULE_0___default()(mainClass, className, _defineProperty(_defineProperty({}, "".concat(mainClass, "_wide"), wide), "".concat(mainClass, "_vertical"), vertical));
  if (children) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("span", {
      className: "separator",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("span", {
        className: "separator__text",
        children: children
      })
    });
  }
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("hr", {
    className: classes
  });
};

/***/ }),

/***/ "./src/components/Separator/index.js":
/*!*******************************************!*\
  !*** ./src/components/Separator/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Separator: function() { return /* reexport safe */ _Separator__WEBPACK_IMPORTED_MODULE_0__.Separator; }
/* harmony export */ });
/* harmony import */ var _Separator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Separator */ "./src/components/Separator/Separator.jsx");


/***/ }),

/***/ "./src/components/Status/Status.jsx":
/*!******************************************!*\
  !*** ./src/components/Status/Status.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Status: function() { return /* binding */ Status; },
/* harmony export */   StatusType: function() { return /* binding */ StatusType; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Text */ "./src/components/Text/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["type", "className", "children"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



// todo: use Status.Type = {...}

var StatusType = {
  Success: "success",
  Warning: "warning",
  Danger: "danger",
  Muted: "muted"
};
var Status = function Status(_ref) {
  var _ref$type = _ref.type,
    type = _ref$type === void 0 ? StatusType.Normal : _ref$type,
    className = _ref.className,
    children = _ref.children,
    props = _objectWithoutProperties(_ref, _excluded);
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()("status", _defineProperty({}, "status_".concat(type), type), className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_Text__WEBPACK_IMPORTED_MODULE_1__.Span, _objectSpread(_objectSpread({
    className: classNames
  }, props), {}, {
    children: children
  }));
};

/***/ }),

/***/ "./src/components/Status/index.js":
/*!****************************************!*\
  !*** ./src/components/Status/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Status: function() { return /* reexport safe */ _Status__WEBPACK_IMPORTED_MODULE_0__.Status; },
/* harmony export */   StatusType: function() { return /* reexport safe */ _Status__WEBPACK_IMPORTED_MODULE_0__.StatusType; }
/* harmony export */ });
/* harmony import */ var _Status__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Status */ "./src/components/Status/Status.jsx");


/***/ }),

/***/ "./src/components/Table/Table.jsx":
/*!****************************************!*\
  !*** ./src/components/Table/Table.jsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Table: function() { return /* binding */ Table; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _TableHeader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TableHeader */ "./src/components/Table/TableHeader.jsx");
/* harmony import */ var _TableBody__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TableBody */ "./src/components/Table/TableBody.jsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");





// todo: noData icon in body (if no hide table for empty items)


var Table = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref) {
  var columns = _ref.columns,
    items = _ref.items,
    sortColumn = _ref.sortColumn,
    onSort = _ref.onSort,
    className = _ref.className;
  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()("table__wrapper", className);
  if (!items.length) return null;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: classes,
    tabIndex: "0",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("table", {
      className: "table",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_TableHeader__WEBPACK_IMPORTED_MODULE_2__.TableHeader, {
        columns: columns,
        sortColumn: sortColumn,
        onSort: onSort
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_TableBody__WEBPACK_IMPORTED_MODULE_3__.TableBody, {
        columns: columns,
        items: items
      })]
    })
  });
});

/***/ }),

/***/ "./src/components/Table/TableBody.jsx":
/*!********************************************!*\
  !*** ./src/components/Table/TableBody.jsx ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TableBody: function() { return /* binding */ TableBody; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


var TableBody = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref) {
  var columns = _ref.columns,
    items = _ref.items,
    _ref$idFieldName = _ref.idFieldName,
    idFieldName = _ref$idFieldName === void 0 ? "id" : _ref$idFieldName;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tbody", {
    className: "table__body",
    children: items.map(function (item) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tr", {
        className: "table__item",
        children: columns.map(function (col) {
          return renderCell(col, item);
        })
      }, item[idFieldName]);
    })
  });
});

/**
 * Render cell
 */
function renderCell(col, item) {
  var key = col.path || col.key;
  var value = col.value ? col.value(item) : get(item, col.path);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("td", {
    className: "table__cell",
    children: value
  }, key);
}
function get(obj, path) {
  // eslint-disable-next-line
  for (var i = 0, path = path.split("."), len = path.length; i < len; i++) {
    obj = obj[path[i]];
  }
  return obj;
}

/***/ }),

/***/ "./src/components/Table/TableHeader.jsx":
/*!**********************************************!*\
  !*** ./src/components/Table/TableHeader.jsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TableHeader: function() { return /* binding */ TableHeader; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var TableHeader = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref) {
  var columns = _ref.columns,
    sortColumn = _ref.sortColumn,
    onSort = _ref.onSort;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("thead", {
    className: "table__header",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tr", {
      className: "table__head",
      children: columns.map(renderColumn)
    })
  });

  // Functions
  // .........................................

  function renderColumn(column) {
    var path = column.path,
      key = column.key,
      label = column.label;
    // const icon = renderSortIcon({ column, sortColumn });

    if (column.path) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("th", {
        onClick: function onClick() {
          return handleSort(path);
        },
        className: "table__title",
        children: label
      }, path);
    }
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("th", {}, key);
  }
  function handleSort(path) {
    if (path === sortColumn.path) {
      onSort(_objectSpread(_objectSpread({}, sortColumn), {}, {
        direction: sortColumn.direction === "asc" ? "desc" : "asc"
      }));
    } else {
      onSort({
        path: path,
        direction: "asc"
      });
    }
  }
});

// Functions
// .........................................

// function renderSortIcon({ column, sortColumn }) {
//     if (!column.path || column.path !== sortColumn.path) return null;
//     const classes = `fa fa-sort-${sortColumn.direction}`;
//     return <i className={classes} />;
// }

/***/ }),

/***/ "./src/components/Table/index.js":
/*!***************************************!*\
  !*** ./src/components/Table/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Table: function() { return /* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_0__.Table; }
/* harmony export */ });
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Table */ "./src/components/Table/Table.jsx");


/***/ }),

/***/ "./src/components/Text/Text.jsx":
/*!**************************************!*\
  !*** ./src/components/Text/Text.jsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Paragraph: function() { return /* binding */ Paragraph; },
/* harmony export */   SectionSubtitle: function() { return /* binding */ SectionSubtitle; },
/* harmony export */   SectionTitle: function() { return /* binding */ SectionTitle; },
/* harmony export */   Span: function() { return /* binding */ Span; },
/* harmony export */   Subtitle: function() { return /* binding */ Subtitle; },
/* harmony export */   TextColor: function() { return /* binding */ TextColor; },
/* harmony export */   TextSize: function() { return /* binding */ TextSize; },
/* harmony export */   Title: function() { return /* binding */ Title; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _excluded = ["variant", "color", "size", "strong", "upper", "className"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var Variant = {
  Title: "Title",
  Subtitle: "Subtitle",
  SectionTitle: "SectionTitle",
  SectionSubtitle: "SectionSubtitle",
  Paragraph: "Paragraph",
  Span: "Span"
};
var Tag = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, Variant.Title, "h1"), Variant.Subtitle, "h2"), Variant.SectionTitle, "h3"), Variant.SectionSubtitle, "h4"), Variant.Paragraph, "p"), Variant.Span, "span");
var TagClassName = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, Variant.Title, "content__title"), Variant.Subtitle, "content__subtitle"), Variant.SectionTitle, "content__section-title"), Variant.SectionSubtitle, "content__section-subtitle"), Variant.Paragraph, "content__paragraph"), Variant.Span, "");
var TextColor = {
  Positive: "positive",
  Brand: "brand",
  Warning: "warning",
  Important: "important",
  Approved: "approved",
  Muted: "muted",
  Pale: "pale"
};
var TextSize = {
  Big: "big",
  Small: "small",
  Smaller: "smaller"
};
var Text = function Text(_ref) {
  var _ref$variant = _ref.variant,
    variant = _ref$variant === void 0 ? Variant.Span : _ref$variant,
    color = _ref.color,
    size = _ref.size,
    strong = _ref.strong,
    upper = _ref.upper,
    className = _ref.className,
    props = _objectWithoutProperties(_ref, _excluded);
  var TagName = Tag[variant];
  var tagClassName = TagClassName[variant];
  var classNames = classnames__WEBPACK_IMPORTED_MODULE_0___default()(tagClassName, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "content_".concat(size), size), "content_".concat(color), color), "content_strong", strong), "content_upper", upper), className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TagName, _objectSpread({
    className: classNames
  }, props));
};
var Title = function Title(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, _objectSpread(_objectSpread({}, props), {}, {
    variant: Variant.Title
  }));
};
var Subtitle = function Subtitle(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, _objectSpread(_objectSpread({}, props), {}, {
    variant: Variant.Subtitle
  }));
};
var SectionTitle = function SectionTitle(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, _objectSpread(_objectSpread({}, props), {}, {
    variant: Variant.SectionTitle
  }));
};
var SectionSubtitle = function SectionSubtitle(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, _objectSpread(_objectSpread({}, props), {}, {
    variant: Variant.SectionSubtitle
  }));
};
var Paragraph = function Paragraph(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, _objectSpread(_objectSpread({}, props), {}, {
    variant: Variant.Paragraph
  }));
};
var Span = function Span(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, _objectSpread(_objectSpread({}, props), {}, {
    variant: Variant.Span
  }));
};

/***/ }),

/***/ "./src/components/Text/index.js":
/*!**************************************!*\
  !*** ./src/components/Text/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Paragraph: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.Paragraph; },
/* harmony export */   SectionSubtitle: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.SectionSubtitle; },
/* harmony export */   SectionTitle: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.SectionTitle; },
/* harmony export */   Span: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.Span; },
/* harmony export */   Subtitle: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.Subtitle; },
/* harmony export */   TextColor: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.TextColor; },
/* harmony export */   TextSize: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.TextSize; },
/* harmony export */   Title: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_0__.Title; }
/* harmony export */ });
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Text */ "./src/components/Text/Text.jsx");


/***/ }),

/***/ "./src/components/Textarea/Textarea.jsx":
/*!**********************************************!*\
  !*** ./src/components/Textarea/Textarea.jsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Textarea: function() { return /* binding */ Textarea; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../hooks */ "./src/hooks/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["value", "title", "error", "wysiwyg", "onChange", "className"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var Textarea = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref, extRef) {
  var value = _ref.value,
    title = _ref.title,
    error = _ref.error,
    wysiwyg = _ref.wysiwyg,
    onChange = _ref.onChange,
    className = _ref.className,
    textareaProps = _objectWithoutProperties(_ref, _excluded);
  var _useFormControlRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_2__.useFormControlRef)(extRef, function (el) {
      return {
        el: el,
        getValue: function getValue() {
          return el.value;
        },
        setValue: function setValue() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          el.value = value;
        }
        //! setError?
      };
    }),
    ref = _useFormControlRef.ref,
    callbackRef = _useFormControlRef.callbackRef;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var $textarea = $(ref.current.el);
    if (wysiwyg) window.initWYSIWYG($textarea);
    return function () {}; // todo
  }, []);
  var labelClassNames = classnames__WEBPACK_IMPORTED_MODULE_1___default()("textarea", {
    textarea_error: error
  }, className);
  var handleChange = function handleChange(event) {
    var value = event.target.value;
    onChange(value, event);
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("label", {
    className: labelClassNames,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("textarea", _objectSpread({
      ref: callbackRef,
      value: value,
      className: "textarea__control",
      onChange: handleChange
    }, textareaProps)), title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
      className: "textarea__title",
      children: title
    }), error && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
      className: "textarea__error",
      children: error
    })]
  });
}));


/***/ }),

/***/ "./src/components/Textarea/index.js":
/*!******************************************!*\
  !*** ./src/components/Textarea/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Textarea: function() { return /* reexport safe */ _Textarea__WEBPACK_IMPORTED_MODULE_0__.Textarea; }
/* harmony export */ });
/* harmony import */ var _Textarea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Textarea */ "./src/components/Textarea/Textarea.jsx");


/***/ }),

/***/ "./src/components/Tooltip/Tooltip.jsx":
/*!********************************************!*\
  !*** ./src/components/Tooltip/Tooltip.jsx ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: function() { return /* binding */ Tooltip; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["className", "tooltip", "placement", "options", "toggle", "theme", "handler"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



// todo: add ext ref ?
// todo: programmatic call
// todo: html in tooltip

// const TooltipPlacement = {};

var Tooltip = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (_ref) {
  var className = _ref.className,
    tooltip = _ref.tooltip,
    _ref$placement = _ref.placement,
    placement = _ref$placement === void 0 ? "auto" : _ref$placement,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options,
    toggle = _ref.toggle,
    theme = _ref.theme,
    handler = _ref.handler,
    props = _objectWithoutProperties(_ref, _excluded);
  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var container = document.querySelector("body");
    container.addEventListener("mouseenter", showTooltip, true);
    function showTooltip(event) {
      window.initToolTip($(event.target));
    }

    // todo: destory???
    return function () {
      return container.removeEventListener("mouseenter", showTooltip);
    };
  }, [options]);
  var attrs = _objectSpread(_objectSpread({}, toggle && {
    "data-tooltip-toggle": true
  }), theme && {
    "data-tooltip-theme": theme
  });
  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()(className, {
    tooltip__handler: handler
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("span", _objectSpread(_objectSpread({
    ref: ref,
    className: classes,
    "data-tooltip": tooltip,
    "data-placement": placement
  }, props), attrs));
});

/***/ }),

/***/ "./src/components/Tooltip/index.js":
/*!*****************************************!*\
  !*** ./src/components/Tooltip/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: function() { return /* reexport safe */ _Tooltip__WEBPACK_IMPORTED_MODULE_0__.Tooltip; }
/* harmony export */ });
/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tooltip */ "./src/components/Tooltip/Tooltip.jsx");


/***/ }),

/***/ "./src/components/VStack/VStack.jsx":
/*!******************************************!*\
  !*** ./src/components/VStack/VStack.jsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VStack: function() { return /* binding */ VStack; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["gap", "children"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


// todo: настроить отображение классов css-модулей во вкладек Elements при использовании SB и в production

var VStack = function VStack(_ref) {
  var _ref$gap = _ref.gap,
    gap = _ref$gap === void 0 ? 0 : _ref$gap,
    children = _ref.children,
    props = _objectWithoutProperties(_ref, _excluded);
  var childrenWithGap = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, function (child, index) {
    var props = child.props;
    var _props$className = props.className,
      className = _props$className === void 0 ? "" : _props$className;
    var length = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);
    var isLast = index === length - 1;
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, _objectSpread(_objectSpread({}, child.props), !isLast && {
      className: "".concat(className, " mb-").concat(gap)
    }));
  });

  // todo: is need element div? (can be <> ?)
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", _objectSpread(_objectSpread({}, props), {}, {
    children: childrenWithGap
  }));
};

// export const VStack = ({ gap = 0, children, ...props }) => {
//     return (
//         <div className={cn(cls.flex)} {...props}>
//             {children}
//         </div>
//     );
// };

// export const HStack = ({ children, gap = 0 }) => {
//     const childrenWithGap = Children.map(children, (child, index) => {
//         const { props } = child;
//         const { className = "" } = props;

//         // const length = Children.count(children);
//         // const isLast = index === length - 1;

//         return cloneElement(child, {
//             ...child.props,
//             ...(!isLast && { className: `${className} ml-${gap}` }),
//         });
//     });

//     return <div>{childrenWithGap}</div>;
// };

/***/ }),

/***/ "./src/components/VStack/index.js":
/*!****************************************!*\
  !*** ./src/components/VStack/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VStack: function() { return /* reexport safe */ _VStack__WEBPACK_IMPORTED_MODULE_0__.VStack; }
/* harmony export */ });
/* harmony import */ var _VStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VStack */ "./src/components/VStack/VStack.jsx");


/***/ }),

/***/ "./src/components/index.js":
/*!*********************************!*\
  !*** ./src/components/index.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Avatar: function() { return /* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.Avatar; },
/* harmony export */   AvatarSize: function() { return /* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.AvatarSize; },
/* harmony export */   Badge: function() { return /* reexport safe */ _Badge__WEBPACK_IMPORTED_MODULE_1__.Badge; },
/* harmony export */   BadgeMaxWidth250: function() { return /* reexport safe */ _Badge__WEBPACK_IMPORTED_MODULE_1__.BadgeMaxWidth250; },
/* harmony export */   BadgeVariant: function() { return /* reexport safe */ _Badge__WEBPACK_IMPORTED_MODULE_1__.BadgeVariant; },
/* harmony export */   Button: function() { return /* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_3__.Button; },
/* harmony export */   ButtonTheme: function() { return /* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_3__.ButtonTheme; },
/* harmony export */   ButtonVariant: function() { return /* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_3__.ButtonVariant; },
/* harmony export */   Card: function() { return /* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_4__.Card; },
/* harmony export */   Checkbox: function() { return /* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_5__.Checkbox; },
/* harmony export */   Col: function() { return /* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_12__.Col; },
/* harmony export */   Container: function() { return /* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_12__.Container; },
/* harmony export */   DateInput: function() { return /* reexport safe */ _DateInput__WEBPACK_IMPORTED_MODULE_6__.DateInput; },
/* harmony export */   Definitions: function() { return /* reexport safe */ _Definitions__WEBPACK_IMPORTED_MODULE_7__.Definitions; },
/* harmony export */   Dropdown: function() { return /* reexport safe */ _Dropdown__WEBPACK_IMPORTED_MODULE_8__.Dropdown; },
/* harmony export */   DropdownItemType: function() { return /* reexport safe */ _Dropdown__WEBPACK_IMPORTED_MODULE_8__.DropdownItemType; },
/* harmony export */   File: function() { return /* reexport safe */ _File__WEBPACK_IMPORTED_MODULE_9__.File; },
/* harmony export */   FileList: function() { return /* reexport safe */ _FileList__WEBPACK_IMPORTED_MODULE_10__.FileList; },
/* harmony export */   FilePreview: function() { return /* reexport safe */ _File__WEBPACK_IMPORTED_MODULE_9__.FilePreview; },
/* harmony export */   Form: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_11__.Form; },
/* harmony export */   FormDescription: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_11__.FormDescription; },
/* harmony export */   FormFieldset: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_11__.FormFieldset; },
/* harmony export */   FormSection: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_11__.FormSection; },
/* harmony export */   FormTitle: function() { return /* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_11__.FormTitle; },
/* harmony export */   GroupContainer: function() { return /* reexport safe */ _GroupContainer__WEBPACK_IMPORTED_MODULE_13__.GroupContainer; },
/* harmony export */   Input: function() { return /* reexport safe */ _Input__WEBPACK_IMPORTED_MODULE_14__.Input; },
/* harmony export */   List: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_15__.List; },
/* harmony export */   ListType: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_15__.ListType; },
/* harmony export */   Loader: function() { return /* reexport safe */ _Loader__WEBPACK_IMPORTED_MODULE_16__.Loader; },
/* harmony export */   Modal: function() { return /* reexport safe */ _Modal__WEBPACK_IMPORTED_MODULE_17__.Modal; },
/* harmony export */   ModalVariant: function() { return /* reexport safe */ _Modal__WEBPACK_IMPORTED_MODULE_17__.ModalVariant; },
/* harmony export */   NotificationContainer: function() { return /* reexport safe */ _Notification__WEBPACK_IMPORTED_MODULE_18__.NotificationContainer; },
/* harmony export */   OList: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_15__.OList; },
/* harmony export */   Pagination: function() { return /* reexport safe */ _Pagination__WEBPACK_IMPORTED_MODULE_19__.Pagination; },
/* harmony export */   Paragraph: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.Paragraph; },
/* harmony export */   Portal: function() { return /* reexport safe */ _Portal__WEBPACK_IMPORTED_MODULE_20__.Portal; },
/* harmony export */   Radio: function() { return /* reexport safe */ _Radio__WEBPACK_IMPORTED_MODULE_21__.Radio; },
/* harmony export */   Row: function() { return /* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_12__.Row; },
/* harmony export */   SectionSubtitle: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.SectionSubtitle; },
/* harmony export */   SectionTitle: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.SectionTitle; },
/* harmony export */   Select: function() { return /* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_22__.Select; },
/* harmony export */   SelectEvent: function() { return /* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_22__.SelectEvent; },
/* harmony export */   Separator: function() { return /* reexport safe */ _Separator__WEBPACK_IMPORTED_MODULE_23__.Separator; },
/* harmony export */   Span: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.Span; },
/* harmony export */   Status: function() { return /* reexport safe */ _Status__WEBPACK_IMPORTED_MODULE_24__.Status; },
/* harmony export */   StatusType: function() { return /* reexport safe */ _Status__WEBPACK_IMPORTED_MODULE_24__.StatusType; },
/* harmony export */   Subtitle: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.Subtitle; },
/* harmony export */   Table: function() { return /* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_25__.Table; },
/* harmony export */   TextColor: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.TextColor; },
/* harmony export */   TextSize: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.TextSize; },
/* harmony export */   Textarea: function() { return /* reexport safe */ _Textarea__WEBPACK_IMPORTED_MODULE_27__.Textarea; },
/* harmony export */   Title: function() { return /* reexport safe */ _Text__WEBPACK_IMPORTED_MODULE_26__.Title; },
/* harmony export */   Tooltip: function() { return /* reexport safe */ _Tooltip__WEBPACK_IMPORTED_MODULE_28__.Tooltip; },
/* harmony export */   UList: function() { return /* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_15__.UList; },
/* harmony export */   VStack: function() { return /* reexport safe */ _VStack__WEBPACK_IMPORTED_MODULE_29__.VStack; },
/* harmony export */   notification: function() { return /* reexport safe */ _Notification__WEBPACK_IMPORTED_MODULE_18__.notification; }
/* harmony export */ });
/* harmony import */ var _Avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Avatar */ "./src/components/Avatar/index.js");
/* harmony import */ var _Badge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Badge */ "./src/components/Badge/index.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Box */ "./src/components/Box/index.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Box__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Box__WEBPACK_IMPORTED_MODULE_2__) if(["default","Avatar","AvatarSize","Badge","BadgeMaxWidth250","BadgeVariant"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _Box__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Button */ "./src/components/Button/index.js");
/* harmony import */ var _Card__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Card */ "./src/components/Card/index.js");
/* harmony import */ var _Checkbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Checkbox */ "./src/components/Checkbox/index.js");
/* harmony import */ var _DateInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DateInput */ "./src/components/DateInput/index.js");
/* harmony import */ var _Definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Definitions */ "./src/components/Definitions/index.js");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Dropdown */ "./src/components/Dropdown/index.js");
/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./File */ "./src/components/File/index.js");
/* harmony import */ var _FileList__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./FileList */ "./src/components/FileList/index.js");
/* harmony import */ var _Form__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Form */ "./src/components/Form/index.js");
/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Grid */ "./src/components/Grid/index.js");
/* harmony import */ var _GroupContainer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./GroupContainer */ "./src/components/GroupContainer/index.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Input */ "./src/components/Input/index.js");
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./List */ "./src/components/List/index.js");
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Loader */ "./src/components/Loader/index.js");
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Modal */ "./src/components/Modal/index.js");
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Notification */ "./src/components/Notification/index.js");
/* harmony import */ var _Pagination__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Pagination */ "./src/components/Pagination/index.js");
/* harmony import */ var _Portal__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Portal */ "./src/components/Portal/index.js");
/* harmony import */ var _Radio__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Radio */ "./src/components/Radio/index.js");
/* harmony import */ var _Select__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./Select */ "./src/components/Select/index.js");
/* harmony import */ var _Separator__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./Separator */ "./src/components/Separator/index.js");
/* harmony import */ var _Status__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./Status */ "./src/components/Status/index.js");
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./Table */ "./src/components/Table/index.js");
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./Text */ "./src/components/Text/index.js");
/* harmony import */ var _Textarea__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./Textarea */ "./src/components/Textarea/index.js");
/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./Tooltip */ "./src/components/Tooltip/index.js");
/* harmony import */ var _VStack__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./VStack */ "./src/components/VStack/index.js");

























// todo: use variant with modifying children classes with mb-x
// export * from "./Stack";






/***/ }),

/***/ "./src/hooks/index.js":
/*!****************************!*\
  !*** ./src/hooks/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useForm: function() { return /* reexport safe */ _useForm__WEBPACK_IMPORTED_MODULE_0__.useForm; },
/* harmony export */   useFormControlRef: function() { return /* reexport safe */ _useFormControlRef__WEBPACK_IMPORTED_MODULE_1__.useFormControlRef; },
/* harmony export */   useProxyState: function() { return /* reexport safe */ _useProxyState__WEBPACK_IMPORTED_MODULE_2__.useProxyState; }
/* harmony export */ });
/* harmony import */ var _useForm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useForm */ "./src/hooks/useForm/index.js");
/* harmony import */ var _useFormControlRef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useFormControlRef */ "./src/hooks/useFormControlRef/index.js");
/* harmony import */ var _useProxyState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useProxyState */ "./src/hooks/useProxyState/index.js");




/***/ }),

/***/ "./src/hooks/useElementRef/composeRef.js":
/*!***********************************************!*\
  !*** ./src/hooks/useElementRef/composeRef.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   composeRef: function() { return /* binding */ composeRef; },
/* harmony export */   fillRef: function() { return /* binding */ fillRef; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }

function fillRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (_typeof(ref) === "object" && ref && "current" in ref) {
    ref.current = node;
  }
}

/**
 * Merge refs into one ref function to support ref passing.
 */
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function (ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (node) {
    refs.forEach(function (ref) {
      fillRef(ref, node);
    });
  }, []);
}

/***/ }),

/***/ "./src/hooks/useElementRef/index.js":
/*!******************************************!*\
  !*** ./src/hooks/useElementRef/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   composeRef: function() { return /* reexport safe */ _composeRef__WEBPACK_IMPORTED_MODULE_1__.composeRef; },
/* harmony export */   useElementRef: function() { return /* reexport safe */ _useElementRef__WEBPACK_IMPORTED_MODULE_0__.useElementRef; }
/* harmony export */ });
/* harmony import */ var _useElementRef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useElementRef */ "./src/hooks/useElementRef/useElementRef.js");
/* harmony import */ var _composeRef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./composeRef */ "./src/hooks/useElementRef/composeRef.js");



/***/ }),

/***/ "./src/hooks/useElementRef/useElementRef.js":
/*!**************************************************!*\
  !*** ./src/hooks/useElementRef/useElementRef.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useElementRef: function() { return /* binding */ useElementRef; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);



/**
 * todo
 * @param {*} extRef
 */
// todo: сделать единую точку экпорта для hooks
// todo: return $el ???
// todo: rename => useElement
// todo!: replace with composeRef ???
var useElementRef = function useElementRef(extRef) {
  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  var refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (el) {
    ref.current = el;
    if (!extRef) return;
    if (typeof extRef === "function") extRef(el);else extRef.current = el;
  }, []);

  // todo: rm
  if (!Object.hasOwn(ref, "el")) {
    Object.defineProperty(ref, "el", {
      get: function get() {
        return ref.current;
      }
    });
  }

  // todo: rm
  if (!Object.hasOwn(ref, "$el")) {
    Object.defineProperty(ref, "$el", {
      get: function get() {
        // todo: cache get $el
        return $(ref.current);
      }
    });
  }
  return {
    ref: ref,
    refCallback: refCallback
  };
};

/***/ }),

/***/ "./src/hooks/useForm/index.js":
/*!************************************!*\
  !*** ./src/hooks/useForm/index.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useForm: function() { return /* reexport safe */ _useForm__WEBPACK_IMPORTED_MODULE_0__.useForm; }
/* harmony export */ });
/* harmony import */ var _useForm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useForm */ "./src/hooks/useForm/useForm.js");


/***/ }),

/***/ "./src/hooks/useForm/useForm.js":
/*!**************************************!*\
  !*** ./src/hooks/useForm/useForm.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useForm: function() { return /* binding */ useForm; }
/* harmony export */ });
/* harmony import */ var yup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yup */ "./node_modules/yup/index.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _useProxyState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../useProxyState */ "./src/hooks/useProxyState/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




// todo: schema should be optional
// todo: useCallbacks
// todo: if select:multiple => validate field and create errors on close dropdown (чтобы при выборе отдельных пунктов не перередирвался селект из-за возвожной ошибки валидации)
// todo: focus on first form element initially
// todo: what if control unmounted (see RHF): update refStore, schema etc.
// todo: process mount/unount components (tune state, schema)
// todo: нужна инструкция по добавлению нового контрола, совместимого с useForm
// todo: сделать story useForm со всеми контролами
// todo: how to process disabled fields
// todo: reset single field
// todo: set single field
// todo: validate onBlur flag
// todo: check useForm with outer lib components react-select, react-datepicker
// todo: scroll to first error (+ flat scrollToFirstError, and focus?)
// todo: focus on first error
// todo: ability to add hidden no validate fileds?
// todo: mv to hooks utils
// todo: create getValues to get all form values without rerenders and subscription
// todo: check case with nested data object (not flat)
// todo: flag unregisterOnUnmount
// todo: case of deeply nested components in form (need context?)
// todo: check rerenders and make story for it
// todo: add controls: Range, SelectList (sorting, add, delete,...), ...
// todo: test with File, FileList
// todo: выделить в SB инпуты отдельно
// todo: should have setError in ref? (like setValue, getValue)
// todo: validate on init ?
// todo!: case of dynamically added/removed array-like form fields (analog of useArrayField)
// todo!: case of nested form object of values (not flat as now)

//! note: преимущество - хук ничего не знает про типы контролов (для документации)

//   const get = (obj, name, defaultValue) => {};

// !TODO: create TWO refs: mainEl, inputEl
// !TODO: поместить name в ref?

var isUndefined = function isUndefined(value) {
  return value === undefined;
};
var useForm = function useForm() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$defaultValues = _ref.defaultValues,
    defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,
    schema = _ref.schema;
  console.log("⚡ useForm: render");
  var refStore = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});

  // const registerOrder = [];

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({}),
    _useState2 = _slicedToArray(_useState, 2),
    values = _useState2[0],
    setValues = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({}),
    _useState4 = _slicedToArray(_useState3, 2),
    errors = _useState4[0],
    setErrors = _useState4[1];
  var _names = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    return {
      watch: new Set(),
      watchAll: false
    };
  }, []);

  // todo: formState should be proxied
  // todo: case of error not readed ???
  // todo: set default values to watched fields
  var _useProxyState = (0,_useProxyState__WEBPACK_IMPORTED_MODULE_2__.useProxyState)({
      isValid: true,
      // todo!: calculate initially (use func argument) do it silently (don't show error messages before submit button is clicked)
      isSubmitted: false
      // dirty: ...,
      //? errors: ...
    }),
    proxyFormState = _useProxyState.proxyState,
    updateFormState = _useProxyState.updateState;
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    setDefaultValues({
      init: true
    });
  }, []);
  var setDefaultValues = function setDefaultValues() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$init = _ref2.init,
      init = _ref2$init === void 0 ? false : _ref2$init;
    for (var _i = 0, _Object$keys = Object.keys(refStore.current); _i < _Object$keys.length; _i++) {
      var name = _Object$keys[_i];
      // note: defaultValue = defaultValues[name] || innerDefaultValue
      var _refStore$current$nam = refStore.current[name],
        setValue = _refStore$current$nam.setValue,
        defaultValue = _refStore$current$nam.defaultValue;
      var hasExternalDefaultValue = !isUndefined(defaultValues[name]);
      var shouldSetDefaultValue = !init || init && hasExternalDefaultValue;

      // todo: don't set default value if current value didn't change

      if (shouldSetDefaultValue) setValue(defaultValue);
    }
  };
  var resetValues = function resetValues() {
    for (var _i2 = 0, _Object$keys2 = Object.keys(refStore.current); _i2 < _Object$keys2.length; _i2++) {
      var name = _Object$keys2[_i2];
      var setValue = refStore.current[name].setValue;
      setValue();
    }
  };
  var resetErrors = function resetErrors() {
    return setErrors({});
  };
  var getData = function getData() {
    return Object.entries(refStore.current).reduce(function (acc, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        getValue = _ref4[1].getValue;
      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, name, getValue()));
    }, {});
  };
  [];
  var getSchema = function getSchema() {
    return Object.entries(refStore.current).reduce(function (acc, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
        name = _ref6[0],
        schema = _ref6[1].schema;
      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, name, schema));
    }, {});
  };

  // todo: extract as util
  var validate = function validate(data, schema) {
    return yup__WEBPACK_IMPORTED_MODULE_0__.object(schema).validate(data, {
      abortEarly: true
    });
  };
  var validateField = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {
      var _ref8,
        _ref8$shouldUpdateVal,
        shouldUpdateValue,
        _refStore$current$nam2,
        getValue,
        schema,
        value,
        errorMessage,
        valueObj,
        schemaObj,
        message,
        isValid,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _ref8 = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, _ref8$shouldUpdateVal = _ref8.shouldUpdateValue, shouldUpdateValue = _ref8$shouldUpdateVal === void 0 ? false : _ref8$shouldUpdateVal;
            _refStore$current$nam2 = refStore.current[name], getValue = _refStore$current$nam2.getValue, schema = _refStore$current$nam2.schema;
            value = getValue();
            errorMessage = "";
            _context.prev = 4;
            if (!schema) {
              _context.next = 10;
              break;
            }
            valueObj = _defineProperty({}, name, value);
            schemaObj = _defineProperty({}, name, schema);
            _context.next = 10;
            return validate(valueObj, schemaObj);
          case 10:
            _context.next = 16;
            break;
          case 12:
            _context.prev = 12;
            _context.t0 = _context["catch"](4);
            message = _context.t0.message;
            errorMessage = message;
          case 16:
            if (shouldUpdateValue) {
              setValues(function (values) {
                return _objectSpread(_objectSpread({}, values), {}, _defineProperty({}, name, value));
              });
            }

            // todo: разобраться с лишним рендером
            // todo: "1" -> "" -> "1" -> "11" (render here)
            // todo: remove error field if no error case
            setErrors(function (prevErrors) {
              var currErrorMessage = prevErrors[name] || "";
              var shouldUpdateError = errorMessage !== currErrorMessage;
              return shouldUpdateError ? _objectSpread(_objectSpread({}, prevErrors), {}, _defineProperty({}, name, errorMessage)) : prevErrors;
            });
            isValid = !hasErrors(_objectSpread(_objectSpread({}, errors), {}, _defineProperty({}, name, errorMessage)));
            updateFormState("isValid", isValid);
          case 20:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[4, 12]]);
    }));
    return function validateField(_x) {
      return _ref7.apply(this, arguments);
    };
  }();

  // исключить лишние рендеры при валидации
  // unregister field при демонтировании компонента
  // проверить, что схема настривается автоматически
  var onChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)( /*#__PURE__*/function () {
    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(value, event) {
      var name, shouldUpdateValue;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            name = event.target.name;
            shouldUpdateValue = _names.watchAll || _names.watch.has(name);
            validateField(name, {
              shouldUpdateValue: shouldUpdateValue
            });
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x2, _x3) {
      return _ref10.apply(this, arguments);
    };
  }(), []);

  // const onBlur = useCallback(({ target: { name } }) => {
  //     //! validate triggers redundant render
  //     // validateField(name);
  // }, []);

  // todo: reset should work for no defaultValues case (reset to clear form)
  // todo: clear form method is needed to (and clear single field)
  // todo: reset/clear/clearError for single field
  var reset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setDefaultValues();
    resetErrors();
  }, []);
  var clear = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    resetValues();
    resetErrors();
  }, []);

  // use stable callback for every name
  // иначе проискодит двойной вызов ref callback (null (1) => node (2))
  // todo: use refStore
  //?! is needed el in ref object
  var getCallbackRef = function getCallbackRef(name) {
    return function (ref) {
      var _schema$name;
      // unregister
      if (!ref) {
        delete refStore.current[name];
        return;
      }

      // register
      var externalDefaultValue = defaultValues[name];
      var innerDefaultValue = ref.getValue();

      // note: defaultValue can be null
      var hasExternalDefaultValue = !isUndefined(externalDefaultValue);
      Object.assign(refStore.current[name], ref, {
        schema: (_schema$name = schema === null || schema === void 0 ? void 0 : schema[name]) !== null && _schema$name !== void 0 ? _schema$name : null,
        defaultValue: hasExternalDefaultValue ? externalDefaultValue : innerDefaultValue
      });
    };
  };
  var register = function register(name) {
    // todo: refactor
    // todo: use deep set
    // note: обеспечиваем стабильность сслки на callbackRef
    if (!refStore.current[name]) refStore.current[name] = {}; //! DRY
    if (!refStore.current[name].refCallback) {
      refStore.current[name].refCallback = getCallbackRef(name);
    }

    // set names to watch
    if (_names.watchAll) _names.watch.add(name);
    var registerProps = {
      name: name,
      ref: refStore.current[name].refCallback,
      onChange: onChange,
      // onBlur,
      // todo: если нет схемы валидации, то и ошибку не передавать
      // todo: use shouldExposeError
      error: errors[name] // todo: отдавать ошибку, если isSubmitted: true или isValid: isUsed
    };
    return registerProps;
  };

  // useCallback???
  // todo: unify validation full object and separate field
  // todo: optimize renders (not always rerender is necessary)
  var handleSubmit = function handleSubmit(submitHandler) {
    return /*#__PURE__*/function () {
      var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(e) {
        var data, schema, promises, result, errors, isValid;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              e.preventDefault();
              data = getData();
              schema = getSchema(); // todo: move to utils (and others)
              // Run validation for each field with abortEarly: true
              // https://github.com/jquense/yup/issues/569
              promises = Object.keys(refStore.current).map(function (name) {
                var fieldData = _defineProperty({}, name, data[name]);
                var fieldSchema = _defineProperty({}, name, schema[name]);
                return validate(fieldData, fieldSchema);
              });
              _context3.next = 6;
              return Promise.allSettled(promises);
            case 6:
              result = _context3.sent;
              errors = result.filter(function (_ref12) {
                var status = _ref12.status;
                return status === "rejected";
              }).map(function (_ref13) {
                var reason = _ref13.reason;
                return reason;
              }).reduce(function (acc, _ref14) {
                var path = _ref14.path,
                  message = _ref14.message;
                return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, path, message));
              }, {}); // todo: don't set errors if errors didn't change
              setErrors(errors);
              isValid = !hasErrors(errors);
              if (isValid) submitHandler(data);
              updateFormState("isSubmitted", true);
            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return function (_x4) {
        return _ref11.apply(this, arguments);
      };
    }();
  };

  // todo: to utils
  var hasErrors = function hasErrors(errors) {
    console.log("errors", errors);
    if (!errors) return false;
    var hasKeys = Object.keys(errors).length > 0;
    if (!hasKeys) return false;
    return Object.values(errors).filter(Boolean).length > 0;
  };

  /**
   * @param {string|string[]|undefined} name
   * @returns
   * ! name can be callback function (call on field change, return unsub)
   */
  var watch = function watch(name) {
    var watchAll = !name;
    if (!name) _names.watchAll = watchAll;
    var namesArr = [];
    if (!watchAll) namesArr = Array.isArray(name) ? name : [name];
    namesArr.forEach(function (name) {
      return _names.watch.add(name);
    });
    var res = _toConsumableArray(_names.watch).reduce(function (acc, name) {
      var _refStore$current;
      var value = !isUndefined(values[name]) ? values[name] : (_refStore$current = refStore.current) === null || _refStore$current === void 0 || (_refStore$current = _refStore$current[name]) === null || _refStore$current === void 0 ? void 0 : _refStore$current.getValue();
      return _objectSpread(_objectSpread({}, acc), !isUndefined(value) && _defineProperty({}, name, value));
    }, watchAll ? defaultValues : _.pick(defaultValues, namesArr));
    return typeof name === "string" ? res[name] : res;
  };
  return {
    register: register,
    // unregister,
    watch: watch,
    handleSubmit: handleSubmit,
    formState: proxyFormState,
    // getFormStateWithoutRedner,
    reset: reset,
    clear: clear,
    getData: getData
  };
};

/***/ }),

/***/ "./src/hooks/useFormControlRef/index.js":
/*!**********************************************!*\
  !*** ./src/hooks/useFormControlRef/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useFormControlRef: function() { return /* reexport safe */ _useFormControlRef__WEBPACK_IMPORTED_MODULE_0__.useFormControlRef; }
/* harmony export */ });
/* harmony import */ var _useFormControlRef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useFormControlRef */ "./src/hooks/useFormControlRef/useFormControlRef.js");


/***/ }),

/***/ "./src/hooks/useFormControlRef/useFormControlRef.js":
/*!**********************************************************!*\
  !*** ./src/hooks/useFormControlRef/useFormControlRef.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useFormControlRef: function() { return /* binding */ useFormControlRef; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


/**
 *
 * @param {*} extRef
 * @param {*} getRefProps - API for useForm hook
 * @returns
 */
function useFormControlRef(extRef, getRefProps) {
  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});

  /**
   * @param {import("react").DOMElement | Object} refParam
   */
  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (refParam) {
    ref.current = refParam ? getRefProps(refParam) : null;
    if (!extRef) return;
    if (typeof extRef === "function") extRef(ref.current);else extRef.current = ref.current;
  }, []);
  return {
    ref: ref,
    callbackRef: callbackRef
  };
}

/***/ }),

/***/ "./src/hooks/useProxyState/index.js":
/*!******************************************!*\
  !*** ./src/hooks/useProxyState/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useProxyState: function() { return /* reexport safe */ _useProxyState__WEBPACK_IMPORTED_MODULE_0__.useProxyState; }
/* harmony export */ });
/* harmony import */ var _useProxyState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useProxyState */ "./src/hooks/useProxyState/useProxyState.js");


/***/ }),

/***/ "./src/hooks/useProxyState/useProxyState.js":
/*!**************************************************!*\
  !*** ./src/hooks/useProxyState/useProxyState.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useProxyState: function() { return /* binding */ useProxyState; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useProxyState = function useProxyState(initState) {
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initState),
    _useState2 = _slicedToArray(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  var watchFieldsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  var proxyStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_objectSpread({}, state));
  var proxyState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var result = {};
    var _loop = function _loop(name) {
      Object.defineProperty(result, name, {
        get: function get() {
          watchFieldsRef.current[name] = true;
          return proxyStateRef.current[name];
        }
      });
    };
    for (var name in state) {
      _loop(name);
    }
    return result;
  }, []);

  // todo: use object to set value (can set multiple values)
  // todo: use updateState to set initial errors
  // todo: reformat errors state with proxyState function
  // todo: is shouldRender used ???
  var updateState = function updateState(name, value) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$shouldRender = _ref.shouldRender,
      shouldRender = _ref$shouldRender === void 0 ? true : _ref$shouldRender;
    var currentValue = proxyStateRef.current[name];
    var isSameValue = value === currentValue;
    var isWatched = watchFieldsRef.current[name];
    proxyStateRef.current[name] = value;
    var shouldSetState = shouldRender && isWatched && !isSameValue;
    if (shouldSetState) setState(_objectSpread({}, proxyStateRef.current));
  };

  //? should use two states
  return {
    state: state,
    proxyState: proxyState,
    updateState: updateState
  };
};

/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;
	var nativeCodeString = '[native code]';

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
					classes.push(arg.toString());
					continue;
				}

				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/inputmask/dist/inputmask.js":
/*!**************************************************!*\
  !*** ./node_modules/inputmask/dist/inputmask.js ***!
  \**************************************************/
/***/ (function(module) {

/*!
 * dist/inputmask
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2023 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.8
 */
!function(e, t) {
    if (true) module.exports = t(); else { var n, i; }
}("undefined" != typeof self ? self : this, (function() {
    return function() {
        "use strict";
        var e = {
            8741: function(e, t) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var i = !("undefined" == typeof window || !window.document || !window.document.createElement);
                t.default = i;
            },
            3976: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = i(2839), a = {
                    _maxTestPos: 500,
                    placeholder: "_",
                    optionalmarker: [ "[", "]" ],
                    quantifiermarker: [ "{", "}" ],
                    groupmarker: [ "(", ")" ],
                    alternatormarker: "|",
                    escapeChar: "\\",
                    mask: null,
                    regex: null,
                    oncomplete: function() {},
                    onincomplete: function() {},
                    oncleared: function() {},
                    repeat: 0,
                    greedy: !1,
                    autoUnmask: !1,
                    removeMaskOnSubmit: !1,
                    clearMaskOnLostFocus: !0,
                    insertMode: !0,
                    insertModeVisual: !0,
                    clearIncomplete: !1,
                    alias: null,
                    onKeyDown: function() {},
                    onBeforeMask: null,
                    onBeforePaste: function(e, t) {
                        return "function" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;
                    },
                    onBeforeWrite: null,
                    onUnMask: null,
                    showMaskOnFocus: !0,
                    showMaskOnHover: !0,
                    onKeyValidation: function() {},
                    skipOptionalPartCharacter: " ",
                    numericInput: !1,
                    rightAlign: !1,
                    undoOnEscape: !0,
                    radixPoint: "",
                    _radixDance: !1,
                    groupSeparator: "",
                    keepStatic: null,
                    positionCaretOnTab: !0,
                    tabThrough: !1,
                    supportsInputType: [ "text", "tel", "url", "password", "search" ],
                    ignorables: [ n.keys.Backspace, n.keys.Tab, n.keys.Pause, n.keys.Escape, n.keys.PageUp, n.keys.PageDown, n.keys.End, n.keys.Home, n.keys.ArrowLeft, n.keys.ArrowUp, n.keys.ArrowRight, n.keys.ArrowDown, n.keys.Insert, n.keys.Delete, n.keys.ContextMenu, n.keys.F1, n.keys.F2, n.keys.F3, n.keys.F4, n.keys.F5, n.keys.F6, n.keys.F7, n.keys.F8, n.keys.F9, n.keys.F10, n.keys.F11, n.keys.F12, n.keys.Process, n.keys.Unidentified, n.keys.Shift, n.keys.Control, n.keys.Alt, n.keys.Tab, n.keys.AltGraph, n.keys.CapsLock ],
                    isComplete: null,
                    preValidation: null,
                    postValidation: null,
                    staticDefinitionSymbol: void 0,
                    jitMasking: !1,
                    nullable: !0,
                    inputEventOnly: !1,
                    noValuePatching: !1,
                    positionCaretOnClick: "lvp",
                    casing: null,
                    inputmode: "text",
                    importDataAttributes: !0,
                    shiftPositions: !0,
                    usePrototypeDefinitions: !0,
                    validationEventTimeOut: 3e3,
                    substitutes: {}
                };
                t.default = a;
            },
            7392: function(e, t) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                t.default = {
                    9: {
                        validator: "[0-9\uff10-\uff19]",
                        definitionSymbol: "*"
                    },
                    a: {
                        validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                        definitionSymbol: "*"
                    },
                    "*": {
                        validator: "[0-9\uff10-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]"
                    }
                };
            },
            253: function(e, t) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t, i) {
                    if (void 0 === i) return e.__data ? e.__data[t] : null;
                    e.__data = e.__data || {}, e.__data[t] = i;
                };
            },
            3776: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Event = void 0, t.off = function(e, t) {
                    var i, n;
                    f(this[0]) && e && (i = this[0].eventRegistry, n = this[0], e.split(" ").forEach((function(e) {
                        var a = l(e.split("."), 2);
                        (function(e, n) {
                            var a, r, o = [];
                            if (e.length > 0) if (void 0 === t) for (a = 0, r = i[e][n].length; a < r; a++) o.push({
                                ev: e,
                                namespace: n && n.length > 0 ? n : "global",
                                handler: i[e][n][a]
                            }); else o.push({
                                ev: e,
                                namespace: n && n.length > 0 ? n : "global",
                                handler: t
                            }); else if (n.length > 0) for (var s in i) for (var l in i[s]) if (l === n) if (void 0 === t) for (a = 0, 
                            r = i[s][l].length; a < r; a++) o.push({
                                ev: s,
                                namespace: l,
                                handler: i[s][l][a]
                            }); else o.push({
                                ev: s,
                                namespace: l,
                                handler: t
                            });
                            return o;
                        })(a[0], a[1]).forEach((function(e) {
                            var t = e.ev, a = e.handler;
                            !function(e, t, a) {
                                if (e in i == 1) if (n.removeEventListener ? n.removeEventListener(e, a, !1) : n.detachEvent && n.detachEvent("on".concat(e), a), 
                                "global" === t) for (var r in i[e]) i[e][r].splice(i[e][r].indexOf(a), 1); else i[e][t].splice(i[e][t].indexOf(a), 1);
                            }(t, e.namespace, a);
                        }));
                    })));
                    return this;
                }, t.on = function(e, t) {
                    if (f(this[0])) {
                        var i = this[0].eventRegistry, n = this[0];
                        e.split(" ").forEach((function(e) {
                            var a = l(e.split("."), 2), r = a[0], o = a[1];
                            !function(e, a) {
                                n.addEventListener ? n.addEventListener(e, t, !1) : n.attachEvent && n.attachEvent("on".concat(e), t), 
                                i[e] = i[e] || {}, i[e][a] = i[e][a] || [], i[e][a].push(t);
                            }(r, void 0 === o ? "global" : o);
                        }));
                    }
                    return this;
                }, t.trigger = function(e) {
                    var t = arguments;
                    if (f(this[0])) for (var i = this[0].eventRegistry, n = this[0], r = "string" == typeof e ? e.split(" ") : [ e.type ], s = 0; s < r.length; s++) {
                        var l = r[s].split("."), c = l[0], u = l[1] || "global";
                        if (void 0 !== document && "global" === u) {
                            var d, p = {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0,
                                detail: arguments[1]
                            };
                            if (document.createEvent) {
                                try {
                                    if ("input" === c) p.inputType = "insertText", d = new InputEvent(c, p); else d = new CustomEvent(c, p);
                                } catch (e) {
                                    (d = document.createEvent("CustomEvent")).initCustomEvent(c, p.bubbles, p.cancelable, p.detail);
                                }
                                e.type && (0, a.default)(d, e), n.dispatchEvent(d);
                            } else (d = document.createEventObject()).eventType = c, d.detail = arguments[1], 
                            e.type && (0, a.default)(d, e), n.fireEvent("on" + d.eventType, d);
                        } else if (void 0 !== i[c]) {
                            arguments[0] = arguments[0].type ? arguments[0] : o.default.Event(arguments[0]), 
                            arguments[0].detail = arguments.slice(1);
                            var h = i[c];
                            ("global" === u ? Object.values(h).flat() : h[u]).forEach((function(e) {
                                return e.apply(n, t);
                            }));
                        }
                    }
                    return this;
                };
                var n, a = u(i(600)), r = u(i(9380)), o = u(i(4963)), s = u(i(8741));
                function l(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e;
                    }(e) || function(e, t) {
                        var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null != i) {
                            var n, a, r, o, s = [], l = !0, c = !1;
                            try {
                                if (r = (i = i.call(e)).next, 0 === t) {
                                    if (Object(i) !== i) return;
                                    l = !1;
                                } else for (;!(l = (n = r.call(i)).done) && (s.push(n.value), s.length !== t); l = !0) ;
                            } catch (e) {
                                c = !0, a = e;
                            } finally {
                                try {
                                    if (!l && null != i.return && (o = i.return(), Object(o) !== o)) return;
                                } finally {
                                    if (c) throw a;
                                }
                            }
                            return s;
                        }
                    }(e, t) || function(e, t) {
                        if (!e) return;
                        if ("string" == typeof e) return c(e, t);
                        var i = Object.prototype.toString.call(e).slice(8, -1);
                        "Object" === i && e.constructor && (i = e.constructor.name);
                        if ("Map" === i || "Set" === i) return Array.from(e);
                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return c(e, t);
                    }(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }();
                }
                function c(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
                    return n;
                }
                function u(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                function f(e) {
                    return e instanceof Element;
                }
                t.Event = n, "function" == typeof r.default.CustomEvent ? t.Event = n = r.default.CustomEvent : s.default && (t.Event = n = function(e, t) {
                    t = t || {
                        bubbles: !1,
                        cancelable: !1,
                        composed: !0,
                        detail: void 0
                    };
                    var i = document.createEvent("CustomEvent");
                    return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i;
                }, n.prototype = r.default.Event.prototype);
            },
            600: function(e, t) {
                function i(e) {
                    return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e;
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                    }, i(e);
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e() {
                    var t, n, a, r, o, s, l = arguments[0] || {}, c = 1, u = arguments.length, f = !1;
                    "boolean" == typeof l && (f = l, l = arguments[c] || {}, c++);
                    "object" !== i(l) && "function" != typeof l && (l = {});
                    for (;c < u; c++) if (null != (t = arguments[c])) for (n in t) a = l[n], l !== (r = t[n]) && (f && r && ("[object Object]" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1, 
                    s = a && Array.isArray(a) ? a : []) : s = a && "[object Object]" === Object.prototype.toString.call(a) ? a : {}, 
                    l[n] = e(f, s, r)) : void 0 !== r && (l[n] = r));
                    return l;
                };
            },
            4963: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = s(i(600)), a = s(i(9380)), r = s(i(253)), o = i(3776);
                function s(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                var l = a.default.document;
                function c(e) {
                    return e instanceof c ? e : this instanceof c ? void (null != e && e !== a.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : l.querySelector(e), 
                    void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new c(e);
                }
                c.prototype = {
                    on: o.on,
                    off: o.off,
                    trigger: o.trigger
                }, c.extend = n.default, c.data = r.default, c.Event = o.Event;
                var u = c;
                t.default = u;
            },
            9845: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.mobile = t.iphone = t.ie = void 0;
                var n, a = (n = i(9380)) && n.__esModule ? n : {
                    default: n
                };
                var r = a.default.navigator && a.default.navigator.userAgent || "", o = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0, s = navigator.userAgentData && navigator.userAgentData.mobile || a.default.navigator && a.default.navigator.maxTouchPoints || "ontouchstart" in a.default, l = /iphone/i.test(r);
                t.iphone = l, t.mobile = s, t.ie = o;
            },
            7184: function(e, t) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    return e.replace(i, "\\$1");
                };
                var i = new RegExp("(\\" + [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ].join("|\\") + ")", "gim");
            },
            6030: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.EventHandlers = void 0;
                var n = i(8711), a = i(2839), r = i(9845), o = i(7215), s = i(7760), l = i(4713);
                function c(e, t) {
                    var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                    if (!i) {
                        if (Array.isArray(e) || (i = function(e, t) {
                            if (!e) return;
                            if ("string" == typeof e) return u(e, t);
                            var i = Object.prototype.toString.call(e).slice(8, -1);
                            "Object" === i && e.constructor && (i = e.constructor.name);
                            if ("Map" === i || "Set" === i) return Array.from(e);
                            if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return u(e, t);
                        }(e)) || t && e && "number" == typeof e.length) {
                            i && (e = i);
                            var n = 0, a = function() {};
                            return {
                                s: a,
                                n: function() {
                                    return n >= e.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: e[n++]
                                    };
                                },
                                e: function(e) {
                                    throw e;
                                },
                                f: a
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var r, o = !0, s = !1;
                    return {
                        s: function() {
                            i = i.call(e);
                        },
                        n: function() {
                            var e = i.next();
                            return o = e.done, e;
                        },
                        e: function(e) {
                            s = !0, r = e;
                        },
                        f: function() {
                            try {
                                o || null == i.return || i.return();
                            } finally {
                                if (s) throw r;
                            }
                        }
                    };
                }
                function u(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
                    return n;
                }
                var f = {
                    keyEvent: function(e, t, i, c, u) {
                        var d = this.inputmask, p = d.opts, h = d.dependencyLib, v = d.maskset, m = this, g = h(m), y = e.key, k = n.caret.call(d, m), b = p.onKeyDown.call(this, e, n.getBuffer.call(d), k, p);
                        if (void 0 !== b) return b;
                        if (y === a.keys.Backspace || y === a.keys.Delete || r.iphone && y === a.keys.BACKSPACE_SAFARI || e.ctrlKey && y === a.keys.x && !("oncut" in m)) e.preventDefault(), 
                        o.handleRemove.call(d, m, y, k), (0, s.writeBuffer)(m, n.getBuffer.call(d, !0), v.p, e, m.inputmask._valueGet() !== n.getBuffer.call(d).join("")); else if (y === a.keys.End || y === a.keys.PageDown) {
                            e.preventDefault();
                            var x = n.seekNext.call(d, n.getLastValidPosition.call(d));
                            n.caret.call(d, m, e.shiftKey ? k.begin : x, x, !0);
                        } else y === a.keys.Home && !e.shiftKey || y === a.keys.PageUp ? (e.preventDefault(), 
                        n.caret.call(d, m, 0, e.shiftKey ? k.begin : 0, !0)) : p.undoOnEscape && y === a.keys.Escape && !0 !== e.altKey ? ((0, 
                        s.checkVal)(m, !0, !1, d.undoValue.split("")), g.trigger("click")) : y !== a.keys.Insert || e.shiftKey || e.ctrlKey || void 0 !== d.userOptions.insertMode ? !0 === p.tabThrough && y === a.keys.Tab ? !0 === e.shiftKey ? (k.end = n.seekPrevious.call(d, k.end, !0), 
                        !0 === l.getTest.call(d, k.end - 1).match.static && k.end--, k.begin = n.seekPrevious.call(d, k.end, !0), 
                        k.begin >= 0 && k.end > 0 && (e.preventDefault(), n.caret.call(d, m, k.begin, k.end))) : (k.begin = n.seekNext.call(d, k.begin, !0), 
                        k.end = n.seekNext.call(d, k.begin, !0), k.end < v.maskLength && k.end--, k.begin <= v.maskLength && (e.preventDefault(), 
                        n.caret.call(d, m, k.begin, k.end))) : e.shiftKey || p.insertModeVisual && !1 === p.insertMode && (y === a.keys.ArrowRight ? setTimeout((function() {
                            var e = n.caret.call(d, m);
                            n.caret.call(d, m, e.begin);
                        }), 0) : y === a.keys.ArrowLeft && setTimeout((function() {
                            var e = n.translatePosition.call(d, m.inputmask.caretPos.begin);
                            n.translatePosition.call(d, m.inputmask.caretPos.end);
                            d.isRTL ? n.caret.call(d, m, e + (e === v.maskLength ? 0 : 1)) : n.caret.call(d, m, e - (0 === e ? 0 : 1));
                        }), 0)) : o.isSelection.call(d, k) ? p.insertMode = !p.insertMode : (p.insertMode = !p.insertMode, 
                        n.caret.call(d, m, k.begin, k.begin));
                        return d.isComposing = y == a.keys.Process || y == a.keys.Unidentified, d.ignorable = p.ignorables.includes(y), 
                        f.keypressEvent.call(this, e, t, i, c, u);
                    },
                    keypressEvent: function(e, t, i, r, l) {
                        var c = this.inputmask || this, u = c.opts, f = c.dependencyLib, d = c.maskset, p = c.el, h = f(p), v = e.key;
                        if (!0 === t || e.ctrlKey && e.altKey || !(e.ctrlKey || e.metaKey || c.ignorable)) {
                            if (v) {
                                var m, g = t ? {
                                    begin: l,
                                    end: l
                                } : n.caret.call(c, p);
                                v = u.substitutes[v] || v, d.writeOutBuffer = !0;
                                var y = o.isValid.call(c, g, v, r, void 0, void 0, void 0, t);
                                if (!1 !== y && (n.resetMaskSet.call(c, !0), m = void 0 !== y.caret ? y.caret : n.seekNext.call(c, y.pos.begin ? y.pos.begin : y.pos), 
                                d.p = m), m = u.numericInput && void 0 === y.caret ? n.seekPrevious.call(c, m) : m, 
                                !1 !== i && (setTimeout((function() {
                                    u.onKeyValidation.call(p, v, y);
                                }), 0), d.writeOutBuffer && !1 !== y)) {
                                    var k = n.getBuffer.call(c);
                                    (0, s.writeBuffer)(p, k, m, e, !0 !== t);
                                }
                                if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;
                            }
                        } else v === a.keys.Enter && c.undoValue !== c._valueGet(!0) && (c.undoValue = c._valueGet(!0), 
                        setTimeout((function() {
                            h.trigger("change");
                        }), 0));
                    },
                    pasteEvent: function(e) {
                        var t, i = this.inputmask, a = i.opts, r = i._valueGet(!0), o = n.caret.call(i, this);
                        i.isRTL && (t = o.end, o.end = n.translatePosition.call(i, o.begin), o.begin = n.translatePosition.call(i, t));
                        var l = r.substr(0, o.begin), u = r.substr(o.end, r.length);
                        if (l == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(0, o.begin).join("") && (l = ""), 
                        u == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(o.end).join("") && (u = ""), 
                        window.clipboardData && window.clipboardData.getData) r = l + window.clipboardData.getData("Text") + u; else {
                            if (!e.clipboardData || !e.clipboardData.getData) return !0;
                            r = l + e.clipboardData.getData("text/plain") + u;
                        }
                        var f = r;
                        if (i.isRTL) {
                            f = f.split("");
                            var d, p = c(n.getBufferTemplate.call(i));
                            try {
                                for (p.s(); !(d = p.n()).done; ) {
                                    var h = d.value;
                                    f[0] === h && f.shift();
                                }
                            } catch (e) {
                                p.e(e);
                            } finally {
                                p.f();
                            }
                            f = f.join("");
                        }
                        if ("function" == typeof a.onBeforePaste) {
                            if (!1 === (f = a.onBeforePaste.call(i, f, a))) return !1;
                            f || (f = r);
                        }
                        (0, s.checkVal)(this, !0, !1, f.toString().split(""), e), e.preventDefault();
                    },
                    inputFallBackEvent: function(e) {
                        var t = this.inputmask, i = t.opts, o = t.dependencyLib;
                        var c, u = this, d = u.inputmask._valueGet(!0), p = (t.isRTL ? n.getBuffer.call(t).slice().reverse() : n.getBuffer.call(t)).join(""), h = n.caret.call(t, u, void 0, void 0, !0);
                        if (p !== d) {
                            if (c = function(e, a, r) {
                                for (var o, s, c, u = e.substr(0, r.begin).split(""), f = e.substr(r.begin).split(""), d = a.substr(0, r.begin).split(""), p = a.substr(r.begin).split(""), h = u.length >= d.length ? u.length : d.length, v = f.length >= p.length ? f.length : p.length, m = "", g = [], y = "~"; u.length < h; ) u.push(y);
                                for (;d.length < h; ) d.push(y);
                                for (;f.length < v; ) f.unshift(y);
                                for (;p.length < v; ) p.unshift(y);
                                var k = u.concat(f), b = d.concat(p);
                                for (s = 0, o = k.length; s < o; s++) switch (c = l.getPlaceholder.call(t, n.translatePosition.call(t, s)), 
                                m) {
                                  case "insertText":
                                    b[s - 1] === k[s] && r.begin == k.length - 1 && g.push(k[s]), s = o;
                                    break;

                                  case "insertReplacementText":
                                  case "deleteContentBackward":
                                    k[s] === y ? r.end++ : s = o;
                                    break;

                                  default:
                                    k[s] !== b[s] && (k[s + 1] !== y && k[s + 1] !== c && void 0 !== k[s + 1] || (b[s] !== c || b[s + 1] !== y) && b[s] !== y ? b[s + 1] === y && b[s] === k[s + 1] ? (m = "insertText", 
                                    g.push(k[s]), r.begin--, r.end--) : k[s] !== c && k[s] !== y && (k[s + 1] === y || b[s] !== k[s] && b[s + 1] === k[s + 1]) ? (m = "insertReplacementText", 
                                    g.push(k[s]), r.begin--) : k[s] === y ? (m = "deleteContentBackward", (n.isMask.call(t, n.translatePosition.call(t, s), !0) || b[s] === i.radixPoint) && r.end++) : s = o : (m = "insertText", 
                                    g.push(k[s]), r.begin--, r.end--));
                                }
                                return {
                                    action: m,
                                    data: g,
                                    caret: r
                                };
                            }(d, p, h), (u.inputmask.shadowRoot || u.ownerDocument).activeElement !== u && u.focus(), 
                            (0, s.writeBuffer)(u, n.getBuffer.call(t)), n.caret.call(t, u, h.begin, h.end, !0), 
                            !r.mobile && t.skipNextInsert && "insertText" === e.inputType && "insertText" === c.action && t.isComposing) return !1;
                            switch ("insertCompositionText" === e.inputType && "insertText" === c.action && t.isComposing ? t.skipNextInsert = !0 : t.skipNextInsert = !1, 
                            c.action) {
                              case "insertText":
                              case "insertReplacementText":
                                c.data.forEach((function(e, i) {
                                    var n = new o.Event("keypress");
                                    n.key = e, t.ignorable = !1, f.keypressEvent.call(u, n);
                                })), setTimeout((function() {
                                    t.$el.trigger("keyup");
                                }), 0);
                                break;

                              case "deleteContentBackward":
                                var v = new o.Event("keydown");
                                v.key = a.keys.Backspace, f.keyEvent.call(u, v);
                                break;

                              default:
                                (0, s.applyInputValue)(u, d), n.caret.call(t, u, h.begin, h.end, !0);
                            }
                            e.preventDefault();
                        }
                    },
                    setValueEvent: function(e) {
                        var t = this.inputmask, i = this, a = e && e.detail ? e.detail[0] : arguments[1];
                        void 0 === a && (a = i.inputmask._valueGet(!0)), (0, s.applyInputValue)(i, a), (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && n.caret.call(t, i, e.detail ? e.detail[1] : arguments[2]);
                    },
                    focusEvent: function(e) {
                        var t = this.inputmask, i = t.opts, a = null == t ? void 0 : t._valueGet();
                        i.showMaskOnFocus && a !== n.getBuffer.call(t).join("") && (0, s.writeBuffer)(this, n.getBuffer.call(t), n.seekNext.call(t, n.getLastValidPosition.call(t))), 
                        !0 !== i.positionCaretOnTab || !1 !== t.mouseEnter || o.isComplete.call(t, n.getBuffer.call(t)) && -1 !== n.getLastValidPosition.call(t) || f.clickEvent.apply(this, [ e, !0 ]), 
                        t.undoValue = null == t ? void 0 : t._valueGet(!0);
                    },
                    invalidEvent: function(e) {
                        this.inputmask.validationEvent = !0;
                    },
                    mouseleaveEvent: function() {
                        var e = this.inputmask, t = e.opts, i = this;
                        e.mouseEnter = !1, t.clearMaskOnLostFocus && (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i && (0, 
                        s.HandleNativePlaceholder)(i, e.originalPlaceholder);
                    },
                    clickEvent: function(e, t) {
                        var i = this.inputmask;
                        i.clicked++;
                        var a = this;
                        if ((a.inputmask.shadowRoot || a.ownerDocument).activeElement === a) {
                            var r = n.determineNewCaretPosition.call(i, n.caret.call(i, a), t);
                            void 0 !== r && n.caret.call(i, a, r);
                        }
                    },
                    cutEvent: function(e) {
                        var t = this.inputmask, i = t.maskset, r = this, l = n.caret.call(t, r), c = t.isRTL ? n.getBuffer.call(t).slice(l.end, l.begin) : n.getBuffer.call(t).slice(l.begin, l.end), u = t.isRTL ? c.reverse().join("") : c.join("");
                        window.navigator.clipboard ? window.navigator.clipboard.writeText(u) : window.clipboardData && window.clipboardData.getData && window.clipboardData.setData("Text", u), 
                        o.handleRemove.call(t, r, a.keys.Delete, l), (0, s.writeBuffer)(r, n.getBuffer.call(t), i.p, e, t.undoValue !== t._valueGet(!0));
                    },
                    blurEvent: function(e) {
                        var t = this.inputmask, i = t.opts, a = t.dependencyLib;
                        t.clicked = 0;
                        var r = a(this), l = this;
                        if (l.inputmask) {
                            (0, s.HandleNativePlaceholder)(l, t.originalPlaceholder);
                            var c = l.inputmask._valueGet(), u = n.getBuffer.call(t).slice();
                            "" !== c && (i.clearMaskOnLostFocus && (-1 === n.getLastValidPosition.call(t) && c === n.getBufferTemplate.call(t).join("") ? u = [] : s.clearOptionalTail.call(t, u)), 
                            !1 === o.isComplete.call(t, u) && (setTimeout((function() {
                                r.trigger("incomplete");
                            }), 0), i.clearIncomplete && (n.resetMaskSet.call(t), u = i.clearMaskOnLostFocus ? [] : n.getBufferTemplate.call(t).slice())), 
                            (0, s.writeBuffer)(l, u, void 0, e)), t.undoValue !== t._valueGet(!0) && (t.undoValue = t._valueGet(!0), 
                            r.trigger("change"));
                        }
                    },
                    mouseenterEvent: function() {
                        var e = this.inputmask, t = e.opts.showMaskOnHover, i = this;
                        if (e.mouseEnter = !0, (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i) {
                            var a = (e.isRTL ? n.getBufferTemplate.call(e).slice().reverse() : n.getBufferTemplate.call(e)).join("");
                            t && (0, s.HandleNativePlaceholder)(i, a);
                        }
                    },
                    submitEvent: function() {
                        var e = this.inputmask, t = e.opts;
                        e.undoValue !== e._valueGet(!0) && e.$el.trigger("change"), -1 === n.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === n.getBufferTemplate.call(e).join("") && e._valueSet(""), 
                        t.clearIncomplete && !1 === o.isComplete.call(e, n.getBuffer.call(e)) && e._valueSet(""), 
                        t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout((function() {
                            (0, s.writeBuffer)(e.el, n.getBuffer.call(e));
                        }), 0));
                    },
                    resetEvent: function() {
                        var e = this.inputmask;
                        e.refreshValue = !0, setTimeout((function() {
                            (0, s.applyInputValue)(e.el, e._valueGet(!0));
                        }), 0);
                    }
                };
                t.EventHandlers = f;
            },
            9716: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.EventRuler = void 0;
                var n, a = (n = i(2394)) && n.__esModule ? n : {
                    default: n
                }, r = i(2839), o = i(8711), s = i(7760);
                var l = {
                    on: function(e, t, i) {
                        var n = e.inputmask.dependencyLib, l = function(t) {
                            t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);
                            var l, c = this, u = c.inputmask, f = u ? u.opts : void 0;
                            if (void 0 === u && "FORM" !== this.nodeName) {
                                var d = n.data(c, "_inputmask_opts");
                                n(c).off(), d && new a.default(d).mask(c);
                            } else {
                                if ([ "submit", "reset", "setvalue" ].includes(t.type) || "FORM" === this.nodeName || !(c.disabled || c.readOnly && !("keydown" === t.type && t.ctrlKey && t.key === r.keys.c || !1 === f.tabThrough && t.key === r.keys.Tab))) {
                                    switch (t.type) {
                                      case "input":
                                        if (!0 === u.skipInputEvent) return u.skipInputEvent = !1, t.preventDefault();
                                        break;

                                      case "click":
                                      case "focus":
                                        return u.validationEvent ? (u.validationEvent = !1, e.blur(), (0, s.HandleNativePlaceholder)(e, (u.isRTL ? o.getBufferTemplate.call(u).slice().reverse() : o.getBufferTemplate.call(u)).join("")), 
                                        setTimeout((function() {
                                            e.focus();
                                        }), f.validationEventTimeOut), !1) : (l = arguments, void setTimeout((function() {
                                            e.inputmask && i.apply(c, l);
                                        }), 0));
                                    }
                                    var p = i.apply(c, arguments);
                                    return !1 === p && (t.preventDefault(), t.stopPropagation()), p;
                                }
                                t.preventDefault();
                            }
                        };
                        [ "submit", "reset" ].includes(t) ? (l = l.bind(e), null !== e.form && n(e.form).on(t, l)) : n(e).on(t, l), 
                        e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(l);
                    },
                    off: function(e, t) {
                        if (e.inputmask && e.inputmask.events) {
                            var i = e.inputmask.dependencyLib, n = e.inputmask.events;
                            for (var a in t && ((n = [])[t] = e.inputmask.events[t]), n) {
                                for (var r = n[a]; r.length > 0; ) {
                                    var o = r.pop();
                                    [ "submit", "reset" ].includes(a) ? null !== e.form && i(e.form).off(a, o) : i(e).off(a, o);
                                }
                                delete e.inputmask.events[a];
                            }
                        }
                    }
                };
                t.EventRuler = l;
            },
            219: function(e, t, i) {
                var n = d(i(2394)), a = i(2839), r = d(i(7184)), o = i(8711), s = i(4713);
                function l(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e;
                    }(e) || function(e, t) {
                        var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null != i) {
                            var n, a, r, o, s = [], l = !0, c = !1;
                            try {
                                if (r = (i = i.call(e)).next, 0 === t) {
                                    if (Object(i) !== i) return;
                                    l = !1;
                                } else for (;!(l = (n = r.call(i)).done) && (s.push(n.value), s.length !== t); l = !0) ;
                            } catch (e) {
                                c = !0, a = e;
                            } finally {
                                try {
                                    if (!l && null != i.return && (o = i.return(), Object(o) !== o)) return;
                                } finally {
                                    if (c) throw a;
                                }
                            }
                            return s;
                        }
                    }(e, t) || function(e, t) {
                        if (!e) return;
                        if ("string" == typeof e) return c(e, t);
                        var i = Object.prototype.toString.call(e).slice(8, -1);
                        "Object" === i && e.constructor && (i = e.constructor.name);
                        if ("Map" === i || "Set" === i) return Array.from(e);
                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return c(e, t);
                    }(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }();
                }
                function c(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
                    return n;
                }
                function u(e) {
                    return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e;
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                    }, u(e);
                }
                function f(e, t) {
                    for (var i = 0; i < t.length; i++) {
                        var n = t[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                        Object.defineProperty(e, (a = n.key, r = void 0, r = function(e, t) {
                            if ("object" !== u(e) || null === e) return e;
                            var i = e[Symbol.toPrimitive];
                            if (void 0 !== i) {
                                var n = i.call(e, t || "default");
                                if ("object" !== u(n)) return n;
                                throw new TypeError("@@toPrimitive must return a primitive value.");
                            }
                            return ("string" === t ? String : Number)(e);
                        }(a, "string"), "symbol" === u(r) ? r : String(r)), n);
                    }
                    var a, r;
                }
                function d(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                var p = n.default.dependencyLib, h = function() {
                    function e(t, i, n) {
                        !function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                        }(this, e), this.mask = t, this.format = i, this.opts = n, this._date = new Date(1, 0, 1), 
                        this.initDateObject(t, this.opts);
                    }
                    var t, i, n;
                    return t = e, (i = [ {
                        key: "date",
                        get: function() {
                            return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts)), 
                            this._date;
                        }
                    }, {
                        key: "initDateObject",
                        value: function(e, t) {
                            var i;
                            for (P(t).lastIndex = 0; i = P(t).exec(this.format); ) {
                                var n = new RegExp("\\d+$").exec(i[0]), a = n ? i[0][0] + "x" : i[0], r = void 0;
                                if (void 0 !== e) {
                                    if (n) {
                                        var o = P(t).lastIndex, s = E(i.index, t);
                                        P(t).lastIndex = o, r = e.slice(0, e.indexOf(s.nextMatch[0]));
                                    } else r = e.slice(0, g[a] && g[a][4] || a.length);
                                    e = e.slice(r.length);
                                }
                                Object.prototype.hasOwnProperty.call(g, a) && this.setValue(this, r, a, g[a][2], g[a][1]);
                            }
                        }
                    }, {
                        key: "setValue",
                        value: function(e, t, i, n, a) {
                            if (void 0 !== t && (e[n] = "ampm" === n ? t : t.replace(/[^0-9]/g, "0"), e["raw" + n] = t.replace(/\s/g, "_")), 
                            void 0 !== a) {
                                var r = e[n];
                                ("day" === n && 29 === parseInt(r) || "month" === n && 2 === parseInt(r)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || "" !== e.year && void 0 !== e.year || e._date.setFullYear(2012, 1, 29)), 
                                "day" === n && (m = !0, 0 === parseInt(r) && (r = 1)), "month" === n && (m = !0), 
                                "year" === n && (m = !0, r.length < 4 && (r = M(r, 4, !0))), "" === r || isNaN(r) || a.call(e._date, r), 
                                "ampm" === n && a.call(e._date, r);
                            }
                        }
                    }, {
                        key: "reset",
                        value: function() {
                            this._date = new Date(1, 0, 1);
                        }
                    }, {
                        key: "reInit",
                        value: function() {
                            this._date = void 0, this.date;
                        }
                    } ]) && f(t.prototype, i), n && f(t, n), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e;
                }(), v = (new Date).getFullYear(), m = !1, g = {
                    d: [ "[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate ],
                    dd: [ "0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                        return M(Date.prototype.getDate.call(this), 2);
                    } ],
                    ddd: [ "" ],
                    dddd: [ "" ],
                    m: [ "[1-9]|1[012]", function(e) {
                        var t = e ? parseInt(e) : 0;
                        return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                    }, "month", function() {
                        return Date.prototype.getMonth.call(this) + 1;
                    } ],
                    mm: [ "0[1-9]|1[012]", function(e) {
                        var t = e ? parseInt(e) : 0;
                        return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                    }, "month", function() {
                        return M(Date.prototype.getMonth.call(this) + 1, 2);
                    } ],
                    mmm: [ "" ],
                    mmmm: [ "" ],
                    yy: [ "[0-9]{2}", Date.prototype.setFullYear, "year", function() {
                        return M(Date.prototype.getFullYear.call(this), 2);
                    } ],
                    yyyy: [ "[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                        return M(Date.prototype.getFullYear.call(this), 4);
                    } ],
                    h: [ "[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                    hh: [ "0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                        return M(Date.prototype.getHours.call(this), 2);
                    } ],
                    hx: [ function(e) {
                        return "[0-9]{".concat(e, "}");
                    }, Date.prototype.setHours, "hours", function(e) {
                        return Date.prototype.getHours;
                    } ],
                    H: [ "1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                    HH: [ "0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                        return M(Date.prototype.getHours.call(this), 2);
                    } ],
                    Hx: [ function(e) {
                        return "[0-9]{".concat(e, "}");
                    }, Date.prototype.setHours, "hours", function(e) {
                        return function() {
                            return M(Date.prototype.getHours.call(this), e);
                        };
                    } ],
                    M: [ "[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes ],
                    MM: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                        return M(Date.prototype.getMinutes.call(this), 2);
                    } ],
                    s: [ "[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds ],
                    ss: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                        return M(Date.prototype.getSeconds.call(this), 2);
                    } ],
                    l: [ "[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                        return M(Date.prototype.getMilliseconds.call(this), 3);
                    }, 3 ],
                    L: [ "[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                        return M(Date.prototype.getMilliseconds.call(this), 2);
                    }, 2 ],
                    t: [ "[ap]", k, "ampm", b, 1 ],
                    tt: [ "[ap]m", k, "ampm", b, 2 ],
                    T: [ "[AP]", k, "ampm", b, 1 ],
                    TT: [ "[AP]M", k, "ampm", b, 2 ],
                    Z: [ ".*", void 0, "Z", function() {
                        var e = this.toString().match(/\((.+)\)/)[1];
                        e.includes(" ") && (e = (e = e.replace("-", " ").toUpperCase()).split(" ").map((function(e) {
                            return l(e, 1)[0];
                        })).join(""));
                        return e;
                    } ],
                    o: [ "" ],
                    S: [ "" ]
                }, y = {
                    isoDate: "yyyy-mm-dd",
                    isoTime: "HH:MM:ss",
                    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
                };
                function k(e) {
                    var t = this.getHours();
                    e.toLowerCase().includes("p") ? this.setHours(t + 12) : e.toLowerCase().includes("a") && t >= 12 && this.setHours(t - 12);
                }
                function b() {
                    var e = this.getHours();
                    return (e = e || 12) >= 12 ? "PM" : "AM";
                }
                function x(e) {
                    var t = new RegExp("\\d+$").exec(e[0]);
                    if (t && void 0 !== t[0]) {
                        var i = g[e[0][0] + "x"].slice("");
                        return i[0] = i[0](t[0]), i[3] = i[3](t[0]), i;
                    }
                    if (g[e[0]]) return g[e[0]];
                }
                function P(e) {
                    if (!e.tokenizer) {
                        var t = [], i = [];
                        for (var n in g) if (/\.*x$/.test(n)) {
                            var a = n[0] + "\\d+";
                            -1 === i.indexOf(a) && i.push(a);
                        } else -1 === t.indexOf(n[0]) && t.push(n[0]);
                        e.tokenizer = "(" + (i.length > 0 ? i.join("|") + "|" : "") + t.join("+|") + ")+?|.", 
                        e.tokenizer = new RegExp(e.tokenizer, "g");
                    }
                    return e.tokenizer;
                }
                function w(e, t, i) {
                    if (!m) return !0;
                    if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || "29" == e.day && (!isFinite(e.rawyear) || void 0 === e.rawyear || "" === e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;
                    if ("29" == e.day) {
                        var n = E(t.pos, i);
                        if ("yyyy" === n.targetMatch[0] && t.pos - n.targetMatchIndex == 2) return t.remove = t.pos + 1, 
                        t;
                    } else if ("02" == e.month && "30" == e.day && void 0 !== t.c) return e.day = "03", 
                    e.date.setDate(3), e.date.setMonth(1), t.insert = [ {
                        pos: t.pos,
                        c: "0"
                    }, {
                        pos: t.pos + 1,
                        c: t.c
                    } ], t.caret = o.seekNext.call(this, t.pos + 1), t;
                    return !1;
                }
                function S(e, t, i, n) {
                    var a, o, s = "";
                    for (P(i).lastIndex = 0; a = P(i).exec(e); ) {
                        if (void 0 === t) if (o = x(a)) s += "(" + o[0] + ")"; else switch (a[0]) {
                          case "[":
                            s += "(";
                            break;

                          case "]":
                            s += ")?";
                            break;

                          default:
                            s += (0, r.default)(a[0]);
                        } else if (o = x(a)) if (!0 !== n && o[3]) s += o[3].call(t.date); else o[2] ? s += t["raw" + o[2]] : s += a[0]; else s += a[0];
                    }
                    return s;
                }
                function M(e, t, i) {
                    for (e = String(e), t = t || 2; e.length < t; ) e = i ? e + "0" : "0" + e;
                    return e;
                }
                function _(e, t, i) {
                    return "string" == typeof e ? new h(e, t, i) : e && "object" === u(e) && Object.prototype.hasOwnProperty.call(e, "date") ? e : void 0;
                }
                function O(e, t) {
                    return S(t.inputFormat, {
                        date: e
                    }, t);
                }
                function E(e, t) {
                    var i, n, a = 0, r = 0;
                    for (P(t).lastIndex = 0; n = P(t).exec(t.inputFormat); ) {
                        var o = new RegExp("\\d+$").exec(n[0]);
                        if ((a += r = o ? parseInt(o[0]) : n[0].length) >= e + 1) {
                            i = n, n = P(t).exec(t.inputFormat);
                            break;
                        }
                    }
                    return {
                        targetMatchIndex: a - r,
                        nextMatch: n,
                        targetMatch: i
                    };
                }
                n.default.extendAliases({
                    datetime: {
                        mask: function(e) {
                            return e.numericInput = !1, g.S = e.i18n.ordinalSuffix.join("|"), e.inputFormat = y[e.inputFormat] || e.inputFormat, 
                            e.displayFormat = y[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = y[e.outputFormat] || e.outputFormat || e.inputFormat, 
                            e.placeholder = "" !== e.placeholder ? e.placeholder : e.inputFormat.replace(/[[\]]/, ""), 
                            e.regex = S(e.inputFormat, void 0, e), e.min = _(e.min, e.inputFormat, e), e.max = _(e.max, e.inputFormat, e), 
                            null;
                        },
                        placeholder: "",
                        inputFormat: "isoDateTime",
                        displayFormat: null,
                        outputFormat: null,
                        min: null,
                        max: null,
                        skipOptionalPartCharacter: "",
                        i18n: {
                            dayNames: [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ],
                            monthNames: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                            ordinalSuffix: [ "st", "nd", "rd", "th" ]
                        },
                        preValidation: function(e, t, i, n, a, r, o, s) {
                            if (s) return !0;
                            if (isNaN(i) && e[t] !== i) {
                                var l = E(t, a);
                                if (l.nextMatch && l.nextMatch[0] === i && l.targetMatch[0].length > 1) {
                                    var c = g[l.targetMatch[0]][0];
                                    if (new RegExp(c).test("0" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = "0", 
                                    {
                                        fuzzy: !0,
                                        buffer: e,
                                        refreshFromBuffer: {
                                            start: t - 1,
                                            end: t + 1
                                        },
                                        pos: t + 1
                                    };
                                }
                            }
                            return !0;
                        },
                        postValidation: function(e, t, i, n, a, r, o, l) {
                            var c, u;
                            if (o) return !0;
                            if (!1 === n && (((c = E(t + 1, a)).targetMatch && c.targetMatchIndex === t && c.targetMatch[0].length > 1 && void 0 !== g[c.targetMatch[0]] || (c = E(t + 2, a)).targetMatch && c.targetMatchIndex === t + 1 && c.targetMatch[0].length > 1 && void 0 !== g[c.targetMatch[0]]) && (u = g[c.targetMatch[0]][0]), 
                            void 0 !== u && (void 0 !== r.validPositions[t + 1] && new RegExp(u).test(i + "0") ? (e[t] = i, 
                            e[t + 1] = "0", n = {
                                pos: t + 2,
                                caret: t
                            }) : new RegExp(u).test("0" + i) && (e[t] = "0", e[t + 1] = i, n = {
                                pos: t + 2
                            })), !1 === n)) return n;
                            if (n.fuzzy && (e = n.buffer, t = n.pos), (c = E(t, a)).targetMatch && c.targetMatch[0] && void 0 !== g[c.targetMatch[0]]) {
                                var f = g[c.targetMatch[0]];
                                u = f[0];
                                var d = e.slice(c.targetMatchIndex, c.targetMatchIndex + c.targetMatch[0].length);
                                if (!1 === new RegExp(u).test(d.join("")) && 2 === c.targetMatch[0].length && r.validPositions[c.targetMatchIndex] && r.validPositions[c.targetMatchIndex + 1] && (r.validPositions[c.targetMatchIndex + 1].input = "0"), 
                                "year" == f[2]) for (var p = s.getMaskTemplate.call(this, !1, 1, void 0, !0), h = t + 1; h < e.length; h++) e[h] = p[h], 
                                delete r.validPositions[h];
                            }
                            var m = n, y = _(e.join(""), a.inputFormat, a);
                            return m && !isNaN(y.date.getTime()) && (a.prefillYear && (m = function(e, t, i) {
                                if (e.year !== e.rawyear) {
                                    var n = v.toString(), a = e.rawyear.replace(/[^0-9]/g, ""), r = n.slice(0, a.length), o = n.slice(a.length);
                                    if (2 === a.length && a === r) {
                                        var s = new Date(v, e.month - 1, e.day);
                                        e.day == s.getDate() && (!i.max || i.max.date.getTime() >= s.getTime()) && (e.date.setFullYear(v), 
                                        e.year = n, t.insert = [ {
                                            pos: t.pos + 1,
                                            c: o[0]
                                        }, {
                                            pos: t.pos + 2,
                                            c: o[1]
                                        } ]);
                                    }
                                }
                                return t;
                            }(y, m, a)), m = function(e, t, i, n, a) {
                                if (!t) return t;
                                if (t && i.min && !isNaN(i.min.date.getTime())) {
                                    var r;
                                    for (e.reset(), P(i).lastIndex = 0; r = P(i).exec(i.inputFormat); ) {
                                        var o;
                                        if ((o = x(r)) && o[3]) {
                                            for (var s = o[1], l = e[o[2]], c = i.min[o[2]], u = i.max ? i.max[o[2]] : c, f = [], d = !1, p = 0; p < c.length; p++) void 0 !== n.validPositions[p + r.index] || d ? (f[p] = l[p], 
                                            d = d || l[p] > c[p]) : (f[p] = c[p], "year" === o[2] && l.length - 1 == p && c != u && (f = (parseInt(f.join("")) + 1).toString().split("")), 
                                            "ampm" === o[2] && c != u && i.min.date.getTime() > e.date.getTime() && (f[p] = u[p]));
                                            s.call(e._date, f.join(""));
                                        }
                                    }
                                    t = i.min.date.getTime() <= e.date.getTime(), e.reInit();
                                }
                                return t && i.max && (isNaN(i.max.date.getTime()) || (t = i.max.date.getTime() >= e.date.getTime())), 
                                t;
                            }(y, m = w.call(this, y, m, a), a, r)), void 0 !== t && m && n.pos !== t ? {
                                buffer: S(a.inputFormat, y, a).split(""),
                                refreshFromBuffer: {
                                    start: t,
                                    end: n.pos
                                },
                                pos: n.caret || n.pos
                            } : m;
                        },
                        onKeyDown: function(e, t, i, n) {
                            e.ctrlKey && e.key === a.keys.ArrowRight && (this.inputmask._valueSet(O(new Date, n)), 
                            p(this).trigger("setvalue"));
                        },
                        onUnMask: function(e, t, i) {
                            return t ? S(i.outputFormat, _(e, i.inputFormat, i), i, !0) : t;
                        },
                        casing: function(e, t, i, n) {
                            return 0 == t.nativeDef.indexOf("[ap]") ? e.toLowerCase() : 0 == t.nativeDef.indexOf("[AP]") ? e.toUpperCase() : e;
                        },
                        onBeforeMask: function(e, t) {
                            return "[object Date]" === Object.prototype.toString.call(e) && (e = O(e, t)), e;
                        },
                        insertMode: !1,
                        insertModeVisual: !1,
                        shiftPositions: !1,
                        keepStatic: !1,
                        inputmode: "numeric",
                        prefillYear: !0
                    }
                });
            },
            3851: function(e, t, i) {
                var n, a = (n = i(2394)) && n.__esModule ? n : {
                    default: n
                }, r = i(8711), o = i(4713);
                a.default.extendDefinitions({
                    A: {
                        validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                        casing: "upper"
                    },
                    "&": {
                        validator: "[0-9A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                        casing: "upper"
                    },
                    "#": {
                        validator: "[0-9A-Fa-f]",
                        casing: "upper"
                    }
                });
                var s = new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]");
                function l(e, t, i, n, a) {
                    return i - 1 > -1 && "." !== t.buffer[i - 1] ? (e = t.buffer[i - 1] + e, e = i - 2 > -1 && "." !== t.buffer[i - 2] ? t.buffer[i - 2] + e : "0" + e) : e = "00" + e, 
                    s.test(e);
                }
                a.default.extendAliases({
                    cssunit: {
                        regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                    },
                    url: {
                        regex: "(https?|ftp)://.*",
                        autoUnmask: !1,
                        keepStatic: !1,
                        tabThrough: !0
                    },
                    ip: {
                        mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                        definitions: {
                            i: {
                                validator: l
                            },
                            j: {
                                validator: l
                            },
                            k: {
                                validator: l
                            },
                            l: {
                                validator: l
                            }
                        },
                        onUnMask: function(e, t, i) {
                            return e;
                        },
                        inputmode: "decimal",
                        substitutes: {
                            ",": "."
                        }
                    },
                    email: {
                        mask: function(e) {
                            var t = e.separator, i = e.quantifier, n = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", a = n;
                            if (t) for (var r = 0; r < i; r++) a += "[".concat(t).concat(n, "]");
                            return a;
                        },
                        greedy: !1,
                        casing: "lower",
                        separator: null,
                        quantifier: 5,
                        skipOptionalPartCharacter: "",
                        onBeforePaste: function(e, t) {
                            return (e = e.toLowerCase()).replace("mailto:", "");
                        },
                        definitions: {
                            "*": {
                                validator: "[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5!#$%&'*+/=?^_`{|}~-]"
                            },
                            "-": {
                                validator: "[0-9A-Za-z-]"
                            }
                        },
                        onUnMask: function(e, t, i) {
                            return e;
                        },
                        inputmode: "email"
                    },
                    mac: {
                        mask: "##:##:##:##:##:##"
                    },
                    vin: {
                        mask: "V{13}9{4}",
                        definitions: {
                            V: {
                                validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                                casing: "upper"
                            }
                        },
                        clearIncomplete: !0,
                        autoUnmask: !0
                    },
                    ssn: {
                        mask: "999-99-9999",
                        postValidation: function(e, t, i, n, a, s, l) {
                            var c = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);
                            return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(c.join(""));
                        }
                    }
                });
            },
            207: function(e, t, i) {
                var n = s(i(2394)), a = s(i(7184)), r = i(8711), o = i(2839);
                function s(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                var l = n.default.dependencyLib;
                function c(e, t) {
                    for (var i = "", a = 0; a < e.length; a++) n.default.prototype.definitions[e.charAt(a)] || t.definitions[e.charAt(a)] || t.optionalmarker[0] === e.charAt(a) || t.optionalmarker[1] === e.charAt(a) || t.quantifiermarker[0] === e.charAt(a) || t.quantifiermarker[1] === e.charAt(a) || t.groupmarker[0] === e.charAt(a) || t.groupmarker[1] === e.charAt(a) || t.alternatormarker === e.charAt(a) ? i += "\\" + e.charAt(a) : i += e.charAt(a);
                    return i;
                }
                function u(e, t, i, n) {
                    if (e.length > 0 && t > 0 && (!i.digitsOptional || n)) {
                        var a = e.indexOf(i.radixPoint), r = !1;
                        i.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === a && (e.push(i.radixPoint), 
                        a = e.length - 1);
                        for (var o = 1; o <= t; o++) isFinite(e[a + o]) || (e[a + o] = "0");
                    }
                    return r && e.push(i.negationSymbol.back), e;
                }
                function f(e, t) {
                    var i = 0;
                    for (var n in "+" === e && (i = r.seekNext.call(this, t.validPositions.length - 1)), 
                    t.tests) if ((n = parseInt(n)) >= i) for (var a = 0, o = t.tests[n].length; a < o; a++) if ((void 0 === t.validPositions[n] || "-" === e) && t.tests[n][a].match.def === e) return n + (void 0 !== t.validPositions[n] && "-" !== e ? 1 : 0);
                    return i;
                }
                function d(e, t) {
                    for (var i = -1, n = 0, a = t.validPositions.length; n < a; n++) {
                        var r = t.validPositions[n];
                        if (r && r.match.def === e) {
                            i = n;
                            break;
                        }
                    }
                    return i;
                }
                function p(e, t, i, n, a) {
                    var r = t.buffer ? t.buffer.indexOf(a.radixPoint) : -1, o = (-1 !== r || n && a.jitMasking) && new RegExp(a.definitions[9].validator).test(e);
                    return a._radixDance && -1 !== r && o && null == t.validPositions[r] ? {
                        insert: {
                            pos: r === i ? r + 1 : r,
                            c: a.radixPoint
                        },
                        pos: i
                    } : o;
                }
                n.default.extendAliases({
                    numeric: {
                        mask: function(e) {
                            e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && "0" !== e.digits && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""), 
                            " " === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)), 
                            "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && (e.positionCaretOnClick = "lvp");
                            var t = "0", i = e.radixPoint;
                            !0 === e.numericInput && void 0 === e.__financeInput ? (t = "1", e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick, 
                            e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, i = "," === e.radixPoint ? "?" : "!", 
                            "" !== e.radixPoint && void 0 === e.definitions[i] && (e.definitions[i] = {}, e.definitions[i].validator = "[" + e.radixPoint + "]", 
                            e.definitions[i].placeholder = e.radixPoint, e.definitions[i].static = !0, e.definitions[i].generated = !0)) : (e.__financeInput = !1, 
                            e.numericInput = !0);
                            var n, r = "[+]";
                            if (r += c(e.prefix, e), "" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {}, 
                            e.definitions[e.groupSeparator].validator = "[" + e.groupSeparator + "]", e.definitions[e.groupSeparator].placeholder = e.groupSeparator, 
                            e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0), 
                            r += e._mask(e)) : r += "9{+}", void 0 !== e.digits && 0 !== e.digits) {
                                var o = e.digits.toString().split(",");
                                isFinite(o[0]) && o[1] && isFinite(o[1]) ? r += i + t + "{" + e.digits + "}" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (n = r + i + t + "{0," + e.digits + "}", 
                                e.keepStatic = !0) : r += i + t + "{" + e.digits + "}");
                            } else e.inputmode = "numeric";
                            return r += c(e.suffix, e), r += "[-]", n && (r = [ n + c(e.suffix, e) + "[-]", r ]), 
                            e.greedy = !1, function(e) {
                                void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0, 
                                a.default)(e.groupSeparator), "g"), ""), "," === e.radixPoint && (e.min = e.min.replace(e.radixPoint, ".")), 
                                e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)), 
                                null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, a.default)(e.groupSeparator), "g"), ""), 
                                "," === e.radixPoint && (e.max = e.max.replace(e.radixPoint, ".")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN, 
                                isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = "done");
                            }(e), "" !== e.radixPoint && e.substituteRadixPoint && (e.substitutes["." == e.radixPoint ? "," : "."] = e.radixPoint), 
                            r;
                        },
                        _mask: function(e) {
                            return "(" + e.groupSeparator + "999){+|1}";
                        },
                        digits: "*",
                        digitsOptional: !0,
                        enforceDigitsOnBlur: !1,
                        radixPoint: ".",
                        positionCaretOnClick: "radixFocus",
                        _radixDance: !0,
                        groupSeparator: "",
                        allowMinus: !0,
                        negationSymbol: {
                            front: "-",
                            back: ""
                        },
                        prefix: "",
                        suffix: "",
                        min: null,
                        max: null,
                        SetMaxOnOverflow: !1,
                        step: 1,
                        inputType: "text",
                        unmaskAsNumber: !1,
                        roundingFN: Math.round,
                        inputmode: "decimal",
                        shortcuts: {
                            k: "1000",
                            m: "1000000"
                        },
                        placeholder: "0",
                        greedy: !1,
                        rightAlign: !0,
                        insertMode: !0,
                        autoUnmask: !1,
                        skipOptionalPartCharacter: "",
                        usePrototypeDefinitions: !1,
                        stripLeadingZeroes: !0,
                        substituteRadixPoint: !0,
                        definitions: {
                            0: {
                                validator: p
                            },
                            1: {
                                validator: p,
                                definitionSymbol: "9"
                            },
                            9: {
                                validator: "[0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]",
                                definitionSymbol: "*"
                            },
                            "+": {
                                validator: function(e, t, i, n, a) {
                                    return a.allowMinus && ("-" === e || e === a.negationSymbol.front);
                                }
                            },
                            "-": {
                                validator: function(e, t, i, n, a) {
                                    return a.allowMinus && e === a.negationSymbol.back;
                                }
                            }
                        },
                        preValidation: function(e, t, i, n, a, r, o, s) {
                            if (!1 !== a.__financeInput && i === a.radixPoint) return !1;
                            var l = e.indexOf(a.radixPoint), c = t;
                            if (t = function(e, t, i, n, a) {
                                return a._radixDance && a.numericInput && t !== a.negationSymbol.back && e <= i && (i > 0 || t == a.radixPoint) && (void 0 === n.validPositions[e - 1] || n.validPositions[e - 1].input !== a.negationSymbol.back) && (e -= 1), 
                                e;
                            }(t, i, l, r, a), "-" === i || i === a.negationSymbol.front) {
                                if (!0 !== a.allowMinus) return !1;
                                var u = !1, p = d("+", r), h = d("-", r);
                                return -1 !== p && (u = [ p, h ]), !1 !== u ? {
                                    remove: u,
                                    caret: c - a.negationSymbol.back.length
                                } : {
                                    insert: [ {
                                        pos: f.call(this, "+", r),
                                        c: a.negationSymbol.front,
                                        fromIsValid: !0
                                    }, {
                                        pos: f.call(this, "-", r),
                                        c: a.negationSymbol.back,
                                        fromIsValid: void 0
                                    } ],
                                    caret: c + a.negationSymbol.back.length
                                };
                            }
                            if (i === a.groupSeparator) return {
                                caret: c
                            };
                            if (s) return !0;
                            if (-1 !== l && !0 === a._radixDance && !1 === n && i === a.radixPoint && void 0 !== a.digits && (isNaN(a.digits) || parseInt(a.digits) > 0) && l !== t) return {
                                caret: a._radixDance && t === l - 1 ? l + 1 : l
                            };
                            if (!1 === a.__financeInput) if (n) {
                                if (a.digitsOptional) return {
                                    rewritePosition: o.end
                                };
                                if (!a.digitsOptional) {
                                    if (o.begin > l && o.end <= l) return i === a.radixPoint ? {
                                        insert: {
                                            pos: l + 1,
                                            c: "0",
                                            fromIsValid: !0
                                        },
                                        rewritePosition: l
                                    } : {
                                        rewritePosition: l + 1
                                    };
                                    if (o.begin < l) return {
                                        rewritePosition: o.begin - 1
                                    };
                                }
                            } else if (!a.showMaskOnHover && !a.showMaskOnFocus && !a.digitsOptional && a.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                                rewritePosition: l
                            };
                            return {
                                rewritePosition: t
                            };
                        },
                        postValidation: function(e, t, i, n, a, r, o) {
                            if (!1 === n) return n;
                            if (o) return !0;
                            if (null !== a.min || null !== a.max) {
                                var s = a.onUnMask(e.slice().reverse().join(""), void 0, l.extend({}, a, {
                                    unmaskAsNumber: !0
                                }));
                                if (null !== a.min && s < a.min && (s.toString().length > a.min.toString().length || s < 0)) return !1;
                                if (null !== a.max && s > a.max) return !!a.SetMaxOnOverflow && {
                                    refreshFromBuffer: !0,
                                    buffer: u(a.max.toString().replace(".", a.radixPoint).split(""), a.digits, a).reverse()
                                };
                            }
                            return n;
                        },
                        onUnMask: function(e, t, i) {
                            if ("" === t && !0 === i.nullable) return t;
                            var n = e.replace(i.prefix, "");
                            return n = (n = n.replace(i.suffix, "")).replace(new RegExp((0, a.default)(i.groupSeparator), "g"), ""), 
                            "" !== i.placeholder.charAt(0) && (n = n.replace(new RegExp(i.placeholder.charAt(0), "g"), "0")), 
                            i.unmaskAsNumber ? ("" !== i.radixPoint && -1 !== n.indexOf(i.radixPoint) && (n = n.replace(a.default.call(this, i.radixPoint), ".")), 
                            n = (n = n.replace(new RegExp("^" + (0, a.default)(i.negationSymbol.front)), "-")).replace(new RegExp((0, 
                            a.default)(i.negationSymbol.back) + "$"), ""), Number(n)) : n;
                        },
                        isComplete: function(e, t) {
                            var i = (t.numericInput ? e.slice().reverse() : e).join("");
                            return i = (i = (i = (i = (i = i.replace(new RegExp("^" + (0, a.default)(t.negationSymbol.front)), "-")).replace(new RegExp((0, 
                            a.default)(t.negationSymbol.back) + "$"), "")).replace(t.prefix, "")).replace(t.suffix, "")).replace(new RegExp((0, 
                            a.default)(t.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t.radixPoint && (i = i.replace((0, 
                            a.default)(t.radixPoint), ".")), isFinite(i);
                        },
                        onBeforeMask: function(e, t) {
                            var i = t.radixPoint || ",";
                            isFinite(t.digits) && (t.digits = parseInt(t.digits)), "number" != typeof e && "number" !== t.inputType || "" === i || (e = e.toString().replace(".", i));
                            var n = "-" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front, r = e.split(i), o = r[0].replace(/[^\-0-9]/g, ""), s = r.length > 1 ? r[1].replace(/[^0-9]/g, "") : "", l = r.length > 1;
                            e = o + ("" !== s ? i + s : s);
                            var c = 0;
                            if ("" !== i && (c = t.digitsOptional ? t.digits < s.length ? t.digits : s.length : t.digits, 
                            "" !== s || !t.digitsOptional)) {
                                var f = Math.pow(10, c || 1);
                                e = e.replace((0, a.default)(i), "."), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * f) / f).toFixed(c)), 
                                e = e.toString().replace(".", i);
                            }
                            if (0 === t.digits && -1 !== e.indexOf(i) && (e = e.substring(0, e.indexOf(i))), 
                            null !== t.min || null !== t.max) {
                                var d = e.toString().replace(i, ".");
                                null !== t.min && d < t.min ? e = t.min.toString().replace(".", i) : null !== t.max && d > t.max && (e = t.max.toString().replace(".", i));
                            }
                            return n && "-" !== e.charAt(0) && (e = "-" + e), u(e.toString().split(""), c, t, l).join("");
                        },
                        onBeforeWrite: function(e, t, i, n) {
                            function r(e, t) {
                                if (!1 !== n.__financeInput || t) {
                                    var i = e.indexOf(n.radixPoint);
                                    -1 !== i && e.splice(i, 1);
                                }
                                if ("" !== n.groupSeparator) for (;-1 !== (i = e.indexOf(n.groupSeparator)); ) e.splice(i, 1);
                                return e;
                            }
                            var o, s;
                            if (n.stripLeadingZeroes && (s = function(e, t) {
                                var i = new RegExp("(^" + ("" !== t.negationSymbol.front ? (0, a.default)(t.negationSymbol.front) + "?" : "") + (0, 
                                a.default)(t.prefix) + ")(.*)(" + (0, a.default)(t.suffix) + ("" != t.negationSymbol.back ? (0, 
                                a.default)(t.negationSymbol.back) + "?" : "") + "$)").exec(e.slice().reverse().join("")), n = i ? i[2] : "", r = !1;
                                return n && (n = n.split(t.radixPoint.charAt(0))[0], r = new RegExp("^[0" + t.groupSeparator + "]*").exec(n)), 
                                !(!r || !(r[0].length > 1 || r[0].length > 0 && r[0].length < n.length)) && r;
                            }(t, n))) for (var c = t.join("").lastIndexOf(s[0].split("").reverse().join("")) - (s[0] == s.input ? 0 : 1), f = s[0] == s.input ? 1 : 0, d = s[0].length - f; d > 0; d--) delete this.maskset.validPositions[c + d], 
                            delete t[c + d];
                            if (e) switch (e.type) {
                              case "blur":
                              case "checkval":
                                if (null !== n.min) {
                                    var p = n.onUnMask(t.slice().reverse().join(""), void 0, l.extend({}, n, {
                                        unmaskAsNumber: !0
                                    }));
                                    if (null !== n.min && p < n.min) return {
                                        refreshFromBuffer: !0,
                                        buffer: u(n.min.toString().replace(".", n.radixPoint).split(""), n.digits, n).reverse()
                                    };
                                }
                                if (t[t.length - 1] === n.negationSymbol.front) {
                                    var h = new RegExp("(^" + ("" != n.negationSymbol.front ? (0, a.default)(n.negationSymbol.front) + "?" : "") + (0, 
                                    a.default)(n.prefix) + ")(.*)(" + (0, a.default)(n.suffix) + ("" != n.negationSymbol.back ? (0, 
                                    a.default)(n.negationSymbol.back) + "?" : "") + "$)").exec(r(t.slice(), !0).reverse().join(""));
                                    0 == (h ? h[2] : "") && (o = {
                                        refreshFromBuffer: !0,
                                        buffer: [ 0 ]
                                    });
                                } else if ("" !== n.radixPoint) {
                                    t.indexOf(n.radixPoint) === n.suffix.length && (o && o.buffer ? o.buffer.splice(0, 1 + n.suffix.length) : (t.splice(0, 1 + n.suffix.length), 
                                    o = {
                                        refreshFromBuffer: !0,
                                        buffer: r(t)
                                    }));
                                }
                                if (n.enforceDigitsOnBlur) {
                                    var v = (o = o || {}) && o.buffer || t.slice().reverse();
                                    o.refreshFromBuffer = !0, o.buffer = u(v, n.digits, n, !0).reverse();
                                }
                            }
                            return o;
                        },
                        onKeyDown: function(e, t, i, n) {
                            var a, r = l(this);
                            if (3 != e.location) {
                                var s, c = e.key;
                                if ((s = n.shortcuts && n.shortcuts[c]) && s.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(s)), 
                                r.trigger("setvalue"), !1;
                            }
                            if (e.ctrlKey) switch (e.key) {
                              case o.keys.ArrowUp:
                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(n.step)), 
                                r.trigger("setvalue"), !1;

                              case o.keys.ArrowDown:
                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(n.step)), 
                                r.trigger("setvalue"), !1;
                            }
                            if (!e.shiftKey && (e.key === o.keys.Delete || e.key === o.keys.Backspace || e.key === o.keys.BACKSPACE_SAFARI) && i.begin !== t.length) {
                                if (t[e.key === o.keys.Delete ? i.begin - 1 : i.end] === n.negationSymbol.front) return a = t.slice().reverse(), 
                                "" !== n.negationSymbol.front && a.shift(), "" !== n.negationSymbol.back && a.pop(), 
                                r.trigger("setvalue", [ a.join(""), i.begin ]), !1;
                                if (!0 === n._radixDance) {
                                    var f = t.indexOf(n.radixPoint);
                                    if (n.digitsOptional) {
                                        if (0 === f) return (a = t.slice().reverse()).pop(), r.trigger("setvalue", [ a.join(""), i.begin >= a.length ? a.length : i.begin ]), 
                                        !1;
                                    } else if (-1 !== f && (i.begin < f || i.end < f || e.key === o.keys.Delete && (i.begin === f || i.begin - 1 === f))) {
                                        var d = void 0;
                                        return i.begin === i.end && (e.key === o.keys.Backspace || e.key === o.keys.BACKSPACE_SAFARI ? i.begin++ : e.key === o.keys.Delete && i.begin - 1 === f && (d = l.extend({}, i), 
                                        i.begin--, i.end--)), (a = t.slice().reverse()).splice(a.length - i.begin, i.begin - i.end + 1), 
                                        a = u(a, n.digits, n).join(""), d && (i = d), r.trigger("setvalue", [ a, i.begin >= a.length ? f + 1 : i.begin ]), 
                                        !1;
                                    }
                                }
                            }
                        }
                    },
                    currency: {
                        prefix: "",
                        groupSeparator: ",",
                        alias: "numeric",
                        digits: 2,
                        digitsOptional: !1
                    },
                    decimal: {
                        alias: "numeric"
                    },
                    integer: {
                        alias: "numeric",
                        inputmode: "numeric",
                        digits: 0
                    },
                    percentage: {
                        alias: "numeric",
                        min: 0,
                        max: 100,
                        suffix: " %",
                        digits: 0,
                        allowMinus: !1
                    },
                    indianns: {
                        alias: "numeric",
                        _mask: function(e) {
                            return "(" + e.groupSeparator + "99){*|1}(" + e.groupSeparator + "999){1|1}";
                        },
                        groupSeparator: ",",
                        radixPoint: ".",
                        placeholder: "0",
                        digits: 2,
                        digitsOptional: !1
                    }
                });
            },
            9380: function(e, t, i) {
                var n;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var a = ((n = i(8741)) && n.__esModule ? n : {
                    default: n
                }).default ? window : {};
                t.default = a;
            },
            7760: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HandleNativePlaceholder = function(e, t) {
                    var i = e ? e.inputmask : this;
                    if (s.ie) {
                        if (e.inputmask._valueGet() !== t && (e.placeholder !== t || "" === e.placeholder)) {
                            var n = r.getBuffer.call(i).slice(), a = e.inputmask._valueGet();
                            if (a !== t) {
                                var o = r.getLastValidPosition.call(i);
                                -1 === o && a === r.getBufferTemplate.call(i).join("") ? n = [] : -1 !== o && u.call(i, n), 
                                d(e, n);
                            }
                        }
                    } else e.placeholder !== t && (e.placeholder = t, "" === e.placeholder && e.removeAttribute("placeholder"));
                }, t.applyInputValue = c, t.checkVal = f, t.clearOptionalTail = u, t.unmaskedvalue = function(e) {
                    var t = e ? e.inputmask : this, i = t.opts, n = t.maskset;
                    if (e) {
                        if (void 0 === e.inputmask) return e.value;
                        e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));
                    }
                    for (var a = [], o = n.validPositions, s = 0, l = o.length; s < l; s++) o[s] && o[s].match && (1 != o[s].match.static || Array.isArray(n.metadata) && !0 !== o[s].generatedInput) && a.push(o[s].input);
                    var u = 0 === a.length ? "" : (t.isRTL ? a.reverse() : a).join("");
                    if ("function" == typeof i.onUnMask) {
                        var f = (t.isRTL ? r.getBuffer.call(t).slice().reverse() : r.getBuffer.call(t)).join("");
                        u = i.onUnMask.call(t, f, u, i);
                    }
                    return u;
                }, t.writeBuffer = d;
                var n = i(2839), a = i(4713), r = i(8711), o = i(7215), s = i(9845), l = i(6030);
                function c(e, t) {
                    var i = e ? e.inputmask : this, n = i.opts;
                    e.inputmask.refreshValue = !1, "function" == typeof n.onBeforeMask && (t = n.onBeforeMask.call(i, t, n) || t), 
                    f(e, !0, !1, t = (t || "").toString().split("")), i.undoValue = i._valueGet(!0), 
                    (n.clearMaskOnLostFocus || n.clearIncomplete) && e.inputmask._valueGet() === r.getBufferTemplate.call(i).join("") && -1 === r.getLastValidPosition.call(i) && e.inputmask._valueSet("");
                }
                function u(e) {
                    e.length = 0;
                    for (var t, i = a.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = i.shift()); ) e.push(t);
                    return e;
                }
                function f(e, t, i, n, s) {
                    var c = e ? e.inputmask : this, u = c.maskset, f = c.opts, p = c.dependencyLib, h = n.slice(), v = "", m = -1, g = void 0, y = f.skipOptionalPartCharacter;
                    f.skipOptionalPartCharacter = "", r.resetMaskSet.call(c), u.tests = {}, m = f.radixPoint ? r.determineNewCaretPosition.call(c, {
                        begin: 0,
                        end: 0
                    }, !1, !1 === f.__financeInput ? "radixFocus" : void 0).begin : 0, u.p = m, c.caretPos = {
                        begin: m
                    };
                    var k = [], b = c.caretPos;
                    if (h.forEach((function(e, t) {
                        if (void 0 !== e) {
                            var n = new p.Event("_checkval");
                            n.key = e, v += e;
                            var o = r.getLastValidPosition.call(c, void 0, !0);
                            !function(e, t) {
                                for (var i = a.getMaskTemplate.call(c, !0, 0).slice(e, r.seekNext.call(c, e, !1, !1)).join("").replace(/'/g, ""), n = i.indexOf(t); n > 0 && " " === i[n - 1]; ) n--;
                                var o = 0 === n && !r.isMask.call(c, e) && (a.getTest.call(c, e).match.nativeDef === t.charAt(0) || !0 === a.getTest.call(c, e).match.static && a.getTest.call(c, e).match.nativeDef === "'" + t.charAt(0) || " " === a.getTest.call(c, e).match.nativeDef && (a.getTest.call(c, e + 1).match.nativeDef === t.charAt(0) || !0 === a.getTest.call(c, e + 1).match.static && a.getTest.call(c, e + 1).match.nativeDef === "'" + t.charAt(0)));
                                if (!o && n > 0 && !r.isMask.call(c, e, !1, !0)) {
                                    var s = r.seekNext.call(c, e);
                                    c.caretPos.begin < s && (c.caretPos = {
                                        begin: s
                                    });
                                }
                                return o;
                            }(m, v) ? (g = l.EventHandlers.keypressEvent.call(c, n, !0, !1, i, c.caretPos.begin)) && (m = c.caretPos.begin + 1, 
                            v = "") : g = l.EventHandlers.keypressEvent.call(c, n, !0, !1, i, o + 1), g ? (void 0 !== g.pos && u.validPositions[g.pos] && !0 === u.validPositions[g.pos].match.static && void 0 === u.validPositions[g.pos].alternation && (k.push(g.pos), 
                            c.isRTL || (g.forwardPosition = g.pos + 1)), d.call(c, void 0, r.getBuffer.call(c), g.forwardPosition, n, !1), 
                            c.caretPos = {
                                begin: g.forwardPosition,
                                end: g.forwardPosition
                            }, b = c.caretPos) : void 0 === u.validPositions[t] && h[t] === a.getPlaceholder.call(c, t) && r.isMask.call(c, t, !0) ? c.caretPos.begin++ : c.caretPos = b;
                        }
                    })), k.length > 0) {
                        var x, P, w = r.seekNext.call(c, -1, void 0, !1);
                        if (!o.isComplete.call(c, r.getBuffer.call(c)) && k.length <= w || o.isComplete.call(c, r.getBuffer.call(c)) && k.length > 0 && k.length !== w && 0 === k[0]) for (var S = w; void 0 !== (x = k.shift()); ) {
                            var M = new p.Event("_checkval");
                            if ((P = u.validPositions[x]).generatedInput = !0, M.key = P.input, (g = l.EventHandlers.keypressEvent.call(c, M, !0, !1, i, S)) && void 0 !== g.pos && g.pos !== x && u.validPositions[g.pos] && !0 === u.validPositions[g.pos].match.static) k.push(g.pos); else if (!g) break;
                            S++;
                        }
                    }
                    t && d.call(c, e, r.getBuffer.call(c), g ? g.forwardPosition : c.caretPos.begin, s || new p.Event("checkval"), s && ("input" === s.type && c.undoValue !== r.getBuffer.call(c).join("") || "paste" === s.type)), 
                    f.skipOptionalPartCharacter = y;
                }
                function d(e, t, i, a, s) {
                    var l = e ? e.inputmask : this, c = l.opts, u = l.dependencyLib;
                    if (a && "function" == typeof c.onBeforeWrite) {
                        var f = c.onBeforeWrite.call(l, a, t, i, c);
                        if (f) {
                            if (f.refreshFromBuffer) {
                                var d = f.refreshFromBuffer;
                                o.refreshFromBuffer.call(l, !0 === d ? d : d.start, d.end, f.buffer || t), t = r.getBuffer.call(l, !0);
                            }
                            void 0 !== i && (i = void 0 !== f.caret ? f.caret : i);
                        }
                    }
                    if (void 0 !== e && (e.inputmask._valueSet(t.join("")), void 0 === i || void 0 !== a && "blur" === a.type || r.caret.call(l, e, i, void 0, void 0, void 0 !== a && "keydown" === a.type && (a.key === n.keys.Delete || a.key === n.keys.Backspace)), 
                    !0 === s)) {
                        var p = u(e), h = e.inputmask._valueGet();
                        e.inputmask.skipInputEvent = !0, p.trigger("input"), setTimeout((function() {
                            h === r.getBufferTemplate.call(l).join("") ? p.trigger("cleared") : !0 === o.isComplete.call(l, t) && p.trigger("complete");
                        }), 0);
                    }
                }
            },
            2394: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = i(157), a = m(i(4963)), r = m(i(9380)), o = i(2391), s = i(4713), l = i(8711), c = i(7215), u = i(7760), f = i(9716), d = m(i(7392)), p = m(i(3976)), h = m(i(8741));
                function v(e) {
                    return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e;
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                    }, v(e);
                }
                function m(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                var g = r.default.document, y = "_inputmask_opts";
                function k(e, t, i) {
                    if (h.default) {
                        if (!(this instanceof k)) return new k(e, t, i);
                        this.dependencyLib = a.default, this.el = void 0, this.events = {}, this.maskset = void 0, 
                        !0 !== i && ("[object Object]" === Object.prototype.toString.call(e) ? t = e : (t = t || {}, 
                        e && (t.alias = e)), this.opts = a.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, 
                        this.userOptions = t || {}, b(this.opts.alias, t, this.opts)), this.refreshValue = !1, 
                        this.undoValue = void 0, this.$el = void 0, this.skipInputEvent = !1, this.validationEvent = !1, 
                        this.ignorable = !1, this.maxLength, this.mouseEnter = !1, this.clicked = 0, this.originalPlaceholder = void 0, 
                        this.isComposing = !1, this.hasAlternator = !1;
                    }
                }
                function b(e, t, i) {
                    var n = k.prototype.aliases[e];
                    return n ? (n.alias && b(n.alias, void 0, i), a.default.extend(!0, i, n), a.default.extend(!0, i, t), 
                    !0) : (null === i.mask && (i.mask = e), !1);
                }
                k.prototype = {
                    dataAttribute: "data-inputmask",
                    defaults: p.default,
                    definitions: d.default,
                    aliases: {},
                    masksCache: {},
                    get isRTL() {
                        return this.opts.isRTL || this.opts.numericInput;
                    },
                    mask: function(e) {
                        var t = this;
                        return "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), 
                        (e = e.nodeName ? [ e ] : Array.isArray(e) ? e : [].slice.call(e)).forEach((function(e, i) {
                            var s = a.default.extend(!0, {}, t.opts);
                            if (function(e, t, i, n) {
                                function o(t, a) {
                                    var o = "" === n ? t : n + "-" + t;
                                    null !== (a = void 0 !== a ? a : e.getAttribute(o)) && ("string" == typeof a && (0 === t.indexOf("on") ? a = r.default[a] : "false" === a ? a = !1 : "true" === a && (a = !0)), 
                                    i[t] = a);
                                }
                                if (!0 === t.importDataAttributes) {
                                    var s, l, c, u, f = e.getAttribute(n);
                                    if (f && "" !== f && (f = f.replace(/'/g, '"'), l = JSON.parse("{" + f + "}")), 
                                    l) for (u in c = void 0, l) if ("alias" === u.toLowerCase()) {
                                        c = l[u];
                                        break;
                                    }
                                    for (s in o("alias", c), i.alias && b(i.alias, i, t), t) {
                                        if (l) for (u in c = void 0, l) if (u.toLowerCase() === s.toLowerCase()) {
                                            c = l[u];
                                            break;
                                        }
                                        o(s, c);
                                    }
                                }
                                a.default.extend(!0, t, i), ("rtl" === e.dir || t.rightAlign) && (e.style.textAlign = "right");
                                ("rtl" === e.dir || t.numericInput) && (e.dir = "ltr", e.removeAttribute("dir"), 
                                t.isRTL = !0);
                                return Object.keys(i).length;
                            }(e, s, a.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {
                                var l = (0, o.generateMaskSet)(s, t.noMasksCache);
                                void 0 !== l && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()), 
                                e.inputmask = new k(void 0, void 0, !0), e.inputmask.opts = s, e.inputmask.noMasksCache = t.noMasksCache, 
                                e.inputmask.userOptions = a.default.extend(!0, {}, t.userOptions), e.inputmask.el = e, 
                                e.inputmask.$el = (0, a.default)(e), e.inputmask.maskset = l, a.default.data(e, y, t.userOptions), 
                                n.mask.call(e.inputmask));
                            }
                        })), e && e[0] && e[0].inputmask || this;
                    },
                    option: function(e, t) {
                        return "string" == typeof e ? this.opts[e] : "object" === v(e) ? (a.default.extend(this.userOptions, e), 
                        this.el && !0 !== t && this.mask(this.el), this) : void 0;
                    },
                    unmaskedvalue: function(e) {
                        if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                        void 0 === this.el || void 0 !== e) {
                            var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                            u.checkVal.call(this, void 0, !1, !1, t), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, l.getBuffer.call(this), 0, this.opts);
                        }
                        return u.unmaskedvalue.call(this, this.el);
                    },
                    remove: function() {
                        if (this.el) {
                            a.default.data(this.el, y, null);
                            var e = this.opts.autoUnmask ? (0, u.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                            e !== l.getBufferTemplate.call(this).join("") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(""), 
                            f.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                                get: this.__valueGet,
                                set: this.__valueSet,
                                configurable: !0
                            }) : g.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), 
                            this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                        }
                        return this.el;
                    },
                    getemptymask: function() {
                        return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                        (this.isRTL ? l.getBufferTemplate.call(this).reverse() : l.getBufferTemplate.call(this)).join("");
                    },
                    hasMaskedValue: function() {
                        return !this.opts.autoUnmask;
                    },
                    isComplete: function() {
                        return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                        c.isComplete.call(this, l.getBuffer.call(this));
                    },
                    getmetadata: function() {
                        if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                        Array.isArray(this.maskset.metadata)) {
                            var e = s.getMaskTemplate.call(this, !0, 0, !1).join("");
                            return this.maskset.metadata.forEach((function(t) {
                                return t.mask !== e || (e = t, !1);
                            })), e;
                        }
                        return this.maskset.metadata;
                    },
                    isValid: function(e) {
                        if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                        e) {
                            var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                            u.checkVal.call(this, void 0, !0, !1, t);
                        } else e = this.isRTL ? l.getBuffer.call(this).slice().reverse().join("") : l.getBuffer.call(this).join("");
                        for (var i = l.getBuffer.call(this), n = l.determineLastRequiredPosition.call(this), a = i.length - 1; a > n && !l.isMask.call(this, a); a--) ;
                        return i.splice(n, a + 1 - n), c.isComplete.call(this, i) && e === (this.isRTL ? l.getBuffer.call(this).slice().reverse().join("") : l.getBuffer.call(this).join(""));
                    },
                    format: function(e, t) {
                        this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache);
                        var i = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                        u.checkVal.call(this, void 0, !0, !1, i);
                        var n = this.isRTL ? l.getBuffer.call(this).slice().reverse().join("") : l.getBuffer.call(this).join("");
                        return t ? {
                            value: n,
                            metadata: this.getmetadata()
                        } : n;
                    },
                    setValue: function(e) {
                        this.el && (0, a.default)(this.el).trigger("setvalue", [ e ]);
                    },
                    analyseMask: o.analyseMask
                }, k.extendDefaults = function(e) {
                    a.default.extend(!0, k.prototype.defaults, e);
                }, k.extendDefinitions = function(e) {
                    a.default.extend(!0, k.prototype.definitions, e);
                }, k.extendAliases = function(e) {
                    a.default.extend(!0, k.prototype.aliases, e);
                }, k.format = function(e, t, i) {
                    return k(t).format(e, i);
                }, k.unmask = function(e, t) {
                    return k(t).unmaskedvalue(e);
                }, k.isValid = function(e, t) {
                    return k(t).isValid(e);
                }, k.remove = function(e) {
                    "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                        e.inputmask && e.inputmask.remove();
                    }));
                }, k.setValue = function(e, t) {
                    "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                        e.inputmask ? e.inputmask.setValue(t) : (0, a.default)(e).trigger("setvalue", [ t ]);
                    }));
                }, k.dependencyLib = a.default, r.default.Inputmask = k;
                var x = k;
                t.default = x;
            },
            5296: function(e, t, i) {
                function n(e) {
                    return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e;
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                    }, n(e);
                }
                var a = h(i(9380)), r = h(i(2394)), o = h(i(8741));
                function s(e, t) {
                    for (var i = 0; i < t.length; i++) {
                        var a = t[i];
                        a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), 
                        Object.defineProperty(e, (r = a.key, o = void 0, o = function(e, t) {
                            if ("object" !== n(e) || null === e) return e;
                            var i = e[Symbol.toPrimitive];
                            if (void 0 !== i) {
                                var a = i.call(e, t || "default");
                                if ("object" !== n(a)) return a;
                                throw new TypeError("@@toPrimitive must return a primitive value.");
                            }
                            return ("string" === t ? String : Number)(e);
                        }(r, "string"), "symbol" === n(o) ? o : String(o)), a);
                    }
                    var r, o;
                }
                function l(e) {
                    var t = f();
                    return function() {
                        var i, a = p(e);
                        if (t) {
                            var r = p(this).constructor;
                            i = Reflect.construct(a, arguments, r);
                        } else i = a.apply(this, arguments);
                        return function(e, t) {
                            if (t && ("object" === n(t) || "function" == typeof t)) return t;
                            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                            return function(e) {
                                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return e;
                            }(e);
                        }(this, i);
                    };
                }
                function c(e) {
                    var t = "function" == typeof Map ? new Map : void 0;
                    return c = function(e) {
                        if (null === e || (i = e, -1 === Function.toString.call(i).indexOf("[native code]"))) return e;
                        var i;
                        if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== t) {
                            if (t.has(e)) return t.get(e);
                            t.set(e, n);
                        }
                        function n() {
                            return u(e, arguments, p(this).constructor);
                        }
                        return n.prototype = Object.create(e.prototype, {
                            constructor: {
                                value: n,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), d(n, e);
                    }, c(e);
                }
                function u(e, t, i) {
                    return u = f() ? Reflect.construct.bind() : function(e, t, i) {
                        var n = [ null ];
                        n.push.apply(n, t);
                        var a = new (Function.bind.apply(e, n));
                        return i && d(a, i.prototype), a;
                    }, u.apply(null, arguments);
                }
                function f() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                        !0;
                    } catch (e) {
                        return !1;
                    }
                }
                function d(e, t) {
                    return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                        return e.__proto__ = t, e;
                    }, d(e, t);
                }
                function p(e) {
                    return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e);
                    }, p(e);
                }
                function h(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
                var v = a.default.document;
                if (o.default && v && v.head && v.head.attachShadow && a.default.customElements && void 0 === a.default.customElements.get("input-mask")) {
                    var m = function(e) {
                        !function(e, t) {
                            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                            e.prototype = Object.create(t && t.prototype, {
                                constructor: {
                                    value: e,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), Object.defineProperty(e, "prototype", {
                                writable: !1
                            }), t && d(e, t);
                        }(o, e);
                        var t, i, n, a = l(o);
                        function o() {
                            var e;
                            !function(e, t) {
                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                            }(this, o);
                            var t = (e = a.call(this)).getAttributeNames(), i = e.attachShadow({
                                mode: "closed"
                            }), n = v.createElement("input");
                            for (var s in n.type = "text", i.appendChild(n), t) Object.prototype.hasOwnProperty.call(t, s) && n.setAttribute(t[s], e.getAttribute(t[s]));
                            var l = new r.default;
                            return l.dataAttribute = "", l.mask(n), n.inputmask.shadowRoot = i, e;
                        }
                        return t = o, i && s(t.prototype, i), n && s(t, n), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t;
                    }(c(HTMLElement));
                    a.default.customElements.define("input-mask", m);
                }
            },
            2839: function(e, t) {
                function i(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e;
                    }(e) || function(e, t) {
                        var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null != i) {
                            var n, a, r, o, s = [], l = !0, c = !1;
                            try {
                                if (r = (i = i.call(e)).next, 0 === t) {
                                    if (Object(i) !== i) return;
                                    l = !1;
                                } else for (;!(l = (n = r.call(i)).done) && (s.push(n.value), s.length !== t); l = !0) ;
                            } catch (e) {
                                c = !0, a = e;
                            } finally {
                                try {
                                    if (!l && null != i.return && (o = i.return(), Object(o) !== o)) return;
                                } finally {
                                    if (c) throw a;
                                }
                            }
                            return s;
                        }
                    }(e, t) || function(e, t) {
                        if (!e) return;
                        if ("string" == typeof e) return n(e, t);
                        var i = Object.prototype.toString.call(e).slice(8, -1);
                        "Object" === i && e.constructor && (i = e.constructor.name);
                        if ("Map" === i || "Set" === i) return Array.from(e);
                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return n(e, t);
                    }(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }();
                }
                function n(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
                    return n;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.keys = t.keyCode = void 0, t.toKey = function(e, t) {
                    return r[e] || (t ? String.fromCharCode(e) : String.fromCharCode(e).toLowerCase());
                }, t.toKeyCode = function(e) {
                    return a[e];
                };
                var a = {
                    AltGraph: 18,
                    ArrowDown: 40,
                    ArrowLeft: 37,
                    ArrowRight: 39,
                    ArrowUp: 38,
                    Backspace: 8,
                    BACKSPACE_SAFARI: 127,
                    CapsLock: 20,
                    Delete: 46,
                    End: 35,
                    Enter: 13,
                    Escape: 27,
                    Home: 36,
                    Insert: 45,
                    PageDown: 34,
                    PageUp: 33,
                    Space: 32,
                    Tab: 9,
                    c: 67,
                    x: 88,
                    z: 90,
                    Shift: 16,
                    Control: 17,
                    Alt: 18,
                    Pause: 19,
                    Meta_LEFT: 91,
                    Meta_RIGHT: 92,
                    ContextMenu: 93,
                    Process: 229,
                    Unidentified: 229,
                    F1: 112,
                    F2: 113,
                    F3: 114,
                    F4: 115,
                    F5: 116,
                    F6: 117,
                    F7: 118,
                    F8: 119,
                    F9: 120,
                    F10: 121,
                    F11: 122,
                    F12: 123
                };
                t.keyCode = a;
                var r = Object.entries(a).reduce((function(e, t) {
                    var n = i(t, 2), a = n[0], r = n[1];
                    return e[r] = void 0 === e[r] ? a : e[r], e;
                }), {}), o = Object.entries(a).reduce((function(e, t) {
                    var n = i(t, 2), a = n[0];
                    n[1];
                    return e[a] = "Space" === a ? " " : a, e;
                }), {});
                t.keys = o;
            },
            2391: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.analyseMask = function(e, t, i) {
                    var n, o, s, l, c, u, f = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, p = !1, h = new a.default, v = [], m = [], g = !1;
                    function y(e, n, a) {
                        a = void 0 !== a ? a : e.matches.length;
                        var o = e.matches[a - 1];
                        if (t) {
                            if (0 === n.indexOf("[") || p && /\\d|\\s|\\w|\\p/i.test(n) || "." === n) {
                                var s = i.casing ? "i" : "";
                                /^\\p\{.*}$/i.test(n) && (s += "u"), e.matches.splice(a++, 0, {
                                    fn: new RegExp(n, s),
                                    static: !1,
                                    optionality: !1,
                                    newBlockMarker: void 0 === o ? "master" : o.def !== n,
                                    casing: null,
                                    def: n,
                                    placeholder: void 0,
                                    nativeDef: n
                                });
                            } else p && (n = n[n.length - 1]), n.split("").forEach((function(t, n) {
                                o = e.matches[a - 1], e.matches.splice(a++, 0, {
                                    fn: /[a-z]/i.test(i.staticDefinitionSymbol || t) ? new RegExp("[" + (i.staticDefinitionSymbol || t) + "]", i.casing ? "i" : "") : null,
                                    static: !0,
                                    optionality: !1,
                                    newBlockMarker: void 0 === o ? "master" : o.def !== t && !0 !== o.static,
                                    casing: null,
                                    def: i.staticDefinitionSymbol || t,
                                    placeholder: void 0 !== i.staticDefinitionSymbol ? t : void 0,
                                    nativeDef: (p ? "'" : "") + t
                                });
                            }));
                            p = !1;
                        } else {
                            var l = i.definitions && i.definitions[n] || i.usePrototypeDefinitions && r.default.prototype.definitions[n];
                            l && !p ? e.matches.splice(a++, 0, {
                                fn: l.validator ? "string" == typeof l.validator ? new RegExp(l.validator, i.casing ? "i" : "") : new function() {
                                    this.test = l.validator;
                                } : new RegExp("."),
                                static: l.static || !1,
                                optionality: l.optional || !1,
                                defOptionality: l.optional || !1,
                                newBlockMarker: void 0 === o || l.optional ? "master" : o.def !== (l.definitionSymbol || n),
                                casing: l.casing,
                                def: l.definitionSymbol || n,
                                placeholder: l.placeholder,
                                nativeDef: n,
                                generated: l.generated
                            }) : (e.matches.splice(a++, 0, {
                                fn: /[a-z]/i.test(i.staticDefinitionSymbol || n) ? new RegExp("[" + (i.staticDefinitionSymbol || n) + "]", i.casing ? "i" : "") : null,
                                static: !0,
                                optionality: !1,
                                newBlockMarker: void 0 === o ? "master" : o.def !== n && !0 !== o.static,
                                casing: null,
                                def: i.staticDefinitionSymbol || n,
                                placeholder: void 0 !== i.staticDefinitionSymbol ? n : void 0,
                                nativeDef: (p ? "'" : "") + n
                            }), p = !1);
                        }
                    }
                    function k() {
                        if (v.length > 0) {
                            if (y(l = v[v.length - 1], o), l.isAlternator) {
                                c = v.pop();
                                for (var e = 0; e < c.matches.length; e++) c.matches[e].isGroup && (c.matches[e].isGroup = !1);
                                v.length > 0 ? (l = v[v.length - 1]).matches.push(c) : h.matches.push(c);
                            }
                        } else y(h, o);
                    }
                    function b(e) {
                        var t = new a.default(!0);
                        return t.openGroup = !1, t.matches = e, t;
                    }
                    function x() {
                        if ((s = v.pop()).openGroup = !1, void 0 !== s) if (v.length > 0) {
                            if ((l = v[v.length - 1]).matches.push(s), l.isAlternator) {
                                for (var e = (c = v.pop()).matches[0].matches ? c.matches[0].matches.length : 1, t = 0; t < c.matches.length; t++) c.matches[t].isGroup = !1, 
                                c.matches[t].alternatorGroup = !1, null === i.keepStatic && e < (c.matches[t].matches ? c.matches[t].matches.length : 1) && (i.keepStatic = !0), 
                                e = c.matches[t].matches ? c.matches[t].matches.length : 1;
                                v.length > 0 ? (l = v[v.length - 1]).matches.push(c) : h.matches.push(c);
                            }
                        } else h.matches.push(s); else k();
                    }
                    function P(e) {
                        var t = e.pop();
                        return t.isQuantifier && (t = b([ e.pop(), t ])), t;
                    }
                    t && (i.optionalmarker[0] = void 0, i.optionalmarker[1] = void 0);
                    for (;n = t ? d.exec(e) : f.exec(e); ) {
                        if (o = n[0], t) {
                            switch (o.charAt(0)) {
                              case "?":
                                o = "{0,1}";
                                break;

                              case "+":
                              case "*":
                                o = "{" + o + "}";
                                break;

                              case "|":
                                if (0 === v.length) {
                                    var w = b(h.matches);
                                    w.openGroup = !0, v.push(w), h.matches = [], g = !0;
                                }
                            }
                            switch (o) {
                              case "\\d":
                                o = "[0-9]";
                                break;

                              case "\\p":
                                o += d.exec(e)[0], o += d.exec(e)[0];
                            }
                        }
                        if (p) k(); else switch (o.charAt(0)) {
                          case "$":
                          case "^":
                            t || k();
                            break;

                          case i.escapeChar:
                            p = !0, t && k();
                            break;

                          case i.optionalmarker[1]:
                          case i.groupmarker[1]:
                            x();
                            break;

                          case i.optionalmarker[0]:
                            v.push(new a.default(!1, !0));
                            break;

                          case i.groupmarker[0]:
                            v.push(new a.default(!0));
                            break;

                          case i.quantifiermarker[0]:
                            var S = new a.default(!1, !1, !0), M = (o = o.replace(/[{}?]/g, "")).split("|"), _ = M[0].split(","), O = isNaN(_[0]) ? _[0] : parseInt(_[0]), E = 1 === _.length ? O : isNaN(_[1]) ? _[1] : parseInt(_[1]), T = isNaN(M[1]) ? M[1] : parseInt(M[1]);
                            "*" !== O && "+" !== O || (O = "*" === E ? 0 : 1), S.quantifier = {
                                min: O,
                                max: E,
                                jit: T
                            };
                            var j = v.length > 0 ? v[v.length - 1].matches : h.matches;
                            (n = j.pop()).isGroup || (n = b([ n ])), j.push(n), j.push(S);
                            break;

                          case i.alternatormarker:
                            if (v.length > 0) {
                                var A = (l = v[v.length - 1]).matches[l.matches.length - 1];
                                u = l.openGroup && (void 0 === A.matches || !1 === A.isGroup && !1 === A.isAlternator) ? v.pop() : P(l.matches);
                            } else u = P(h.matches);
                            if (u.isAlternator) v.push(u); else if (u.alternatorGroup ? (c = v.pop(), u.alternatorGroup = !1) : c = new a.default(!1, !1, !1, !0), 
                            c.matches.push(u), v.push(c), u.openGroup) {
                                u.openGroup = !1;
                                var D = new a.default(!0);
                                D.alternatorGroup = !0, v.push(D);
                            }
                            break;

                          default:
                            k();
                        }
                    }
                    g && x();
                    for (;v.length > 0; ) s = v.pop(), h.matches.push(s);
                    h.matches.length > 0 && (!function e(n) {
                        n && n.matches && n.matches.forEach((function(a, r) {
                            var o = n.matches[r + 1];
                            (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && a && a.isGroup && (a.isGroup = !1, 
                            t || (y(a, i.groupmarker[0], 0), !0 !== a.openGroup && y(a, i.groupmarker[1]))), 
                            e(a);
                        }));
                    }(h), m.push(h));
                    (i.numericInput || i.isRTL) && function e(t) {
                        for (var n in t.matches = t.matches.reverse(), t.matches) if (Object.prototype.hasOwnProperty.call(t.matches, n)) {
                            var a = parseInt(n);
                            if (t.matches[n].isQuantifier && t.matches[a + 1] && t.matches[a + 1].isGroup) {
                                var r = t.matches[n];
                                t.matches.splice(n, 1), t.matches.splice(a + 1, 0, r);
                            }
                            void 0 !== t.matches[n].matches ? t.matches[n] = e(t.matches[n]) : t.matches[n] = ((o = t.matches[n]) === i.optionalmarker[0] ? o = i.optionalmarker[1] : o === i.optionalmarker[1] ? o = i.optionalmarker[0] : o === i.groupmarker[0] ? o = i.groupmarker[1] : o === i.groupmarker[1] && (o = i.groupmarker[0]), 
                            o);
                        }
                        var o;
                        return t;
                    }(m[0]);
                    return m;
                }, t.generateMaskSet = function(e, t) {
                    var i;
                    function a(e, t) {
                        var i = t.repeat, n = t.groupmarker, a = t.quantifiermarker, r = t.keepStatic;
                        if (i > 0 || "*" === i || "+" === i) {
                            var l = "*" === i ? 0 : "+" === i ? 1 : i;
                            e = n[0] + e + n[1] + a[0] + l + "," + i + a[1];
                        }
                        if (!0 === r) {
                            var c = e.match(new RegExp("(.)\\[([^\\]]*)\\]", "g"));
                            c && c.forEach((function(t, i) {
                                var n = function(e, t) {
                                    return function(e) {
                                        if (Array.isArray(e)) return e;
                                    }(e) || function(e, t) {
                                        var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                        if (null != i) {
                                            var n, a, r, o, s = [], l = !0, c = !1;
                                            try {
                                                if (r = (i = i.call(e)).next, 0 === t) {
                                                    if (Object(i) !== i) return;
                                                    l = !1;
                                                } else for (;!(l = (n = r.call(i)).done) && (s.push(n.value), s.length !== t); l = !0) ;
                                            } catch (e) {
                                                c = !0, a = e;
                                            } finally {
                                                try {
                                                    if (!l && null != i.return && (o = i.return(), Object(o) !== o)) return;
                                                } finally {
                                                    if (c) throw a;
                                                }
                                            }
                                            return s;
                                        }
                                    }(e, t) || function(e, t) {
                                        if (!e) return;
                                        if ("string" == typeof e) return s(e, t);
                                        var i = Object.prototype.toString.call(e).slice(8, -1);
                                        "Object" === i && e.constructor && (i = e.constructor.name);
                                        if ("Map" === i || "Set" === i) return Array.from(e);
                                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return s(e, t);
                                    }(e, t) || function() {
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                    }();
                                }(t.split("["), 2), a = n[0], r = n[1];
                                r = r.replace("]", ""), e = e.replace(new RegExp("".concat((0, o.default)(a), "\\[").concat((0, 
                                o.default)(r), "\\]")), a.charAt(0) === r.charAt(0) ? "(".concat(a, "|").concat(a).concat(r, ")") : "".concat(a, "[").concat(r, "]"));
                            }));
                        }
                        return e;
                    }
                    function l(e, i, o) {
                        var s, l, c = !1;
                        return null !== e && "" !== e || ((c = null !== o.regex) ? e = (e = o.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (c = !0, 
                        e = ".*")), 1 === e.length && !1 === o.greedy && 0 !== o.repeat && (o.placeholder = ""), 
                        e = a(e, o), l = c ? "regex_" + o.regex : o.numericInput ? e.split("").reverse().join("") : e, 
                        null !== o.keepStatic && (l = "ks_" + o.keepStatic + l), void 0 === r.default.prototype.masksCache[l] || !0 === t ? (s = {
                            mask: e,
                            maskToken: r.default.prototype.analyseMask(e, c, o),
                            validPositions: [],
                            _buffer: void 0,
                            buffer: void 0,
                            tests: {},
                            excludes: {},
                            metadata: i,
                            maskLength: void 0,
                            jitOffset: {}
                        }, !0 !== t && (r.default.prototype.masksCache[l] = s, s = n.default.extend(!0, {}, r.default.prototype.masksCache[l]))) : s = n.default.extend(!0, {}, r.default.prototype.masksCache[l]), 
                        s;
                    }
                    "function" == typeof e.mask && (e.mask = e.mask(e));
                    if (Array.isArray(e.mask)) {
                        if (e.mask.length > 1) {
                            null === e.keepStatic && (e.keepStatic = !0);
                            var c = e.groupmarker[0];
                            return (e.isRTL ? e.mask.reverse() : e.mask).forEach((function(t) {
                                c.length > 1 && (c += e.alternatormarker), void 0 !== t.mask && "function" != typeof t.mask ? c += t.mask : c += t;
                            })), l(c += e.groupmarker[1], e.mask, e);
                        }
                        e.mask = e.mask.pop();
                    }
                    i = e.mask && void 0 !== e.mask.mask && "function" != typeof e.mask.mask ? l(e.mask.mask, e.mask, e) : l(e.mask, e.mask, e);
                    null === e.keepStatic && (e.keepStatic = !1);
                    return i;
                };
                var n = l(i(4963)), a = l(i(9695)), r = l(i(2394)), o = l(i(7184));
                function s(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
                    return n;
                }
                function l(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                }
            },
            157: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.mask = function() {
                    var e = this, t = this.opts, i = this.el, u = this.dependencyLib;
                    o.EventRuler.off(i);
                    var f = function(t, i) {
                        "textarea" !== t.tagName.toLowerCase() && i.ignorables.push(n.keys.Enter);
                        var s = t.getAttribute("type"), l = "input" === t.tagName.toLowerCase() && i.supportsInputType.includes(s) || t.isContentEditable || "textarea" === t.tagName.toLowerCase();
                        if (!l) if ("input" === t.tagName.toLowerCase()) {
                            var c = document.createElement("input");
                            c.setAttribute("type", s), l = "text" === c.type, c = null;
                        } else l = "partial";
                        return !1 !== l ? function(t) {
                            var n, s;
                            function l() {
                                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== a.getLastValidPosition.call(e) || !0 !== i.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && i.clearMaskOnLostFocus ? (e.isRTL ? r.clearOptionalTail.call(e, a.getBuffer.call(e).slice()).reverse() : r.clearOptionalTail.call(e, a.getBuffer.call(e).slice())).join("") : n.call(this) : "" : n.call(this);
                            }
                            function c(e) {
                                s.call(this, e), this.inputmask && (0, r.applyInputValue)(this, e);
                            }
                            if (!t.inputmask.__valueGet) {
                                if (!0 !== i.noValuePatching) {
                                    if (Object.getOwnPropertyDescriptor) {
                                        var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), "value") : void 0;
                                        f && f.get && f.set ? (n = f.get, s = f.set, Object.defineProperty(t, "value", {
                                            get: l,
                                            set: c,
                                            configurable: !0
                                        })) : "input" !== t.tagName.toLowerCase() && (n = function() {
                                            return this.textContent;
                                        }, s = function(e) {
                                            this.textContent = e;
                                        }, Object.defineProperty(t, "value", {
                                            get: l,
                                            set: c,
                                            configurable: !0
                                        }));
                                    } else document.__lookupGetter__ && t.__lookupGetter__("value") && (n = t.__lookupGetter__("value"), 
                                    s = t.__lookupSetter__("value"), t.__defineGetter__("value", l), t.__defineSetter__("value", c));
                                    t.inputmask.__valueGet = n, t.inputmask.__valueSet = s;
                                }
                                t.inputmask._valueGet = function(t) {
                                    return e.isRTL && !0 !== t ? n.call(this.el).split("").reverse().join("") : n.call(this.el);
                                }, t.inputmask._valueSet = function(t, i) {
                                    s.call(this.el, null == t ? "" : !0 !== i && e.isRTL ? t.split("").reverse().join("") : t);
                                }, void 0 === n && (n = function() {
                                    return this.value;
                                }, s = function(e) {
                                    this.value = e;
                                }, function(t) {
                                    if (u.valHooks && (void 0 === u.valHooks[t] || !0 !== u.valHooks[t].inputmaskpatch)) {
                                        var n = u.valHooks[t] && u.valHooks[t].get ? u.valHooks[t].get : function(e) {
                                            return e.value;
                                        }, o = u.valHooks[t] && u.valHooks[t].set ? u.valHooks[t].set : function(e, t) {
                                            return e.value = t, e;
                                        };
                                        u.valHooks[t] = {
                                            get: function(t) {
                                                if (t.inputmask) {
                                                    if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();
                                                    var r = n(t);
                                                    return -1 !== a.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== i.nullable ? r : "";
                                                }
                                                return n(t);
                                            },
                                            set: function(e, t) {
                                                var i = o(e, t);
                                                return e.inputmask && (0, r.applyInputValue)(e, t), i;
                                            },
                                            inputmaskpatch: !0
                                        };
                                    }
                                }(t.type), function(e) {
                                    o.EventRuler.on(e, "mouseenter", (function() {
                                        var e = this, t = e.inputmask._valueGet(!0);
                                        t != (e.inputmask.isRTL ? a.getBuffer.call(e.inputmask).slice().reverse() : a.getBuffer.call(e.inputmask)).join("") && (0, 
                                        r.applyInputValue)(e, t);
                                    }));
                                }(t));
                            }
                        }(t) : t.inputmask = void 0, l;
                    }(i, t);
                    if (!1 !== f) {
                        e.originalPlaceholder = i.placeholder, e.maxLength = void 0 !== i ? i.maxLength : void 0, 
                        -1 === e.maxLength && (e.maxLength = void 0), "inputMode" in i && null === i.getAttribute("inputmode") && (i.inputMode = t.inputmode, 
                        i.setAttribute("inputmode", t.inputmode)), !0 === f && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === [ "cc-number", "cc-exp" ].indexOf(i.autocomplete), 
                        s.iphone && (t.insertModeVisual = !1, i.setAttribute("autocorrect", "off")), o.EventRuler.on(i, "submit", c.EventHandlers.submitEvent), 
                        o.EventRuler.on(i, "reset", c.EventHandlers.resetEvent), o.EventRuler.on(i, "blur", c.EventHandlers.blurEvent), 
                        o.EventRuler.on(i, "focus", c.EventHandlers.focusEvent), o.EventRuler.on(i, "invalid", c.EventHandlers.invalidEvent), 
                        o.EventRuler.on(i, "click", c.EventHandlers.clickEvent), o.EventRuler.on(i, "mouseleave", c.EventHandlers.mouseleaveEvent), 
                        o.EventRuler.on(i, "mouseenter", c.EventHandlers.mouseenterEvent), o.EventRuler.on(i, "paste", c.EventHandlers.pasteEvent), 
                        o.EventRuler.on(i, "cut", c.EventHandlers.cutEvent), o.EventRuler.on(i, "complete", t.oncomplete), 
                        o.EventRuler.on(i, "incomplete", t.onincomplete), o.EventRuler.on(i, "cleared", t.oncleared), 
                        !0 !== t.inputEventOnly && o.EventRuler.on(i, "keydown", c.EventHandlers.keyEvent), 
                        (s.mobile || t.inputEventOnly) && i.removeAttribute("maxLength"), o.EventRuler.on(i, "input", c.EventHandlers.inputFallBackEvent)), 
                        o.EventRuler.on(i, "setvalue", c.EventHandlers.setValueEvent), a.getBufferTemplate.call(e).join(""), 
                        e.undoValue = e._valueGet(!0);
                        var d = (i.inputmask.shadowRoot || i.ownerDocument).activeElement;
                        if ("" !== i.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || d === i) {
                            (0, r.applyInputValue)(i, i.inputmask._valueGet(!0), t);
                            var p = a.getBuffer.call(e).slice();
                            !1 === l.isComplete.call(e, p) && t.clearIncomplete && a.resetMaskSet.call(e), t.clearMaskOnLostFocus && d !== i && (-1 === a.getLastValidPosition.call(e) ? p = [] : r.clearOptionalTail.call(e, p)), 
                            (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && d === i || "" !== i.inputmask._valueGet(!0)) && (0, 
                            r.writeBuffer)(i, p), d === i && a.caret.call(e, i, a.seekNext.call(e, a.getLastValidPosition.call(e)));
                        }
                    }
                };
                var n = i(2839), a = i(8711), r = i(7760), o = i(9716), s = i(9845), l = i(7215), c = i(6030);
            },
            9695: function(e, t) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t, i, n) {
                    this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, 
                    this.isOptional = t || !1, this.isQuantifier = i || !1, this.isAlternator = n || !1, 
                    this.quantifier = {
                        min: 1,
                        max: 1
                    };
                };
            },
            3194: function() {
                Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                    value: function(e, t) {
                        if (null == this) throw new TypeError('"this" is null or not defined');
                        var i = Object(this), n = i.length >>> 0;
                        if (0 === n) return !1;
                        for (var a = 0 | t, r = Math.max(a >= 0 ? a : n - Math.abs(a), 0); r < n; ) {
                            if (i[r] === e) return !0;
                            r++;
                        }
                        return !1;
                    }
                });
            },
            9302: function() {
                var e = Function.bind.call(Function.call, Array.prototype.reduce), t = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable), i = Function.bind.call(Function.call, Array.prototype.concat), n = Object.keys;
                Object.entries || (Object.entries = function(a) {
                    return e(n(a), (function(e, n) {
                        return i(e, "string" == typeof n && t(a, n) ? [ [ n, a[n] ] ] : []);
                    }), []);
                });
            },
            7149: function() {
                function e(t) {
                    return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e;
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                    }, e(t);
                }
                "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e("test".__proto__) ? function(e) {
                    return e.__proto__;
                } : function(e) {
                    return e.constructor.prototype;
                });
            },
            4013: function() {
                String.prototype.includes || (String.prototype.includes = function(e, t) {
                    return "number" != typeof t && (t = 0), !(t + e.length > this.length) && -1 !== this.indexOf(e, t);
                });
            },
            8711: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.caret = function(e, t, i, n, a) {
                    var r, o = this, s = this.opts;
                    if (void 0 === t) return "selectionStart" in e && "selectionEnd" in e ? (t = e.selectionStart, 
                    i = e.selectionEnd) : window.getSelection ? (r = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && r.commonAncestorContainer !== e || (t = r.startOffset, 
                    i = r.endOffset) : document.selection && document.selection.createRange && (i = (t = 0 - (r = document.selection.createRange()).duplicate().moveStart("character", -e.inputmask._valueGet().length)) + r.text.length), 
                    {
                        begin: n ? t : c.call(o, t),
                        end: n ? i : c.call(o, i)
                    };
                    if (Array.isArray(t) && (i = o.isRTL ? t[0] : t[1], t = o.isRTL ? t[1] : t[0]), 
                    void 0 !== t.begin && (i = o.isRTL ? t.begin : t.end, t = o.isRTL ? t.end : t.begin), 
                    "number" == typeof t) {
                        t = n ? t : c.call(o, t), i = "number" == typeof (i = n ? i : c.call(o, i)) ? i : t;
                        var l = parseInt(((e.ownerDocument.defaultView || window).getComputedStyle ? (e.ownerDocument.defaultView || window).getComputedStyle(e, null) : e.currentStyle).fontSize) * i;
                        if (e.scrollLeft = l > e.scrollWidth ? l : 0, e.inputmask.caretPos = {
                            begin: t,
                            end: i
                        }, s.insertModeVisual && !1 === s.insertMode && t === i && (a || i++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) if ("setSelectionRange" in e) e.setSelectionRange(t, i); else if (window.getSelection) {
                            if (r = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {
                                var u = document.createTextNode("");
                                e.appendChild(u);
                            }
                            r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), 
                            r.setEnd(e.firstChild, i < e.inputmask._valueGet().length ? i : e.inputmask._valueGet().length), 
                            r.collapse(!0);
                            var f = window.getSelection();
                            f.removeAllRanges(), f.addRange(r);
                        } else e.createTextRange && ((r = e.createTextRange()).collapse(!0), r.moveEnd("character", i), 
                        r.moveStart("character", t), r.select());
                    }
                }, t.determineLastRequiredPosition = function(e) {
                    var t, i, r = this, s = r.maskset, l = r.dependencyLib, c = n.getMaskTemplate.call(r, !0, o.call(r), !0, !0), u = c.length, f = o.call(r), d = {}, p = s.validPositions[f], h = void 0 !== p ? p.locator.slice() : void 0;
                    for (t = f + 1; t < c.length; t++) h = (i = n.getTestTemplate.call(r, t, h, t - 1)).locator.slice(), 
                    d[t] = l.extend(!0, {}, i);
                    var v = p && void 0 !== p.alternation ? p.locator[p.alternation] : void 0;
                    for (t = u - 1; t > f && (((i = d[t]).match.optionality || i.match.optionalQuantifier && i.match.newBlockMarker || v && (v !== d[t].locator[p.alternation] && 1 != i.match.static || !0 === i.match.static && i.locator[p.alternation] && a.checkAlternationMatch.call(r, i.locator[p.alternation].toString().split(","), v.toString().split(",")) && "" !== n.getTests.call(r, t)[0].def)) && c[t] === n.getPlaceholder.call(r, t, i.match)); t--) u--;
                    return e ? {
                        l: u,
                        def: d[u] ? d[u].match : void 0
                    } : u;
                }, t.determineNewCaretPosition = function(e, t, i) {
                    var a = this, c = a.maskset, u = a.opts;
                    t && (a.isRTL ? e.end = e.begin : e.begin = e.end);
                    if (e.begin === e.end) {
                        switch (i = i || u.positionCaretOnClick) {
                          case "none":
                            break;

                          case "select":
                            e = {
                                begin: 0,
                                end: r.call(a).length
                            };
                            break;

                          case "ignore":
                            e.end = e.begin = l.call(a, o.call(a));
                            break;

                          case "radixFocus":
                            if (a.clicked > 1 && 0 == c.validPositions.length) break;
                            if (function(e) {
                                if ("" !== u.radixPoint && 0 !== u.digits) {
                                    var t = c.validPositions;
                                    if (void 0 === t[e] || t[e].input === n.getPlaceholder.call(a, e)) {
                                        if (e < l.call(a, -1)) return !0;
                                        var i = r.call(a).indexOf(u.radixPoint);
                                        if (-1 !== i) {
                                            for (var o = 0, s = t.length; o < s; o++) if (t[o] && i < o && t[o].input !== n.getPlaceholder.call(a, o)) return !1;
                                            return !0;
                                        }
                                    }
                                }
                                return !1;
                            }(e.begin)) {
                                var f = r.call(a).join("").indexOf(u.radixPoint);
                                e.end = e.begin = u.numericInput ? l.call(a, f) : f;
                                break;
                            }

                          default:
                            var d = e.begin, p = o.call(a, d, !0), h = l.call(a, -1 !== p || s.call(a, 0) ? p : -1);
                            if (d <= h) e.end = e.begin = s.call(a, d, !1, !0) ? d : l.call(a, d); else {
                                var v = c.validPositions[p], m = n.getTestTemplate.call(a, h, v ? v.match.locator : void 0, v), g = n.getPlaceholder.call(a, h, m.match);
                                if ("" !== g && r.call(a)[h] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !s.call(a, h, u.keepStatic, !0) && m.match.def === g) {
                                    var y = l.call(a, h);
                                    (d >= y || d === h) && (h = y);
                                }
                                e.end = e.begin = h;
                            }
                        }
                        return e;
                    }
                }, t.getBuffer = r, t.getBufferTemplate = function() {
                    var e = this.maskset;
                    void 0 === e._buffer && (e._buffer = n.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));
                    return e._buffer;
                }, t.getLastValidPosition = o, t.isMask = s, t.resetMaskSet = function(e) {
                    var t = this.maskset;
                    t.buffer = void 0, !0 !== e && (t.validPositions = [], t.p = 0);
                }, t.seekNext = l, t.seekPrevious = function(e, t) {
                    var i = this, a = e - 1;
                    if (e <= 0) return 0;
                    for (;a > 0 && (!0 === t && (!0 !== n.getTest.call(i, a).match.newBlockMarker || !s.call(i, a, void 0, !0)) || !0 !== t && !s.call(i, a, void 0, !0)); ) a--;
                    return a;
                }, t.translatePosition = c;
                var n = i(4713), a = i(7215);
                function r(e) {
                    var t = this, i = t.maskset;
                    return void 0 !== i.buffer && !0 !== e || (i.buffer = n.getMaskTemplate.call(t, !0, o.call(t), !0), 
                    void 0 === i._buffer && (i._buffer = i.buffer.slice())), i.buffer;
                }
                function o(e, t, i) {
                    var n = this.maskset, a = -1, r = -1, o = i || n.validPositions;
                    void 0 === e && (e = -1);
                    for (var s = 0, l = o.length; s < l; s++) o[s] && (t || !0 !== o[s].generatedInput) && (s <= e && (a = s), 
                    s >= e && (r = s));
                    return -1 === a || a == e ? r : -1 == r || e - a < r - e ? a : r;
                }
                function s(e, t, i) {
                    var a = this, r = this.maskset, o = n.getTestTemplate.call(a, e).match;
                    if ("" === o.def && (o = n.getTest.call(a, e).match), !0 !== o.static) return o.fn;
                    if (!0 === i && void 0 !== r.validPositions[e] && !0 !== r.validPositions[e].generatedInput) return !0;
                    if (!0 !== t && e > -1) {
                        if (i) {
                            var s = n.getTests.call(a, e);
                            return s.length > 1 + ("" === s[s.length - 1].match.def ? 1 : 0);
                        }
                        var l = n.determineTestTemplate.call(a, e, n.getTests.call(a, e)), c = n.getPlaceholder.call(a, e, l.match);
                        return l.match.def !== c;
                    }
                    return !1;
                }
                function l(e, t, i) {
                    var a = this;
                    void 0 === i && (i = !0);
                    for (var r = e + 1; "" !== n.getTest.call(a, r).match.def && (!0 === t && (!0 !== n.getTest.call(a, r).match.newBlockMarker || !s.call(a, r, void 0, !0)) || !0 !== t && !s.call(a, r, void 0, i)); ) r++;
                    return r;
                }
                function c(e) {
                    var t = this.opts, i = this.el;
                    return !this.isRTL || "number" != typeof e || t.greedy && "" === t.placeholder || !i || (e = this._valueGet().length - e) < 0 && (e = 0), 
                    e;
                }
            },
            4713: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.determineTestTemplate = c, t.getDecisionTaker = o, t.getMaskTemplate = function(e, t, i, n, a) {
                    var r = this, o = this.opts, u = this.maskset, f = o.greedy;
                    a && o.greedy && (o.greedy = !1, r.maskset.tests = {});
                    t = t || 0;
                    var p, h, v, m, g = [], y = 0;
                    do {
                        if (!0 === e && u.validPositions[y]) h = (v = a && u.validPositions[y].match.optionality && void 0 === u.validPositions[y + 1] && (!0 === u.validPositions[y].generatedInput || u.validPositions[y].input == o.skipOptionalPartCharacter && y > 0) ? c.call(r, y, d.call(r, y, p, y - 1)) : u.validPositions[y]).match, 
                        p = v.locator.slice(), g.push(!0 === i ? v.input : !1 === i ? h.nativeDef : s.call(r, y, h)); else {
                            h = (v = l.call(r, y, p, y - 1)).match, p = v.locator.slice();
                            var k = !0 !== n && (!1 !== o.jitMasking ? o.jitMasking : h.jit);
                            (m = (m && h.static && h.def !== o.groupSeparator && null === h.fn || u.validPositions[y - 1] && h.static && h.def !== o.groupSeparator && null === h.fn) && u.tests[y]) || !1 === k || void 0 === k || "number" == typeof k && isFinite(k) && k > y ? g.push(!1 === i ? h.nativeDef : s.call(r, g.length, h)) : m = !1;
                        }
                        y++;
                    } while (!0 !== h.static || "" !== h.def || t > y);
                    "" === g[g.length - 1] && g.pop();
                    !1 === i && void 0 !== u.maskLength || (u.maskLength = y - 1);
                    return o.greedy = f, g;
                }, t.getPlaceholder = s, t.getTest = u, t.getTestTemplate = l, t.getTests = d, t.isSubsetOf = f;
                var n, a = (n = i(2394)) && n.__esModule ? n : {
                    default: n
                };
                function r(e, t) {
                    var i = (null != e.alternation ? e.mloc[o(e)] : e.locator).join("");
                    if ("" !== i) for (;i.length < t; ) i += "0";
                    return i;
                }
                function o(e) {
                    var t = e.locator[e.alternation];
                    return "string" == typeof t && t.length > 0 && (t = t.split(",")[0]), void 0 !== t ? t.toString() : "";
                }
                function s(e, t, i) {
                    var n = this.opts, a = this.maskset;
                    if (void 0 !== (t = t || u.call(this, e).match).placeholder || !0 === i) return "function" == typeof t.placeholder ? t.placeholder(n) : t.placeholder;
                    if (!0 === t.static) {
                        if (e > -1 && void 0 === a.validPositions[e]) {
                            var r, o = d.call(this, e), s = [];
                            if (o.length > 1 + ("" === o[o.length - 1].match.def ? 1 : 0)) for (var l = 0; l < o.length; l++) if ("" !== o[l].match.def && !0 !== o[l].match.optionality && !0 !== o[l].match.optionalQuantifier && (!0 === o[l].match.static || void 0 === r || !1 !== o[l].match.fn.test(r.match.def, a, e, !0, n)) && (s.push(o[l]), 
                            !0 === o[l].match.static && (r = o[l]), s.length > 1 && /[0-9a-bA-Z]/.test(s[0].match.def))) return n.placeholder.charAt(e % n.placeholder.length);
                        }
                        return t.def;
                    }
                    return n.placeholder.charAt(e % n.placeholder.length);
                }
                function l(e, t, i) {
                    return this.maskset.validPositions[e] || c.call(this, e, d.call(this, e, t ? t.slice() : t, i));
                }
                function c(e, t) {
                    var i = this.opts, n = 0, a = function(e, t) {
                        var i = 0, n = !1;
                        t.forEach((function(e) {
                            e.match.optionality && (0 !== i && i !== e.match.optionality && (n = !0), (0 === i || i > e.match.optionality) && (i = e.match.optionality));
                        })), i && (0 == e || 1 == t.length ? i = 0 : n || (i = 0));
                        return i;
                    }(e, t);
                    e = e > 0 ? e - 1 : 0;
                    var o, s, l, c = r(u.call(this, e));
                    i.greedy && t.length > 1 && "" === t[t.length - 1].match.def && (n = 1);
                    for (var f = 0; f < t.length - n; f++) {
                        var d = t[f];
                        o = r(d, c.length);
                        var p = Math.abs(o - c);
                        (void 0 === s || "" !== o && p < s || l && !i.greedy && l.match.optionality && l.match.optionality - a > 0 && "master" === l.match.newBlockMarker && (!d.match.optionality || d.match.optionality - a < 1 || !d.match.newBlockMarker) || l && !i.greedy && l.match.optionalQuantifier && !d.match.optionalQuantifier) && (s = p, 
                        l = d);
                    }
                    return l;
                }
                function u(e, t) {
                    var i = this.maskset;
                    return i.validPositions[e] ? i.validPositions[e] : (t || d.call(this, e))[0];
                }
                function f(e, t, i) {
                    function n(e) {
                        for (var t, i = [], n = -1, a = 0, r = e.length; a < r; a++) if ("-" === e.charAt(a)) for (t = e.charCodeAt(a + 1); ++n < t; ) i.push(String.fromCharCode(n)); else n = e.charCodeAt(a), 
                        i.push(e.charAt(a));
                        return i.join("");
                    }
                    return e.match.def === t.match.nativeDef || !(!(i.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && -1 !== n(t.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(n(e.match.fn.toString().replace(/[[\]/]/g, "")));
                }
                function d(e, t, i) {
                    var n, r, o = this, s = this.dependencyLib, l = this.maskset, u = this.opts, d = this.el, p = l.maskToken, h = t ? i : 0, v = t ? t.slice() : [ 0 ], m = [], g = !1, y = t ? t.join("") : "";
                    function k(t, i, r, s) {
                        function c(r, s, p) {
                            function v(e, t) {
                                var i = 0 === t.matches.indexOf(e);
                                return i || t.matches.every((function(n, a) {
                                    return !0 === n.isQuantifier ? i = v(e, t.matches[a - 1]) : Object.prototype.hasOwnProperty.call(n, "matches") && (i = v(e, n)), 
                                    !i;
                                })), i;
                            }
                            function x(e, t, i) {
                                var n, a;
                                if ((l.tests[e] || l.validPositions[e]) && (l.tests[e] || [ l.validPositions[e] ]).every((function(e, r) {
                                    if (e.mloc[t]) return n = e, !1;
                                    var o = void 0 !== i ? i : e.alternation, s = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;
                                    return (void 0 === a || s < a) && -1 !== s && (n = e, a = s), !0;
                                })), n) {
                                    var r = n.locator[n.alternation];
                                    return (n.mloc[t] || n.mloc[r] || n.locator).slice((void 0 !== i ? i : n.alternation) + 1);
                                }
                                return void 0 !== i ? x(e, t) : void 0;
                            }
                            function P(e, t) {
                                var i = e.alternation, n = void 0 === t || i === t.alternation && -1 === e.locator[i].toString().indexOf(t.locator[i]);
                                if (!n && i > t.alternation) for (var a = t.alternation; a < i; a++) if (e.locator[a] !== t.locator[a]) {
                                    i = a, n = !0;
                                    break;
                                }
                                if (n) {
                                    e.mloc = e.mloc || {};
                                    var r = e.locator[i];
                                    if (void 0 !== r) {
                                        if ("string" == typeof r && (r = r.split(",")[0]), void 0 === e.mloc[r] && (e.mloc[r] = e.locator.slice()), 
                                        void 0 !== t) {
                                            for (var o in t.mloc) "string" == typeof o && (o = o.split(",")[0]), void 0 === e.mloc[o] && (e.mloc[o] = t.mloc[o]);
                                            e.locator[i] = Object.keys(e.mloc).join(",");
                                        }
                                        return !0;
                                    }
                                    e.alternation = void 0;
                                }
                                return !1;
                            }
                            function w(e, t) {
                                if (e.locator.length !== t.locator.length) return !1;
                                for (var i = e.alternation + 1; i < e.locator.length; i++) if (e.locator[i] !== t.locator[i]) return !1;
                                return !0;
                            }
                            if (h > e + u._maxTestPos) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + l.mask;
                            if (h === e && void 0 === r.matches) {
                                if (m.push({
                                    match: r,
                                    locator: s.reverse(),
                                    cd: y,
                                    mloc: {}
                                }), !r.optionality || void 0 !== p || !(u.definitions && u.definitions[r.nativeDef] && u.definitions[r.nativeDef].optional || a.default.prototype.definitions[r.nativeDef] && a.default.prototype.definitions[r.nativeDef].optional)) return !0;
                                g = !0, h = e;
                            } else if (void 0 !== r.matches) {
                                if (r.isGroup && p !== r) return function() {
                                    if (r = c(t.matches[t.matches.indexOf(r) + 1], s, p)) return !0;
                                }();
                                if (r.isOptional) return function() {
                                    var t = r, a = m.length;
                                    if (r = k(r, i, s, p), m.length > 0) {
                                        if (m.forEach((function(e, t) {
                                            t >= a && (e.match.optionality = e.match.optionality ? e.match.optionality + 1 : 1);
                                        })), n = m[m.length - 1].match, void 0 !== p || !v(n, t)) return r;
                                        g = !0, h = e;
                                    }
                                }();
                                if (r.isAlternator) return function() {
                                    o.hasAlternator = !0;
                                    var n, a, v, y = r, k = [], b = m.slice(), S = s.length, M = !1, _ = i.length > 0 ? i.shift() : -1;
                                    if (-1 === _ || "string" == typeof _) {
                                        var O, E = h, T = i.slice(), j = [];
                                        if ("string" == typeof _) j = _.split(","); else for (O = 0; O < y.matches.length; O++) j.push(O.toString());
                                        if (void 0 !== l.excludes[e]) {
                                            for (var A = j.slice(), D = 0, B = l.excludes[e].length; D < B; D++) {
                                                var C = l.excludes[e][D].toString().split(":");
                                                s.length == C[1] && j.splice(j.indexOf(C[0]), 1);
                                            }
                                            0 === j.length && (delete l.excludes[e], j = A);
                                        }
                                        (!0 === u.keepStatic || isFinite(parseInt(u.keepStatic)) && E >= u.keepStatic) && (j = j.slice(0, 1));
                                        for (var R = 0; R < j.length; R++) {
                                            O = parseInt(j[R]), m = [], i = "string" == typeof _ && x(h, O, S) || T.slice();
                                            var L = y.matches[O];
                                            if (L && c(L, [ O ].concat(s), p)) r = !0; else if (0 === R && (M = !0), L && L.matches && L.matches.length > y.matches[0].matches.length) break;
                                            n = m.slice(), h = E, m = [];
                                            for (var F = 0; F < n.length; F++) {
                                                var I = n[F], N = !1;
                                                I.match.jit = I.match.jit || M, I.alternation = I.alternation || S, P(I);
                                                for (var V = 0; V < k.length; V++) {
                                                    var G = k[V];
                                                    if ("string" != typeof _ || void 0 !== I.alternation && j.includes(I.locator[I.alternation].toString())) {
                                                        if (I.match.nativeDef === G.match.nativeDef) {
                                                            N = !0, P(G, I);
                                                            break;
                                                        }
                                                        if (f(I, G, u)) {
                                                            P(I, G) && (N = !0, k.splice(k.indexOf(G), 0, I));
                                                            break;
                                                        }
                                                        if (f(G, I, u)) {
                                                            P(G, I);
                                                            break;
                                                        }
                                                        if (v = G, !0 === (a = I).match.static && !0 !== v.match.static && v.match.fn.test(a.match.def, l, e, !1, u, !1)) {
                                                            w(I, G) || void 0 !== d.inputmask.userOptions.keepStatic ? P(I, G) && (N = !0, k.splice(k.indexOf(G), 0, I)) : u.keepStatic = !0;
                                                            break;
                                                        }
                                                    }
                                                }
                                                N || k.push(I);
                                            }
                                        }
                                        m = b.concat(k), h = e, g = m.length > 0, r = k.length > 0, i = T.slice();
                                    } else r = c(y.matches[_] || t.matches[_], [ _ ].concat(s), p);
                                    if (r) return !0;
                                }();
                                if (r.isQuantifier && p !== t.matches[t.matches.indexOf(r) - 1]) return function() {
                                    for (var a = r, o = !1, f = i.length > 0 ? i.shift() : 0; f < (isNaN(a.quantifier.max) ? f + 1 : a.quantifier.max) && h <= e; f++) {
                                        var d = t.matches[t.matches.indexOf(a) - 1];
                                        if (r = c(d, [ f ].concat(s), d)) {
                                            if (m.forEach((function(t, i) {
                                                (n = b(d, t.match) ? t.match : m[m.length - 1].match).optionalQuantifier = f >= a.quantifier.min, 
                                                n.jit = (f + 1) * (d.matches.indexOf(n) + 1) > a.quantifier.jit, n.optionalQuantifier && v(n, d) && (g = !0, 
                                                h = e, u.greedy && null == l.validPositions[e - 1] && f > a.quantifier.min && -1 != [ "*", "+" ].indexOf(a.quantifier.max) && (m.pop(), 
                                                y = void 0), o = !0, r = !1), !o && n.jit && (l.jitOffset[e] = d.matches.length - d.matches.indexOf(n));
                                            })), o) break;
                                            return !0;
                                        }
                                    }
                                }();
                                if (r = k(r, i, s, p)) return !0;
                            } else h++;
                        }
                        for (var p = i.length > 0 ? i.shift() : 0; p < t.matches.length; p++) if (!0 !== t.matches[p].isQuantifier) {
                            var v = c(t.matches[p], [ p ].concat(r), s);
                            if (v && h === e) return v;
                            if (h > e) break;
                        }
                    }
                    function b(e, t) {
                        var i = -1 != e.matches.indexOf(t);
                        return i || e.matches.forEach((function(e, n) {
                            void 0 === e.matches || i || (i = b(e, t));
                        })), i;
                    }
                    if (e > -1) {
                        if (void 0 === t) {
                            for (var x, P = e - 1; void 0 === (x = l.validPositions[P] || l.tests[P]) && P > -1; ) P--;
                            void 0 !== x && P > -1 && (v = function(e, t) {
                                var i, n = [];
                                return Array.isArray(t) || (t = [ t ]), t.length > 0 && (void 0 === t[0].alternation || !0 === u.keepStatic ? 0 === (n = c.call(o, e, t.slice()).locator.slice()).length && (n = t[0].locator.slice()) : t.forEach((function(e) {
                                    "" !== e.def && (0 === n.length ? (i = e.alternation, n = e.locator.slice()) : e.locator[i] && -1 === n[i].toString().indexOf(e.locator[i]) && (n[i] += "," + e.locator[i]));
                                }))), n;
                            }(P, x), y = v.join(""), h = P);
                        }
                        if (l.tests[e] && l.tests[e][0].cd === y) return l.tests[e];
                        for (var w = v.shift(); w < p.length; w++) {
                            if (k(p[w], v, [ w ]) && h === e || h > e) break;
                        }
                    }
                    return (0 === m.length || g) && m.push({
                        match: {
                            fn: null,
                            static: !0,
                            optionality: !1,
                            casing: null,
                            def: "",
                            placeholder: ""
                        },
                        locator: [],
                        mloc: {},
                        cd: y
                    }), void 0 !== t && l.tests[e] ? r = s.extend(!0, [], m) : (l.tests[e] = s.extend(!0, [], m), 
                    r = l.tests[e]), m.forEach((function(e) {
                        e.match.optionality = e.match.defOptionality || !1;
                    })), r;
                }
            },
            7215: function(e, t, i) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.alternate = s, t.checkAlternationMatch = function(e, t, i) {
                    for (var n, a = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== i ? i.split(",") : [], s = 0; s < o.length; s++) -1 !== (n = e.indexOf(o[s])) && e.splice(n, 1);
                    for (var l = 0; l < e.length; l++) if (a.includes(e[l])) {
                        r = !0;
                        break;
                    }
                    return r;
                }, t.handleRemove = function(e, t, i, o, l) {
                    var c = this, u = this.maskset, f = this.opts;
                    if ((f.numericInput || c.isRTL) && (t === a.keys.Backspace ? t = a.keys.Delete : t === a.keys.Delete && (t = a.keys.Backspace), 
                    c.isRTL)) {
                        var d = i.end;
                        i.end = i.begin, i.begin = d;
                    }
                    var p, h = r.getLastValidPosition.call(c, void 0, !0);
                    i.end >= r.getBuffer.call(c).length && h >= i.end && (i.end = h + 1);
                    t === a.keys.Backspace ? i.end - i.begin < 1 && (i.begin = r.seekPrevious.call(c, i.begin)) : t === a.keys.Delete && i.begin === i.end && (i.end = r.isMask.call(c, i.end, !0, !0) ? i.end + 1 : r.seekNext.call(c, i.end) + 1);
                    if (!1 !== (p = v.call(c, i))) {
                        if (!0 !== o && !1 !== f.keepStatic || null !== f.regex && -1 !== n.getTest.call(c, i.begin).match.def.indexOf("|")) {
                            var m = s.call(c, !0);
                            if (m) {
                                var g = void 0 !== m.caret ? m.caret : m.pos ? r.seekNext.call(c, m.pos.begin ? m.pos.begin : m.pos) : r.getLastValidPosition.call(c, -1, !0);
                                (t !== a.keys.Delete || i.begin > g) && i.begin;
                            }
                        }
                        !0 !== o && (u.p = t === a.keys.Delete ? i.begin + p : i.begin, u.p = r.determineNewCaretPosition.call(c, {
                            begin: u.p,
                            end: u.p
                        }, !1, !1 === f.insertMode && t === a.keys.Backspace ? "none" : void 0).begin);
                    }
                }, t.isComplete = c, t.isSelection = u, t.isValid = f, t.refreshFromBuffer = p, 
                t.revalidateMask = v;
                var n = i(4713), a = i(2839), r = i(8711), o = i(6030);
                function s(e, t, i, a, o, l) {
                    var c, u, d, p, h, v, m, g, y, k, b, x = this, P = this.dependencyLib, w = this.opts, S = x.maskset, M = P.extend(!0, [], S.validPositions), _ = P.extend(!0, {}, S.tests), O = !1, E = !1, T = void 0 !== o ? o : r.getLastValidPosition.call(x);
                    if (l && (k = l.begin, b = l.end, l.begin > l.end && (k = l.end, b = l.begin)), 
                    -1 === T && void 0 === o) c = 0, u = (p = n.getTest.call(x, c)).alternation; else for (;T >= 0; T--) if ((d = S.validPositions[T]) && void 0 !== d.alternation) {
                        if (T <= (e || 0) && p && p.locator[d.alternation] !== d.locator[d.alternation]) break;
                        c = T, u = S.validPositions[c].alternation, p = d;
                    }
                    if (void 0 !== u) {
                        m = parseInt(c), S.excludes[m] = S.excludes[m] || [], !0 !== e && S.excludes[m].push((0, 
                        n.getDecisionTaker)(p) + ":" + p.alternation);
                        var j = [], A = -1;
                        for (h = m; h < r.getLastValidPosition.call(x, void 0, !0) + 1; h++) -1 === A && e <= h && void 0 !== t && (j.push(t), 
                        A = j.length - 1), (v = S.validPositions[h]) && !0 !== v.generatedInput && (void 0 === l || h < k || h >= b) && j.push(v.input), 
                        delete S.validPositions[h];
                        for (-1 === A && void 0 !== t && (j.push(t), A = j.length - 1); void 0 !== S.excludes[m] && S.excludes[m].length < 10; ) {
                            for (S.tests = {}, r.resetMaskSet.call(x, !0), O = !0, h = 0; h < j.length && (g = O.caret || r.getLastValidPosition.call(x, void 0, !0) + 1, 
                            y = j[h], O = f.call(x, g, y, !1, a, !0)); h++) h === A && (E = O), 1 == e && O && (E = {
                                caretPos: h
                            });
                            if (O) break;
                            if (r.resetMaskSet.call(x), p = n.getTest.call(x, m), S.validPositions = P.extend(!0, [], M), 
                            S.tests = P.extend(!0, {}, _), !S.excludes[m]) {
                                E = s.call(x, e, t, i, a, m - 1, l);
                                break;
                            }
                            var D = (0, n.getDecisionTaker)(p);
                            if (-1 !== S.excludes[m].indexOf(D + ":" + p.alternation)) {
                                E = s.call(x, e, t, i, a, m - 1, l);
                                break;
                            }
                            for (S.excludes[m].push(D + ":" + p.alternation), h = m; h < r.getLastValidPosition.call(x, void 0, !0) + 1; h++) delete S.validPositions[h];
                        }
                    }
                    return E && !1 === w.keepStatic || delete S.excludes[m], E;
                }
                function l(e, t, i) {
                    var n = this.opts, r = this.maskset;
                    switch (n.casing || t.casing) {
                      case "upper":
                        e = e.toUpperCase();
                        break;

                      case "lower":
                        e = e.toLowerCase();
                        break;

                      case "title":
                        var o = r.validPositions[i - 1];
                        e = 0 === i || o && o.input === String.fromCharCode(a.keyCode.Space) ? e.toUpperCase() : e.toLowerCase();
                        break;

                      default:
                        if ("function" == typeof n.casing) {
                            var s = Array.prototype.slice.call(arguments);
                            s.push(r.validPositions), e = n.casing.apply(this, s);
                        }
                    }
                    return e;
                }
                function c(e) {
                    var t = this, i = this.opts, a = this.maskset;
                    if ("function" == typeof i.isComplete) return i.isComplete(e, i);
                    if ("*" !== i.repeat) {
                        var o = !1, s = r.determineLastRequiredPosition.call(t, !0), l = r.seekPrevious.call(t, s.l);
                        if (void 0 === s.def || s.def.newBlockMarker || s.def.optionality || s.def.optionalQuantifier) {
                            o = !0;
                            for (var c = 0; c <= l; c++) {
                                var u = n.getTestTemplate.call(t, c).match;
                                if (!0 !== u.static && void 0 === a.validPositions[c] && !0 !== u.optionality && !0 !== u.optionalQuantifier || !0 === u.static && e[c] !== n.getPlaceholder.call(t, c, u)) {
                                    o = !1;
                                    break;
                                }
                            }
                        }
                        return o;
                    }
                }
                function u(e) {
                    var t = this.opts.insertMode ? 0 : 1;
                    return this.isRTL ? e.begin - e.end > t : e.end - e.begin > t;
                }
                function f(e, t, i, a, o, d, m) {
                    var g = this, y = this.dependencyLib, k = this.opts, b = g.maskset;
                    i = !0 === i;
                    var x = e;
                    function P(e) {
                        if (void 0 !== e) {
                            if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [ e.remove ]), 
                            e.remove.sort((function(e, t) {
                                return g.isRTL ? e.pos - t.pos : t.pos - e.pos;
                            })).forEach((function(e) {
                                v.call(g, {
                                    begin: e,
                                    end: e + 1
                                });
                            })), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [ e.insert ]), 
                            e.insert.sort((function(e, t) {
                                return g.isRTL ? t.pos - e.pos : e.pos - t.pos;
                            })).forEach((function(e) {
                                "" !== e.c && f.call(g, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : a);
                            })), e.insert = void 0), e.refreshFromBuffer && e.buffer) {
                                var t = e.refreshFromBuffer;
                                p.call(g, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;
                            }
                            void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);
                        }
                        return e;
                    }
                    function w(t, i, o) {
                        var s = !1;
                        return n.getTests.call(g, t).every((function(c, f) {
                            var d = c.match;
                            if (r.getBuffer.call(g, !0), !1 !== (s = (!d.jit || void 0 !== b.validPositions[r.seekPrevious.call(g, t)]) && (null != d.fn ? d.fn.test(i, b, t, o, k, u.call(g, e)) : (i === d.def || i === k.skipOptionalPartCharacter) && "" !== d.def && {
                                c: n.getPlaceholder.call(g, t, d, !0) || d.def,
                                pos: t
                            }))) {
                                var p = void 0 !== s.c ? s.c : i, h = t;
                                return p = p === k.skipOptionalPartCharacter && !0 === d.static ? n.getPlaceholder.call(g, t, d, !0) || d.def : p, 
                                !0 !== (s = P(s)) && void 0 !== s.pos && s.pos !== t && (h = s.pos), !0 !== s && void 0 === s.pos && void 0 === s.c ? !1 : (!1 === v.call(g, e, y.extend({}, c, {
                                    input: l.call(g, p, d, h)
                                }), a, h) && (s = !1), !1);
                            }
                            return !0;
                        })), s;
                    }
                    void 0 !== e.begin && (x = g.isRTL ? e.end : e.begin);
                    var S = !0, M = y.extend(!0, {}, b.validPositions);
                    if (!1 === k.keepStatic && void 0 !== b.excludes[x] && !0 !== o && !0 !== a) for (var _ = x; _ < (g.isRTL ? e.begin : e.end); _++) void 0 !== b.excludes[_] && (b.excludes[_] = void 0, 
                    delete b.tests[_]);
                    if ("function" == typeof k.preValidation && !0 !== a && !0 !== d && (S = P(S = k.preValidation.call(g, r.getBuffer.call(g), x, t, u.call(g, e), k, b, e, i || o))), 
                    !0 === S) {
                        if (S = w(x, t, i), (!i || !0 === a) && !1 === S && !0 !== d) {
                            var O = b.validPositions[x];
                            if (!O || !0 !== O.match.static || O.match.def !== t && t !== k.skipOptionalPartCharacter) {
                                if (k.insertMode || void 0 === b.validPositions[r.seekNext.call(g, x)] || e.end > x) {
                                    var E = !1;
                                    if (b.jitOffset[x] && void 0 === b.validPositions[r.seekNext.call(g, x)] && !1 !== (S = f.call(g, x + b.jitOffset[x], t, !0, !0)) && (!0 !== o && (S.caret = x), 
                                    E = !0), e.end > x && (b.validPositions[x] = void 0), !E && !r.isMask.call(g, x, k.keepStatic && 0 === x)) for (var T = x + 1, j = r.seekNext.call(g, x, !1, 0 !== x); T <= j; T++) if (!1 !== (S = w(T, t, i))) {
                                        S = h.call(g, x, void 0 !== S.pos ? S.pos : T) || S, x = T;
                                        break;
                                    }
                                }
                            } else S = {
                                caret: r.seekNext.call(g, x)
                            };
                        }
                        g.hasAlternator && !0 !== o && !i && (!1 === S && k.keepStatic && (c.call(g, r.getBuffer.call(g)) || 0 === x) ? S = s.call(g, x, t, i, a, void 0, e) : (u.call(g, e) && b.tests[x] && b.tests[x].length > 1 && k.keepStatic || 1 == S && !0 !== k.numericInput && b.tests[x] && b.tests[x].length > 1 && r.getLastValidPosition.call(g, void 0, !0) > x) && (S = s.call(g, !0))), 
                        !0 === S && (S = {
                            pos: x
                        });
                    }
                    if ("function" == typeof k.postValidation && !0 !== a && !0 !== d) {
                        var A = k.postValidation.call(g, r.getBuffer.call(g, !0), void 0 !== e.begin ? g.isRTL ? e.end : e.begin : e, t, S, k, b, i, m);
                        void 0 !== A && (S = !0 === A ? S : A);
                    }
                    S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === d ? (r.resetMaskSet.call(g, !0), 
                    b.validPositions = y.extend(!0, [], M)) : h.call(g, void 0, x, !0);
                    var D = P(S);
                    void 0 !== g.maxLength && (r.getBuffer.call(g).length > g.maxLength && !a && (r.resetMaskSet.call(g, !0), 
                    b.validPositions = y.extend(!0, [], M), D = !1));
                    return D;
                }
                function d(e, t, i) {
                    for (var a = this.maskset, r = !1, o = n.getTests.call(this, e), s = 0; s < o.length; s++) {
                        if (o[s].match && (o[s].match.nativeDef === t.match[i.shiftPositions ? "def" : "nativeDef"] && (!i.shiftPositions || !t.match.static) || o[s].match.nativeDef === t.match.nativeDef || i.regex && !o[s].match.static && o[s].match.fn.test(t.input, a, e, !1, i))) {
                            r = !0;
                            break;
                        }
                        if (o[s].match && o[s].match.def === t.match.nativeDef) {
                            r = void 0;
                            break;
                        }
                    }
                    return !1 === r && void 0 !== a.jitOffset[e] && (r = d.call(this, e + a.jitOffset[e], t, i)), 
                    r;
                }
                function p(e, t, i) {
                    var n, a, s = this, l = this.maskset, c = this.opts, u = this.dependencyLib, f = c.skipOptionalPartCharacter, d = s.isRTL ? i.slice().reverse() : i;
                    if (c.skipOptionalPartCharacter = "", !0 === e) r.resetMaskSet.call(s), l.tests = {}, 
                    e = 0, t = i.length, a = r.determineNewCaretPosition.call(s, {
                        begin: 0,
                        end: 0
                    }, !1).begin; else {
                        for (n = e; n < t; n++) delete l.validPositions[n];
                        a = e;
                    }
                    var p = new u.Event("keypress");
                    for (n = e; n < t; n++) {
                        p.key = d[n].toString(), s.ignorable = !1;
                        var h = o.EventHandlers.keypressEvent.call(s, p, !0, !1, !1, a);
                        !1 !== h && void 0 !== h && (a = h.forwardPosition);
                    }
                    c.skipOptionalPartCharacter = f;
                }
                function h(e, t, i) {
                    var a = this, o = this.maskset, s = this.dependencyLib;
                    if (void 0 === e) for (e = t - 1; e > 0 && !o.validPositions[e]; e--) ;
                    for (var l = e; l < t; l++) {
                        if (void 0 === o.validPositions[l] && !r.isMask.call(a, l, !1)) if (0 == l ? n.getTest.call(a, l) : o.validPositions[l - 1]) {
                            var c = n.getTests.call(a, l).slice();
                            "" === c[c.length - 1].match.def && c.pop();
                            var u, d = n.determineTestTemplate.call(a, l, c);
                            if (d && (!0 !== d.match.jit || "master" === d.match.newBlockMarker && (u = o.validPositions[l + 1]) && !0 === u.match.optionalQuantifier) && ((d = s.extend({}, d, {
                                input: n.getPlaceholder.call(a, l, d.match, !0) || d.match.def
                            })).generatedInput = !0, v.call(a, l, d, !0), !0 !== i)) {
                                var p = o.validPositions[t].input;
                                return o.validPositions[t] = void 0, f.call(a, t, p, !0, !0);
                            }
                        }
                    }
                }
                function v(e, t, i, a) {
                    var o = this, s = this.maskset, l = this.opts, c = this.dependencyLib;
                    function u(e, t, i) {
                        var n = t[e];
                        if (void 0 !== n && !0 === n.match.static && !0 !== n.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {
                            var a = i.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1], r = i.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];
                            return a && r;
                        }
                        return !1;
                    }
                    var p = 0, h = void 0 !== e.begin ? e.begin : e, v = void 0 !== e.end ? e.end : e, m = !0;
                    if (e.begin > e.end && (h = e.end, v = e.begin), a = void 0 !== a ? a : h, void 0 === i && (h !== v || l.insertMode && void 0 !== s.validPositions[a] || void 0 === t || t.match.optionalQuantifier || t.match.optionality)) {
                        var g, y = c.extend(!0, {}, s.validPositions), k = r.getLastValidPosition.call(o, void 0, !0);
                        for (s.p = h, g = k; g >= h; g--) delete s.validPositions[g], void 0 === t && delete s.tests[g + 1];
                        var b, x, P = a, w = P;
                        for (t && (s.validPositions[a] = c.extend(!0, {}, t), w++, P++), g = t ? v : v - 1; g <= k; g++) {
                            if (void 0 !== (b = y[g]) && !0 !== b.generatedInput && (g >= v || g >= h && u(g, y, {
                                begin: h,
                                end: v
                            }))) {
                                for (;"" !== n.getTest.call(o, w).match.def; ) {
                                    if (!1 !== (x = d.call(o, w, b, l)) || "+" === b.match.def) {
                                        "+" === b.match.def && r.getBuffer.call(o, !0);
                                        var S = f.call(o, w, b.input, "+" !== b.match.def, !0);
                                        if (m = !1 !== S, P = (S.pos || w) + 1, !m && x) break;
                                    } else m = !1;
                                    if (m) {
                                        void 0 === t && b.match.static && g === e.begin && p++;
                                        break;
                                    }
                                    if (!m && r.getBuffer.call(o), w > s.maskLength) break;
                                    w++;
                                }
                                "" == n.getTest.call(o, w).match.def && (m = !1), w = P;
                            }
                            if (!m) break;
                        }
                        if (!m) return s.validPositions = c.extend(!0, [], y), r.resetMaskSet.call(o, !0), 
                        !1;
                    } else t && n.getTest.call(o, a).match.cd === t.match.cd && (s.validPositions[a] = c.extend(!0, {}, t));
                    return r.resetMaskSet.call(o, !0), p;
                }
            }
        }, t = {};
        function i(n) {
            var a = t[n];
            if (void 0 !== a) return a.exports;
            var r = t[n] = {
                exports: {}
            };
            return e[n](r, r.exports, i), r.exports;
        }
        var n = {};
        return function() {
            var e, t = n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0, i(7149), i(3194), i(9302), i(4013), i(3851), i(219), i(207), 
            i(5296);
            var a = ((e = i(2394)) && e.__esModule ? e : {
                default: e
            }).default;
            t.default = a;
        }(), n;
    }();
}));

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = __webpack_require__(/*! ./lib/has */ "./node_modules/prop-types/lib/has.js");

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/prop-types/node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var has = __webpack_require__(/*! ./lib/has */ "./node_modules/prop-types/lib/has.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/prop-types/node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module) {

module.exports = Function.call.bind(Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/prop-types/node_modules/react-is/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/prop-types/node_modules/react-is/index.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/property-expr/index.js":
/*!*********************************************!*\
  !*** ./node_modules/property-expr/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";
/**
 * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
 */


function Cache(maxSize) {
  this._maxSize = maxSize
  this.clear()
}
Cache.prototype.clear = function () {
  this._size = 0
  this._values = Object.create(null)
}
Cache.prototype.get = function (key) {
  return this._values[key]
}
Cache.prototype.set = function (key, value) {
  this._size >= this._maxSize && this.clear()
  if (!(key in this._values)) this._size++

  return (this._values[key] = value)
}

var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
  DIGIT_REGEX = /^\d+$/,
  LEAD_DIGIT_REGEX = /^\d/,
  SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
  CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
  MAX_CACHE_SIZE = 512

var pathCache = new Cache(MAX_CACHE_SIZE),
  setCache = new Cache(MAX_CACHE_SIZE),
  getCache = new Cache(MAX_CACHE_SIZE)

var config

module.exports = {
  Cache: Cache,

  split: split,

  normalizePath: normalizePath,

  setter: function (path) {
    var parts = normalizePath(path)

    return (
      setCache.get(path) ||
      setCache.set(path, function setter(obj, value) {
        var index = 0
        var len = parts.length
        var data = obj

        while (index < len - 1) {
          var part = parts[index]
          if (
            part === '__proto__' ||
            part === 'constructor' ||
            part === 'prototype'
          ) {
            return obj
          }

          data = data[parts[index++]]
        }
        data[parts[index]] = value
      })
    )
  },

  getter: function (path, safe) {
    var parts = normalizePath(path)
    return (
      getCache.get(path) ||
      getCache.set(path, function getter(data) {
        var index = 0,
          len = parts.length
        while (index < len) {
          if (data != null || !safe) data = data[parts[index++]]
          else return
        }
        return data
      })
    )
  },

  join: function (segments) {
    return segments.reduce(function (path, part) {
      return (
        path +
        (isQuoted(part) || DIGIT_REGEX.test(part)
          ? '[' + part + ']'
          : (path ? '.' : '') + part)
      )
    }, '')
  },

  forEach: function (path, cb, thisArg) {
    forEach(Array.isArray(path) ? path : split(path), cb, thisArg)
  },
}

function normalizePath(path) {
  return (
    pathCache.get(path) ||
    pathCache.set(
      path,
      split(path).map(function (part) {
        return part.replace(CLEAN_QUOTES_REGEX, '$2')
      })
    )
  )
}

function split(path) {
  return path.match(SPLIT_REGEX) || ['']
}

function forEach(parts, iter, thisArg) {
  var len = parts.length,
    part,
    idx,
    isArray,
    isBracket

  for (idx = 0; idx < len; idx++) {
    part = parts[idx]

    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"'
      }

      isBracket = isQuoted(part)
      isArray = !isBracket && /^\d+$/.test(part)

      iter.call(thisArg, part, isBracket, isArray, idx, parts)
    }
  }
}

function isQuoted(str) {
  return (
    typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1
  )
}

function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)
}

function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part)
}

function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "react");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var displayName = outerType.displayName;

  if (displayName) {
    return displayName;
  }

  var functionName = innerType.displayName || innerType.name || '';
  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber


function getContextName(type) {
  return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


function getComponentNameFromType(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        var outerName = type.displayName || null;

        if (outerName !== null) {
          return outerName;
        }

        return getComponentNameFromType(type.type) || 'Memo';

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentNameFromType(init(payload));
          } catch (x) {
            return null;
          }
        }

      // eslint-disable-next-line no-fallthrough
    }
  }

  return null;
}

var assign = Object.assign;

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if ( !fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                // but we have a user-provided "displayName"
                // splice it in to make the stack more readable.


                if (fn.displayName && _frame.includes('<anonymous>')) {
                  _frame = _frame.replace('<anonymous>', fn.displayName);
                }

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            // eslint-disable-next-line react-internal/prod-error-codes
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */
// $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value) {
  {
    // toStringTag is needed for namespaced types like Temporal.Instant
    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
    return type;
  }
} // $FlowFixMe only called in DEV, so void return is not possible.


function willCoercionThrow(value) {
  {
    try {
      testStringCoercion(value);
      return false;
    } catch (e) {
      return true;
    }
  }
}

function testStringCoercion(value) {
  // If you ended up here by following an exception call stack, here's what's
  // happened: you supplied an object or symbol value to React (as a prop, key,
  // DOM attribute, CSS property, string ref, etc.) and when React tried to
  // coerce it to a string using `'' + value`, an exception was thrown.
  //
  // The most common types that will cause this exception are `Symbol` instances
  // and Temporal objects like `Temporal.Instant`. But any object that has a
  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
  // exception. (Library authors do this to prevent users from using built-in
  // numeric operators like `+` or comparison operators like `>=` because custom
  // methods are needed to perform accurate arithmetic or comparison.)
  //
  // To fix the problem, coerce this object or symbol value to a string before
  // passing it to React. The most reliable way is usually `String(value)`.
  //
  // To find which value is throwing, check the browser or debugger console.
  // Before this exception was thrown, there should be `console.error` output
  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
  // problem and how that type was used: key, atrribute, input value prop, etc.
  // In most cases, this console output also shows the component and its
  // ancestor components where the exception happened.
  //
  // eslint-disable-next-line react-internal/safe-string-coercion
  return '' + value;
}
function checkKeyStringCoercion(value) {
  {
    if (willCoercionThrow(value)) {
      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      {
        checkKeyStringCoercion(maybeKey);
      }

      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */


function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentNameFromType(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentNameFromType(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, true);
  }
}
function jsxWithValidationDynamic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, false);
  }
}

var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
// for now we can ship identical prod functions

var jsxs =  jsxWithValidationStatic ;

exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsx;
exports.jsxs = jsxs;
  })();
}


/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/tiny-case/index.js":
/*!*****************************************!*\
  !*** ./node_modules/tiny-case/index.js ***!
  \*****************************************/
/***/ (function(module) {

const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g

const words = (str) => str.match(reWords) || []

const upperFirst = (str) => str[0].toUpperCase() + str.slice(1)

const join = (str, d) => words(str).join(d).toLowerCase()

const camelCase = (str) =>
  words(str).reduce(
    (acc, next) =>
      `${acc}${
        !acc
          ? next.toLowerCase()
          : next[0].toUpperCase() + next.slice(1).toLowerCase()
      }`,
    '',
  )

const pascalCase = (str) => upperFirst(camelCase(str))

const snakeCase = (str) => join(str, '_')

const kebabCase = (str) => join(str, '-')

const sentenceCase = (str) => upperFirst(join(str, ' '))

const titleCase = (str) => words(str).map(upperFirst).join(' ')

module.exports = {
  words,
  upperFirst,
  camelCase,
  pascalCase,
  snakeCase,
  kebabCase,
  sentenceCase,
  titleCase,
}


/***/ }),

/***/ "./node_modules/toposort/index.js":
/*!****************************************!*\
  !*** ./node_modules/toposort/index.js ***!
  \****************************************/
/***/ (function(module) {


/**
 * Topological sorting function
 *
 * @param {Array} edges
 * @returns {Array}
 */

module.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges)
}

module.exports.array = toposort

function toposort(nodes, edges) {
  var cursor = nodes.length
    , sorted = new Array(cursor)
    , visited = {}
    , i = cursor
    // Better data structures make algorithm much faster.
    , outgoingEdges = makeOutgoingEdges(edges)
    , nodesHash = makeNodesHash(nodes)

  // check for unknown nodes
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error('Unknown node. There is an unknown node in the supplied edges.')
    }
  })

  while (i--) {
    if (!visited[i]) visit(nodes[i], i, new Set())
  }

  return sorted

  function visit(node, i, predecessors) {
    if(predecessors.has(node)) {
      var nodeRep
      try {
        nodeRep = ", node was:" + JSON.stringify(node)
      } catch(e) {
        nodeRep = ""
      }
      throw new Error('Cyclic dependency' + nodeRep)
    }

    if (!nodesHash.has(node)) {
      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
    }

    if (visited[i]) return;
    visited[i] = true

    var outgoing = outgoingEdges.get(node) || new Set()
    outgoing = Array.from(outgoing)

    if (i = outgoing.length) {
      predecessors.add(node)
      do {
        var child = outgoing[--i]
        visit(child, nodesHash.get(child), predecessors)
      } while (i)
      predecessors.delete(node)
    }

    sorted[--cursor] = node
  }
}

function uniqueNodes(arr){
  var res = new Set()
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    res.add(edge[0])
    res.add(edge[1])
  }
  return Array.from(res)
}

function makeOutgoingEdges(arr){
  var edges = new Map()
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    if (!edges.has(edge[0])) edges.set(edge[0], new Set())
    if (!edges.has(edge[1])) edges.set(edge[1], new Set())
    edges.get(edge[0]).add(edge[1])
  }
  return edges
}

function makeNodesHash(arr){
  var res = new Map()
  for (var i = 0, len = arr.length; i < len; i++) {
    res.set(arr[i], i)
  }
  return res
}


/***/ }),

/***/ "./node_modules/yup/index.esm.js":
/*!***************************************!*\
  !*** ./node_modules/yup/index.esm.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArraySchema: function() { return /* binding */ ArraySchema; },
/* harmony export */   BooleanSchema: function() { return /* binding */ BooleanSchema; },
/* harmony export */   DateSchema: function() { return /* binding */ DateSchema; },
/* harmony export */   MixedSchema: function() { return /* binding */ MixedSchema; },
/* harmony export */   NumberSchema: function() { return /* binding */ NumberSchema; },
/* harmony export */   ObjectSchema: function() { return /* binding */ ObjectSchema; },
/* harmony export */   Schema: function() { return /* binding */ Schema; },
/* harmony export */   StringSchema: function() { return /* binding */ StringSchema; },
/* harmony export */   TupleSchema: function() { return /* binding */ TupleSchema; },
/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },
/* harmony export */   addMethod: function() { return /* binding */ addMethod; },
/* harmony export */   array: function() { return /* binding */ create$2; },
/* harmony export */   bool: function() { return /* binding */ create$7; },
/* harmony export */   boolean: function() { return /* binding */ create$7; },
/* harmony export */   date: function() { return /* binding */ create$4; },
/* harmony export */   defaultLocale: function() { return /* binding */ locale; },
/* harmony export */   getIn: function() { return /* binding */ getIn; },
/* harmony export */   isSchema: function() { return /* binding */ isSchema; },
/* harmony export */   lazy: function() { return /* binding */ create; },
/* harmony export */   mixed: function() { return /* binding */ create$8; },
/* harmony export */   number: function() { return /* binding */ create$5; },
/* harmony export */   object: function() { return /* binding */ create$3; },
/* harmony export */   printValue: function() { return /* binding */ printValue; },
/* harmony export */   reach: function() { return /* binding */ reach; },
/* harmony export */   ref: function() { return /* binding */ create$9; },
/* harmony export */   setLocale: function() { return /* binding */ setLocale; },
/* harmony export */   string: function() { return /* binding */ create$6; },
/* harmony export */   tuple: function() { return /* binding */ create$1; }
/* harmony export */ });
/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-expr */ "./node_modules/property-expr/index.js");
/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-case */ "./node_modules/tiny-case/index.js");
/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toposort */ "./node_modules/toposort/index.js");
/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);




const toString = Object.prototype.toString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val) return 'NaN';
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? '-0' : '' + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false) return '' + val;
  const typeOf = typeof val;
  if (typeOf === 'number') return printNumber(val);
  if (typeOf === 'string') return quoteStrings ? `"${val}"` : val;
  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  const tag = toString.call(val).slice(8, -1);
  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
  if (tag === 'RegExp') return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function (key, value) {
    let result = printSimpleValue(this[key], quoteStrings);
    if (result !== null) return result;
    return value;
  }, 2);
}

function toArray(value) {
  return value == null ? [] : [].concat(value);
}

let _Symbol$toStringTag;
let strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;
class ValidationError extends Error {
  static formatError(message, params) {
    const path = params.label || params.path || 'this';
    if (path !== params.path) params = Object.assign({}, params, {
      path
    });
    if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));
    if (typeof message === 'function') return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === 'ValidationError';
  }
  constructor(errorOrErrors, value, field, type, disableStack) {
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.errors = void 0;
    this.params = void 0;
    this.inner = void 0;
    this[_Symbol$toStringTag] = 'Error';
    this.name = 'ValidationError';
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray(errorOrErrors).forEach(err => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        const innerErrors = err.inner.length ? err.inner : [err];
        this.inner.push(...innerErrors);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (!disableStack && Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);
  }
}

let mixed = {
  default: '${path} is invalid',
  required: '${path} is a required field',
  defined: '${path} must be defined',
  notNull: '${path} cannot be null',
  oneOf: '${path} must be one of the following values: ${values}',
  notOneOf: '${path} must not be one of the following values: ${values}',
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : '.';
    return type !== 'mixed' ? `${path} must be a \`${type}\` type, ` + `but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \`${printValue(value, true)}\`` + castMsg;
  }
};
let string = {
  length: '${path} must be exactly ${length} characters',
  min: '${path} must be at least ${min} characters',
  max: '${path} must be at most ${max} characters',
  matches: '${path} must match the following: "${regex}"',
  email: '${path} must be a valid email',
  url: '${path} must be a valid URL',
  uuid: '${path} must be a valid UUID',
  trim: '${path} must be a trimmed string',
  lowercase: '${path} must be a lowercase string',
  uppercase: '${path} must be a upper case string'
};
let number = {
  min: '${path} must be greater than or equal to ${min}',
  max: '${path} must be less than or equal to ${max}',
  lessThan: '${path} must be less than ${less}',
  moreThan: '${path} must be greater than ${more}',
  positive: '${path} must be a positive number',
  negative: '${path} must be a negative number',
  integer: '${path} must be an integer'
};
let date = {
  min: '${path} field must be later than ${min}',
  max: '${path} field must be at earlier than ${max}'
};
let boolean = {
  isValue: '${path} field must be ${value}'
};
let object = {
  noUnknown: '${path} field has unspecified keys: ${unknown}'
};
let array = {
  min: '${path} field must have at least ${min} items',
  max: '${path} field must have less than or equal to ${max} items',
  length: '${path} must have ${length} items'
};
let tuple = {
  notType: params => {
    const {
      path,
      value,
      spec
    } = params;
    const typeLen = spec.types.length;
    if (Array.isArray(value)) {
      if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
      if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
    }
    return ValidationError.formatError(mixed.notType, params);
  }
};
var locale = Object.assign(Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean,
  tuple
});

const isSchema = obj => obj && obj.__isYupSchema__;

class Condition {
  static fromOptions(refs, config) {
    if (!config.then && !config.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
    let {
      is,
      then,
      otherwise
    } = config;
    let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);
    return new Condition(refs, (values, schema) => {
      var _branch;
      let branch = check(...values) ? then : otherwise;
      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values = this.refs.map(ref =>
    // TODO: ? operator here?
    ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
    let schema = this.fn(values, base, options);
    if (schema === undefined ||
    // @ts-ignore this can be base
    schema === base) {
      return base;
    }
    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');
    return schema.resolve(options);
  }
}

const prefixes = {
  context: '$',
  value: '.'
};
function create$9(key, options) {
  return new Reference(key, options);
}
class Reference {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
    this.key = key.trim();
    if (key === '') throw new TypeError('ref must be a non-empty string');
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  }

  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: 'ref',
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
}

// @ts-ignore
Reference.prototype.__isYupRef = true;

const isAbsent = value => value == null;

function createValidation(config) {
  function validate({
    value,
    path = '',
    options,
    originalValue,
    schema
  }, panic, next) {
    const {
      name,
      test,
      params,
      message,
      skipAbsent
    } = config;
    let {
      parent,
      context,
      abortEarly = schema.spec.abortEarly,
      disableStackTrace = schema.spec.disableStackTrace
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      var _overrides$disableSta;
      const nextParams = Object.assign({
        value,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path,
        spec: schema.spec
      }, params, overrides.params);
      for (const key of Object.keys(nextParams)) nextParams[key] = resolve(nextParams[key]);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, (_overrides$disableSta = overrides.disableStackTrace) != null ? _overrides$disableSta : disableStackTrace);
      error.params = nextParams;
      return error;
    }
    const invalid = abortEarly ? panic : next;
    let ctx = {
      path,
      parent,
      type: name,
      from: options.from,
      createError,
      resolve,
      options,
      originalValue,
      schema
    };
    const handleResult = validOrError => {
      if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);
    };
    const handleError = err => {
      if (ValidationError.isError(err)) invalid(err);else panic(err);
    };
    const shouldSkip = skipAbsent && isAbsent(value);
    if (shouldSkip) {
      return handleResult(true);
    }
    let result;
    try {
      var _result;
      result = test.call(ctx, value, ctx);
      if (typeof ((_result = result) == null ? void 0 : _result.then) === 'function') {
        if (options.sync) {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);
        }
        return Promise.resolve(result).then(handleResult, handleError);
      }
    } catch (err) {
      handleError(err);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config;
  return validate;
}

function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;

  // root path: ''
  if (!path) return {
    parent,
    parentPath: path,
    schema
  };
  (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    let isTuple = schema.type === 'tuple';
    let idx = isArray ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }

    // sometimes the array index part of a path doesn't exist: "nested.arr.child"
    // in these cases the current part is the next schema and should be processed
    // in this iteration. For cases where the index signature is included this
    // check will fail and we'll handle the `child` part on the next iteration like normal
    if (!isArray) {
      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
function reach(obj, path, value, context) {
  return getIn(obj, path, value, context).schema;
}

class ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve(item));
    }
    return result;
  }
  clone() {
    return new ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.forEach(value => next.add(value));
    removeItems.forEach(value => next.delete(value));
    return next;
  }
}

// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js
function clone(src, seen = new Map()) {
  if (isSchema(src) || !src || typeof src !== 'object') return src;
  if (seen.has(src)) return seen.get(src);
  let copy;
  if (src instanceof Date) {
    // Date
    copy = new Date(src.getTime());
    seen.set(src, copy);
  } else if (src instanceof RegExp) {
    // RegExp
    copy = new RegExp(src);
    seen.set(src, copy);
  } else if (Array.isArray(src)) {
    // Array
    copy = new Array(src.length);
    seen.set(src, copy);
    for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);
  } else if (src instanceof Map) {
    // Map
    copy = new Map();
    seen.set(src, copy);
    for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));
  } else if (src instanceof Set) {
    // Set
    copy = new Set();
    seen.set(src, copy);
    for (const v of src) copy.add(clone(v, seen));
  } else if (src instanceof Object) {
    // Object
    copy = {};
    seen.set(src, copy);
    for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);
  } else {
    throw Error(`Unable to clone ${src}`);
  }
  return copy;
}

// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a
// loose Record definition allowing free form usage.
class Schema {
  constructor(options) {
    this.type = void 0;
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this.internalTests = {};
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = Object.create(null);
    this._typeCheck = void 0;
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      disableStackTrace: false,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? void 0 : options.spec);
    this.withMutation(s => {
      s.nonNullable();
    });
  }

  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec) Object.assign(this.spec, spec);
      return this;
    }

    // if the nested value is a schema we can skip cloning, since
    // they are already immutable
    const next = Object.create(Object.getPrototypeOf(this));

    // @ts-expect-error this is readonly
    next.type = this.type;
    next._typeCheck = this._typeCheck;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.internalTests = Object.assign({}, this.internalTests);
    next.exclusiveTests = Object.assign({}, this.exclusiveTests);

    // @ts-expect-error this is readonly
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone(Object.assign({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  withMutation(fn) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this) return this;
    if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);

    // manually merge the blacklist/whitelist (the other `schema` takes
    // precedence in case of conflicts)
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);

    // start with the current tests
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;

    // manually add the new tests to ensure
    // the deduping logic is consistent
    combined.withMutation(next => {
      schema.tests.forEach(fn => {
        next.test(fn.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v) {
    if (v == null) {
      if (this.spec.nullable && v === null) return true;
      if (this.spec.optional && v === undefined) return true;
      return false;
    }
    return this._typeCheck(v);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
    });
  }

  /**
   * Run the configured transform pipeline over an input value.
   */

  cast(value, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value
    }, options));
    let allowOptionality = options.assert === 'ignore-optionality';
    let result = resolvedSchema._cast(value, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: "${resolvedSchema.type}". \n\n` + `attempted value: ${formattedValue} \n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
    if (value === undefined) {
      value = this.getDefault(options);
    }
    return value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      path,
      originalValue = _value,
      strict = this.spec.strict
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test of Object.values(this.internalTests)) {
      if (test) initialTests.push(test);
    }
    this.runTests({
      path,
      value,
      originalValue,
      options,
      tests: initialTests
    }, panic, initialErrors => {
      // even if we aren't ending early we can't proceed further if the types aren't correct
      if (initialErrors.length) {
        return next(initialErrors, value);
      }
      this.runTests({
        path,
        value,
        originalValue,
        options,
        tests: this.tests
      }, panic, next);
    });
  }

  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(runOptions, panic, next) {
    let fired = false;
    let {
      tests,
      value,
      originalValue,
      path,
      options
    } = runOptions;
    let panicOnce = arg => {
      if (fired) return;
      fired = true;
      panic(arg, value);
    };
    let nextOnce = arg => {
      if (fired) return;
      fired = true;
      next(arg, value);
    };
    let count = tests.length;
    let nestedErrors = [];
    if (!count) return nextOnce([]);
    let args = {
      value,
      originalValue,
      path,
      options,
      schema: this
    };
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      test(args, panicOnce, function finishTestRun(err) {
        if (err) {
          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
        }
        if (--count <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k = key != null ? key : index;
    if (k == null) {
      throw TypeError('Must include `key` or `index` for nested validations');
    }
    const isIndex = typeof k === 'number';
    let value = parent[k];
    const testOptions = Object.assign({}, options, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: true,
      parent,
      value,
      originalValue: originalParent[k],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: undefined,
      // index: undefined,
      [isIndex ? 'index' : 'key']: k,
      path: isIndex || k.includes('.') ? `${parentPath || ''}[${value ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : '') + key
    });
    return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
  }
  validate(value, options) {
    var _options$disableStack2;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
    return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
      if (ValidationError.isError(error)) error.value = parsed;
      reject(error);
    }, (errors, validated) => {
      if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));else resolve(validated);
    }));
  }
  validateSync(value, options) {
    var _options$disableStack3;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let result;
    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
    schema._validate(value, Object.assign({}, options, {
      sync: true
    }), (error, parsed) => {
      if (ValidationError.isError(error)) error.value = parsed;
      throw error;
    }, (errors, validated) => {
      if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);
      result = validated;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, err => {
      if (ValidationError.isError(err)) return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err)) return false;
      throw err;
    }
  }
  _getDefault(options) {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === 'function' ? defaultValue.call(this, options) : clone(defaultValue);
  }
  getDefault(options
  // If schema is defaulted we know it's at least not undefined
  ) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message) {
    const next = this.clone({
      nullable
    });
    next.internalTests.nullable = createValidation({
      message,
      name: 'nullable',
      test(value) {
        return value === null ? this.schema.spec.nullable : true;
      }
    });
    return next;
  }
  optionality(optional, message) {
    const next = this.clone({
      optional
    });
    next.internalTests.optionality = createValidation({
      message,
      name: 'optionality',
      test(value) {
        return value === undefined ? this.schema.spec.optional : true;
      }
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message = mixed.defined) {
    return this.optionality(false, message);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message = mixed.notNull) {
    return this.nullability(false, message);
  }
  required(message = mixed.required) {
    return this.clone().withMutation(next => next.nonNullable(message).defined(message));
  }
  notRequired() {
    return this.clone().withMutation(next => next.nullable().optional());
  }
  transform(fn) {
    let next = this.clone();
    next.transforms.push(fn);
    return next;
  }

  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */

  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === 'function') {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === undefined) opts.message = mixed.default;
    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
    }
    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter(fn => {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys, options) {
    if (!Array.isArray(keys) && typeof keys !== 'string') {
      options = keys;
      keys = '.';
    }
    let next = this.clone();
    let deps = toArray(keys).map(key => new Reference(key));
    deps.forEach(dep => {
      // @ts-ignore readonly array
      if (dep.isSibling) next.deps.push(dep.key);
    });
    next.conditions.push(typeof options === 'function' ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next;
  }
  typeError(message) {
    let next = this.clone();
    next.internalTests.typeError = createValidation({
      message,
      name: 'typeError',
      skipAbsent: true,
      test(value) {
        if (!this.schema._typeCheck(value)) return this.createError({
          params: {
            type: this.schema.type
          }
        });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next = this.clone();
    enums.forEach(val => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next.internalTests.whiteList = createValidation({
      message,
      name: 'oneOf',
      skipAbsent: true,
      test(value) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: Array.from(valids).join(', '),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach(val => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next.internalTests.blacklist = createValidation({
      message,
      name: 'notOneOf',
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value)) return this.createError({
          params: {
            values: Array.from(invalids).join(', '),
            resolved
          }
        });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }

  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional,
      nullable
    } = next.spec;
    const description = {
      meta,
      label,
      optional,
      nullable,
      default: next.getDefault(options),
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map(fn => ({
        name: fn.OPTIONS.name,
        params: fn.OPTIONS.params
      })).filter((n, idx, list) => list.findIndex(c => c.name === n.name) === idx)
    };
    return description;
  }
}
// @ts-expect-error
Schema.prototype.__isYupSchema__ = true;
for (const method of ['validate', 'validateSync']) Schema.prototype[`${method}At`] = function (path, value, options = {}) {
  const {
    parent,
    parentPath,
    schema
  } = getIn(this, path, value, options.context);
  return schema[method](parent && parent[parentPath], Object.assign({}, options, {
    parent,
    path
  }));
};
for (const alias of ['equals', 'is']) Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ['not', 'nope']) Schema.prototype[alias] = Schema.prototype.notOneOf;

const returnsTrue = () => true;
function create$8(spec) {
  return new MixedSchema(spec);
}
class MixedSchema extends Schema {
  constructor(spec) {
    super(typeof spec === 'function' ? {
      type: 'mixed',
      check: spec
    } : Object.assign({
      type: 'mixed',
      check: returnsTrue
    }, spec));
  }
}
create$8.prototype = MixedSchema.prototype;

function create$7() {
  return new BooleanSchema();
}
class BooleanSchema extends Schema {
  constructor() {
    super({
      type: 'boolean',
      check(v) {
        if (v instanceof Boolean) v = v.valueOf();
        return typeof v === 'boolean';
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (ctx.spec.coerce && !ctx.isType(value)) {
          if (/^(true|1)$/i.test(String(value))) return true;
          if (/^(false|0)$/i.test(String(value))) return false;
        }
        return value;
      });
    });
  }
  isTrue(message = boolean.isValue) {
    return this.test({
      message,
      name: 'is-value',
      exclusive: true,
      params: {
        value: 'true'
      },
      test(value) {
        return isAbsent(value) || value === true;
      }
    });
  }
  isFalse(message = boolean.isValue) {
    return this.test({
      message,
      name: 'is-value',
      exclusive: true,
      params: {
        value: 'false'
      },
      test(value) {
        return isAbsent(value) || value === false;
      }
    });
  }
  default(def) {
    return super.default(def);
  }
  defined(msg) {
    return super.defined(msg);
  }
  optional() {
    return super.optional();
  }
  required(msg) {
    return super.required(msg);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(msg) {
    return super.nonNullable(msg);
  }
  strip(v) {
    return super.strip(v);
  }
}
create$7.prototype = BooleanSchema.prototype;

// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
let rEmail =
// eslint-disable-next-line
/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
let rUrl =
// eslint-disable-next-line
/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

// eslint-disable-next-line
let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
let isTrimmed = value => isAbsent(value) || value === value.trim();
let objStringTag = {}.toString();
function create$6() {
  return new StringSchema();
}
class StringSchema extends Schema {
  constructor() {
    super({
      type: 'string',
      check(value) {
        if (value instanceof String) value = value.valueOf();
        return typeof value === 'string';
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value)) return value;

        // don't ever convert arrays
        if (Array.isArray(value)) return value;
        const strValue = value != null && value.toString ? value.toString() : value;

        // no one wants plain objects converted to [Object object]
        if (strValue === objStringTag) return value;
        return strValue;
      });
    });
  }
  required(message) {
    return super.required(message).withMutation(schema => schema.test({
      message: message || mixed.required,
      name: 'required',
      skipAbsent: true,
      test: value => !!value.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation(schema => {
      schema.tests = schema.tests.filter(t => t.OPTIONS.name !== 'required');
      return schema;
    });
  }
  length(length, message = string.length) {
    return this.test({
      message,
      name: 'length',
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message = string.min) {
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message = string.max) {
    return this.test({
      name: 'max',
      exclusive: true,
      message,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message;
    let name;
    if (options) {
      if (typeof options === 'object') {
        ({
          excludeEmptyString = false,
          message,
          name
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name || 'matches',
      message: message || string.matches,
      params: {
        regex
      },
      skipAbsent: true,
      test: value => value === '' && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message = string.email) {
    return this.matches(rEmail, {
      name: 'email',
      message,
      excludeEmptyString: true
    });
  }
  url(message = string.url) {
    return this.matches(rUrl, {
      name: 'url',
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string.uuid) {
    return this.matches(rUUID, {
      name: 'uuid',
      message,
      excludeEmptyString: false
    });
  }

  //-- transforms --
  ensure() {
    return this.default('').transform(val => val === null ? '' : val);
  }
  trim(message = string.trim) {
    return this.transform(val => val != null ? val.trim() : val).test({
      message,
      name: 'trim',
      test: isTrimmed
    });
  }
  lowercase(message = string.lowercase) {
    return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({
      message,
      name: 'string_case',
      exclusive: true,
      skipAbsent: true,
      test: value => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message = string.uppercase) {
    return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({
      message,
      name: 'string_case',
      exclusive: true,
      skipAbsent: true,
      test: value => isAbsent(value) || value === value.toUpperCase()
    });
  }
}
create$6.prototype = StringSchema.prototype;

//
// String Interfaces
//

let isNaN$1 = value => value != +value;
function create$5() {
  return new NumberSchema();
}
class NumberSchema extends Schema {
  constructor() {
    super({
      type: 'number',
      check(value) {
        if (value instanceof Number) value = value.valueOf();
        return typeof value === 'number' && !isNaN$1(value);
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce) return value;
        let parsed = value;
        if (typeof parsed === 'string') {
          parsed = parsed.replace(/\s/g, '');
          if (parsed === '') return NaN;
          // don't use parseFloat to avoid positives on alpha-numeric strings
          parsed = +parsed;
        }

        // null -> NaN isn't useful; treat all nulls as null and let it fail on
        // nullability check vs TypeErrors
        if (ctx.isType(parsed) || parsed === null) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  min(min, message = number.min) {
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(min);
      }
    });
  }
  max(max, message = number.max) {
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(max);
      }
    });
  }
  lessThan(less, message = number.lessThan) {
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        less
      },
      skipAbsent: true,
      test(value) {
        return value < this.resolve(less);
      }
    });
  }
  moreThan(more, message = number.moreThan) {
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        more
      },
      skipAbsent: true,
      test(value) {
        return value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message = number.integer) {
    return this.test({
      name: 'integer',
      message,
      skipAbsent: true,
      test: val => Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform(value => !isAbsent(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ['ceil', 'floor', 'round', 'trunc'];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round';

    // this exists for symemtry with the new Math.trunc
    if (method === 'trunc') return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);
  }
}
create$5.prototype = NumberSchema.prototype;

//
// Number Interfaces
//

/**
 * This file is a modified version of the file from the following repository:
 * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
 * NON-CONFORMANT EDITION.
 * © 2011 Colin Snover <http://zetafleet.com>
 * Released under MIT license.
 */

// prettier-ignore
//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm
const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function toNumber(str, defaultValue = 0) {
  return Number(str) || defaultValue;
}
function parseIsoDate(date) {
  const regexResult = isoReg.exec(date);
  if (!regexResult) return Date.parse ? Date.parse(date) : Number.NaN;

  // use of toNumber() avoids NaN timestamps caused by “undefined”
  // values being passed to Date constructor
  const struct = {
    year: toNumber(regexResult[1]),
    month: toNumber(regexResult[2], 1) - 1,
    day: toNumber(regexResult[3], 1),
    hour: toNumber(regexResult[4]),
    minute: toNumber(regexResult[5]),
    second: toNumber(regexResult[6]),
    millisecond: regexResult[7] ?
    // allow arbitrary sub-second precision beyond milliseconds
    toNumber(regexResult[7].substring(0, 3)) : 0,
    z: regexResult[8] || undefined,
    plusMinus: regexResult[9] || undefined,
    hourOffset: toNumber(regexResult[10]),
    minuteOffset: toNumber(regexResult[11])
  };

  // timestamps without timezone identifiers should be considered local time
  if (struct.z === undefined && struct.plusMinus === undefined) {
    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
  }
  let totalMinutesOffset = 0;
  if (struct.z !== 'Z' && struct.plusMinus !== undefined) {
    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
    if (struct.plusMinus === '+') totalMinutesOffset = 0 - totalMinutesOffset;
  }
  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}

let invalidDate = new Date('');
let isDate = obj => Object.prototype.toString.call(obj) === '[object Date]';
function create$4() {
  return new DateSchema();
}
class DateSchema extends Schema {
  constructor() {
    super({
      type: 'date',
      check(v) {
        return isDate(v) && !isNaN(v.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on
        // nullability check vs TypeErrors
        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
        value = parseIsoDate(value);

        // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.
        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref, name) {
    let param;
    if (!Reference.isRef(ref)) {
      let cast = this.cast(ref);
      if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref;
    }
    return param;
  }
  min(min, message = date.min) {
    let limit = this.prepareParam(min, 'min');
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(limit);
      }
    });
  }
  max(max, message = date.max) {
    let limit = this.prepareParam(max, 'max');
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;
create$4.prototype = DateSchema.prototype;
create$4.INVALID_DATE = invalidDate;

// @ts-expect-error
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = new Set();
  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
  function addNode(depPath, key) {
    let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
  }
  for (const key of Object.keys(fields)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));
  }
  return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();
}

function findIndex(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if ((_err$path = err.path) != null && _err$path.includes(key)) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys) {
  return (a, b) => {
    return findIndex(keys, a) - findIndex(keys, b);
  };
}

const parseJson = (value, _, ctx) => {
  if (typeof value !== 'string') {
    return value;
  }
  let parsed = value;
  try {
    parsed = JSON.parse(value);
  } catch (err) {
    /* */
  }
  return ctx.isType(parsed) ? parsed : value;
};

// @ts-ignore
function deepPartial(schema) {
  if ('fields' in schema) {
    const partial = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial);
  }
  if (schema.type === 'array') {
    const nextArray = schema.optional();
    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === 'tuple') {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ('optional' in schema) {
    return schema.optional();
  }
  return schema;
}
const deepHas = (obj, p) => {
  const path = [...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)];
  if (path.length === 1) return path[0] in obj;
  let last = path.pop();
  let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);
  return !!(parent && last in parent);
};
let isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter(key => known.indexOf(key) === -1);
}
const defaultSort = sortByKeyOrder([]);
function create$3(spec) {
  return new ObjectSchema(spec);
}
class ObjectSchema extends Schema {
  constructor(spec) {
    super({
      type: 'object',
      check(value) {
        return isObject(value) || typeof value === 'function';
      }
    });
    this.fields = Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);

    //should ignore nulls here
    if (value === undefined) return this.getDefault(options);
    if (!this._typeCheck(value)) return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value).filter(v => !this._nodes.includes(v)));
    let intermediateValue = {}; // is filled during the transform below
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = (prop in value);
      if (field) {
        let fieldValue;
        let inputValue = value[prop];

        // safe to mutate since this is fired in sequence
        innerOptions.path = (options.path ? `${options.path}.` : '') + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : undefined;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ?
        // TODO: use _cast, this is double resolving
        field.cast(value[prop], innerOptions) : value[prop];
        if (fieldValue !== undefined) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      from = [],
      originalValue = _value,
      recursive = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from];
    // this flag is needed for handling `strict` correctly in the context of
    // validation vs just casting. e.g strict() on a field is only used when validating
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value) => {
      if (!recursive || !isObject(value)) {
        next(objectErrors, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value,
        originalValue,
        options
      }, panic, fieldErrors => {
        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
      });
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = Object.assign({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === undefined ? schemaOrRef : target;
    }
    return next.withMutation(s =>
    // XXX: excludes here is wrong
    s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));
  }
  _getDefault(options) {
    if ('default' in this.spec) {
      return super._getDefault(options);
    }

    // if there is no default set invent one
    if (!this._nodes.length) {
      return undefined;
    }
    let dft = {};
    this._nodes.forEach(key => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && 'getDefault' in field ? field.getDefault(innerOptions) : undefined;
    });
    return dft;
  }
  setFields(shape, excludedEdges) {
    let next = this.clone();
    next.fields = shape;
    next._nodes = sortFields(shape, excludedEdges);
    next._sortErrors = sortByKeyOrder(Object.keys(shape));
    // XXX: this carries over edges which may not be what you want
    if (excludedEdges) next._excludedEdges = excludedEdges;
    return next;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation(next => {
      let edges = next._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0])) excludes = [excludes];
        edges = [...next._excludedEdges, ...excludes];
      }

      // XXX: excludes here is wrong
      return next.setFields(Object.assign(next.fields, additions), edges);
    });
  }
  partial() {
    const partial = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial[key] = 'optional' in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial);
  }
  deepPartial() {
    const next = deepPartial(this);
    return next;
  }
  pick(keys) {
    const picked = {};
    for (const key of keys) {
      if (this.fields[key]) picked[key] = this.fields[key];
    }
    return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys.includes(a) && keys.includes(b)));
  }
  omit(keys) {
    const remaining = [];
    for (const key of Object.keys(this.fields)) {
      if (keys.includes(key)) continue;
      remaining.push(key);
    }
    return this.pick(remaining);
  }
  from(from, to, alias) {
    let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);
    return this.transform(obj => {
      if (!obj) return obj;
      let newObj = obj;
      if (deepHas(obj, from)) {
        newObj = Object.assign({}, obj);
        if (!alias) delete newObj[from];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }

  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  noUnknown(noAllow = true, message = object.noUnknown) {
    if (typeof noAllow !== 'boolean') {
      message = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: 'noUnknown',
      exclusive: true,
      message: message,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(', ')
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message = object.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn) {
    return this.transform(obj => {
      if (!obj) return obj;
      const result = {};
      for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);
  }
  snakeCase() {
    return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);
  }
  constantCase() {
    return this.transformKeys(key => (0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.fields = {};
    for (const [key, value] of Object.entries(next.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value.describe(innerOptions);
    }
    return base;
  }
}
create$3.prototype = ObjectSchema.prototype;

function create$2(type) {
  return new ArraySchema(type);
}
class ArraySchema extends Schema {
  constructor(type) {
    super({
      type: 'array',
      spec: {
        types: type
      },
      check(v) {
        return Array.isArray(v);
      }
    });

    // `undefined` specifically means uninitialized, as opposed to "no subtype"
    this.innerType = void 0;
    this.innerType = type;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);

    // should ignore nulls here
    if (!this._typeCheck(value) || !this.innerType) {
      return value;
    }
    let isChanged = false;
    const castArray = value.map((v, idx) => {
      const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
        path: `${_opts.path || ''}[${idx}]`
      }));
      if (castElement !== v) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    var _options$recursive;
    // let sync = options.sync;
    // let path = options.path;
    let innerType = this.innerType;
    // let endEarly = options.abortEarly ?? this.spec.abortEarly;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    options.originalValue != null ? options.originalValue : _value;
    super._validate(_value, options, panic, (arrayErrors, value) => {
      var _options$originalValu2;
      if (!recursive || !innerType || !this._typeCheck(value)) {
        next(arrayErrors, value);
        return;
      }

      // #950 Ensure that sparse array empty slots are validated
      let tests = new Array(value.length);
      for (let index = 0; index < value.length; index++) {
        var _options$originalValu;
        tests[index] = innerType.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, innerTypeErrors => next(innerTypeErrors.concat(arrayErrors), value));
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    // @ts-expect-error readonly
    next.innerType = this.innerType;
    return next;
  }

  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  concat(schema) {
    let next = super.concat(schema);

    // @ts-expect-error readonly
    next.innerType = this.innerType;
    if (schema.innerType)
      // @ts-expect-error readonly
      next.innerType = next.innerType ?
      // @ts-expect-error Lazy doesn't have concat and will break
      next.innerType.concat(schema.innerType) : schema.innerType;
    return next;
  }
  of(schema) {
    // FIXME: this should return a new instance of array without the default to be
    let next = this.clone();
    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema));

    // @ts-expect-error readonly
    next.innerType = schema;
    next.spec = Object.assign({}, next.spec, {
      types: schema
    });
    return next;
  }
  length(length, message = array.length) {
    return this.test({
      message,
      name: 'length',
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message) {
    message = message || array.min;
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      // FIXME(ts): Array<typeof T>
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message) {
    message = message || array.max;
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      // We don't want to return `null` for nullable schema
      if (this._typeCheck(val)) return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);
    return this.transform(values => values != null ? values.filter(reject) : values);
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    if (next.innerType) {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[0]
        });
      }
      base.innerType = next.innerType.describe(innerOptions);
    }
    return base;
  }
}
create$2.prototype = ArraySchema.prototype;

// @ts-ignore
function create$1(schemas) {
  return new TupleSchema(schemas);
}
class TupleSchema extends Schema {
  constructor(schemas) {
    super({
      type: 'tuple',
      spec: {
        types: schemas
      },
      check(v) {
        const types = this.spec.types;
        return Array.isArray(v) && v.length === types.length;
      }
    });
    this.withMutation(() => {
      this.typeError(tuple.notType);
    });
  }
  _cast(inputValue, options) {
    const {
      types
    } = this.spec;
    const value = super._cast(inputValue, options);
    if (!this._typeCheck(value)) {
      return value;
    }
    let isChanged = false;
    const castArray = types.map((type, idx) => {
      const castElement = type.cast(value[idx], Object.assign({}, options, {
        path: `${options.path || ''}[${idx}]`
      }));
      if (castElement !== value[idx]) isChanged = true;
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    let itemTypes = this.spec.types;
    super._validate(_value, options, panic, (tupleErrors, value) => {
      var _options$originalValu2;
      // intentionally not respecting recursive
      if (!this._typeCheck(value)) {
        next(tupleErrors, value);
        return;
      }
      let tests = [];
      for (let [index, itemSchema] of itemTypes.entries()) {
        var _options$originalValu;
        tests[index] = itemSchema.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, innerTypeErrors => next(innerTypeErrors.concat(tupleErrors), value));
    });
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.innerType = next.spec.types.map((schema, index) => {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[index]
        });
      }
      return schema.describe(innerOptions);
    });
    return base;
  }
}
create$1.prototype = TupleSchema.prototype;

function create(builder) {
  return new Lazy(builder);
}
class Lazy {
  constructor(builder) {
    this.type = 'lazy';
    this.__isYupSchema__ = true;
    this.spec = void 0;
    this._resolve = (value, options = {}) => {
      let schema = this.builder(value, options);
      if (!isSchema(schema)) throw new TypeError('lazy() functions must return a valid schema');
      if (this.spec.optional) schema = schema.optional();
      return schema.resolve(options);
    };
    this.builder = builder;
    this.spec = {
      meta: undefined,
      optional: false
    };
  }
  clone(spec) {
    const next = new Lazy(this.builder);
    next.spec = Object.assign({}, this.spec, spec);
    return next;
  }
  optionality(optional) {
    const next = this.clone({
      optional
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  resolve(options) {
    return this._resolve(options.value, options);
  }
  cast(value, options) {
    return this._resolve(value, options).cast(value, options);
  }
  asNestedTest(config) {
    let {
      key,
      index,
      parent,
      options
    } = config;
    let value = parent[index != null ? index : key];
    return this._resolve(value, Object.assign({}, options, {
      value,
      parent
    })).asNestedTest(config);
  }
  validate(value, options) {
    return this._resolve(value, options).validate(value, options);
  }
  validateSync(value, options) {
    return this._resolve(value, options).validateSync(value, options);
  }
  validateAt(path, value, options) {
    return this._resolve(value, options).validateAt(path, value, options);
  }
  validateSyncAt(path, value, options) {
    return this._resolve(value, options).validateSyncAt(path, value, options);
  }
  isValid(value, options) {
    return this._resolve(value, options).isValid(value, options);
  }
  isValidSync(value, options) {
    return this._resolve(value, options).isValidSync(value, options);
  }
  describe(options) {
    return options ? this.resolve(options).describe(options) : {
      type: 'lazy',
      meta: this.spec.meta,
      label: undefined
    };
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
}

function setLocale(custom) {
  Object.keys(custom).forEach(type => {
    // @ts-ignore
    Object.keys(custom[type]).forEach(method => {
      // @ts-ignore
      locale[type][method] = custom[type][method];
    });
  });
}

function addMethod(schemaType, name, fn) {
  if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');
  if (typeof name !== 'string') throw new TypeError('A Method name must be provided');
  if (typeof fn !== 'function') throw new TypeError('Method function must be provided');
  schemaType.prototype[name] = fn;
}




/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!*****************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom"} ***!
  \*****************************************************************************************************/
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components */ "./src/components/index.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _components__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _components__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);

}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixDQUFNO0FBQzdJO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELEVBQUUsS0FBSyxFQUlOOzs7Ozs7Ozs7Ozs7QUNsQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBOzs7Ozs7Ozs7OztBQ1hBOzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUIsY0FBYztBQUNkLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDcExhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx3SkFBeUQ7QUFDM0Q7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFdBQVc7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsb0JBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsT0FBTywwQ0FBMEM7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsZ0NBQWdDLEtBQUssNkNBQTZDLEtBQUs7QUFDdEg7QUFDQTtBQUNBLGlHQUFpRyxFQUFFLGtCQUFrQixrckJBQWtyQixFQUFFLGtCQUFrQixvRkFBb0YsRUFBRSxrQkFBa0IsMkZBQTJGLEVBQUUsa0JBQWtCLDhHQUE4RyxFQUFFLGtCQUFrQjs7QUFFcHBDO0FBQ0EsMEJBQTBCLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUc7QUFDeEY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksR0FBRyxzQkFBc0IsRUFBRSxVQUFVLEVBQUU7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxFQUFFLEdBQUcsRUFBRTtBQUNqRTtBQUNBLGVBQWUsb0RBQUs7QUFDcEI7QUFDQSx5QkFBeUIsSUFBSSxHQUFHLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxTQUFTLHFEQUFjO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBYTtBQUNoQztBQUNBO0FBQ0EsZUFBZSxxREFBTSxDQUFDLG1EQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBLGVBQWUsNEJBQTRCO1dBQzNDLGVBQWU7V0FDZixpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEEsOENBQThDOzs7OztXQ0E5QztXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdFVpa2l0L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQXZhdGFyL0F2YXRhci5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0F2YXRhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQmFkZ2UvQmFkZ2UuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9CYWRnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQnV0dG9uL0J1dHRvbi5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0J1dHRvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQ2FyZC9DYXJkLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQ2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQ2hlY2tib3gvQ2hlY2tib3guanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9DaGVja2JveC9DaGVja2JveEdyb3VwLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQ2hlY2tib3gvY29udGV4dC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvQ2hlY2tib3gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0RhdGVJbnB1dC9EYXRlSW5wdXQuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9EYXRlSW5wdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0RhdGVJbnB1dC91c2VEYXRlcGlja2VyLmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9EZWZpbml0aW9ucy9EZWZpbml0aW9ucy5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0RlZmluaXRpb25zL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93bi5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duSXRlbS5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9GaWxlL0ZpbGUuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9GaWxlL0ZpbGVQcmV2aWV3LmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvRmlsZS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0ZpbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0ZpbGVMaXN0L0ZpbGVMaXN0LmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvRmlsZUxpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0Zvcm0vRm9ybS5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0Zvcm0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0dyaWQvQ29sLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvR3JpZC9Db250YWluZXIuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9HcmlkL1Jvdy5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0dyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0dyb3VwQ29udGFpbmVyL0dyb3VwQ29udGFpbmVyLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvR3JvdXBDb250YWluZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0lucHV0L0lucHV0LmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvSW5wdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0xpc3QvTGlzdC5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0xpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL0xvYWRlci9Mb2FkZXIuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9Mb2FkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL01vZGFsL01vZGFsLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvTW9kYWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL05vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24uanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9Ob3RpZmljYXRpb24vTm90aWZpY2F0aW9uQ29udGFpbmVyLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvTm90aWZpY2F0aW9uL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9QYWdpbmF0aW9uL1BhZ2luYXRpb24uanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9QYWdpbmF0aW9uL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9QYWdpbmF0aW9uL3V0aWxzLmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9Qb3J0YWwvUG9ydGFsLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvUG9ydGFsL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9SYWRpby9SYWRpby5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1JhZGlvL1JhZGlvR3JvdXAuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9SYWRpby9jb250ZXh0LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9SYWRpby9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvU2VsZWN0L1NlbGVjdC5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1NlbGVjdC9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1NlbGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvU2VwYXJhdG9yL1NlcGFyYXRvci5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1NlcGFyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvU3RhdHVzL1N0YXR1cy5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1N0YXR1cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvVGFibGUvVGFibGUuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9UYWJsZS9UYWJsZUJvZHkuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9UYWJsZS9UYWJsZUhlYWRlci5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1RhYmxlL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9UZXh0L1RleHQuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9UZXh0L2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9UZXh0YXJlYS9UZXh0YXJlYS5qc3giLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9jb21wb25lbnRzL1RleHRhcmVhL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9Ub29sdGlwL1Rvb2x0aXAuanN4Iiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9Ub29sdGlwL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9WU3RhY2svVlN0YWNrLmpzeCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2NvbXBvbmVudHMvVlN0YWNrL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2hvb2tzL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvaG9va3MvdXNlRWxlbWVudFJlZi9jb21wb3NlUmVmLmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvaG9va3MvdXNlRWxlbWVudFJlZi9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2hvb2tzL3VzZUVsZW1lbnRSZWYvdXNlRWxlbWVudFJlZi5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2hvb2tzL3VzZUZvcm0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9ob29rcy91c2VGb3JtL3VzZUZvcm0uanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9ob29rcy91c2VGb3JtQ29udHJvbFJlZi9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2hvb2tzL3VzZUZvcm1Db250cm9sUmVmL3VzZUZvcm1Db250cm9sUmVmLmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9zcmMvaG9va3MvdXNlUHJveHlTdGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vc3JjL2hvb2tzL3VzZVByb3h5U3RhdGUvdXNlUHJveHlTdGF0ZS5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svZGlzdC9pbnB1dG1hc2suanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWV4cHIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtcnVudGltZS5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vbm9kZV9tb2R1bGVzL3RpbnktY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0Ly4vbm9kZV9tb2R1bGVzL3RvcG9zb3J0L2luZGV4LmpzIiwid2VicGFjazovL1JlYWN0VWlraXQvLi9ub2RlX21vZHVsZXMveXVwL2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0L2V4dGVybmFsIHVtZCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9Iiwid2VicGFjazovL1JlYWN0VWlraXQvZXh0ZXJuYWwgdW1kIHtcInJvb3RcIjpcIlJlYWN0RE9NXCIsXCJjb21tb25qczJcIjpcInJlYWN0LWRvbVwiLFwiY29tbW9uanNcIjpcInJlYWN0LWRvbVwiLFwiYW1kXCI6XCJyZWFjdC1kb21cIn0iLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0L3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL1JlYWN0VWlraXQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL1JlYWN0VWlraXQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9SZWFjdFVpa2l0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vUmVhY3RVaWtpdC8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiLCBcInJlYWN0LWRvbVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdFVpa2l0XCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJlYWN0VWlraXRcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIlJlYWN0RE9NXCJdKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9kb21fXykge1xucmV0dXJuICIsImltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5leHBvcnQgY29uc3QgQXZhdGFyU2l6ZSA9IHtcbiAgICBCaWc6IFwiYmlnXCIsXG4gICAgTWVkaXVtOiBcIm1lZGl1bVwiLFxuICAgIFNtYWxsOiBcInNtYWxsXCIsXG4gICAgU21hbGxlc3Q6IFwic21hbGxlc3RcIixcbn07XG5cbi8vIHRvZG86IHVzZU1lbW8sIGZvcndhcmRSZWYgP1xuXG5leHBvcnQgY29uc3QgQXZhdGFyID0gKHsgc3JjLCBjbGFzc05hbWUsIHJvdW5kZWQsIHNpemUsIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY24oXCJhdmF0YXJcIiwgY2xhc3NOYW1lLCB7IGF2YXRhcl9yb3VuZGVkOiByb3VuZGVkLCBbYGF2YXRhcl8ke3NpemV9YF06IHNpemUgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+XG4gICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT1cImF2YXRhcl9faW1hZ2VcIiBzcmM9e3NyY30gey4uLnByb3BzfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcbiIsImV4cG9ydCB7IEF2YXRhciwgQXZhdGFyU2l6ZSB9IGZyb20gXCIuL0F2YXRhclwiO1xuIiwiaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmV4cG9ydCBjb25zdCBCYWRnZVZhcmlhbnQgPSB7XG4gICAgU3VjY2VzczogXCJzdWNjZXNzXCIsXG4gICAgRXJyb3I6IFwiZXJyb3JcIixcbiAgICBXYXJuaW5nOiBcIndhcm5pbmdcIixcbiAgICBEYW5nZXI6IFwiZGFuZ2VyXCIsXG4gICAgVHJhbnNwYXJlbnQ6IFwidHJhbnNwYXJlbnRcIixcbn07XG5cbmV4cG9ydCBjb25zdCBCYWRnZU1heFdpZHRoMjUwID0gMjUwO1xuXG5leHBvcnQgY29uc3QgQmFkZ2UgPSAoeyBjbGFzc05hbWUsIGljb24sIHZhcmlhbnQsIHJvdW5kLCBtYXhXaWR0aCwgY2xvc2VhYmxlLCBvbkNsb3NlLCBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwiYmFkZ2VcIiwgY2xhc3NOYW1lLCB7XG4gICAgICAgIFtgYmFkZ2VfJHt2YXJpYW50fWBdOiB2YXJpYW50LFxuICAgICAgICBbYGJhZGdlX21heC13aWR0aC0ke21heFdpZHRofWBdOiBtYXhXaWR0aCxcbiAgICAgICAgYmFkZ2Vfcm91bmQ6IHJvdW5kLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PlxuICAgICAgICAgICAge2ljb24gJiYgKFxuICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiaWNvbiBiYWRnZV9faWNvblwiPlxuICAgICAgICAgICAgICAgICAgICA8dXNlIGhyZWY9e2B1aWtpdC9pY29uL2ljb25zLnN2ZyMke2ljb259YH0+PC91c2U+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYmFkZ2VfX3RleHRcIj57Y2hpbGRyZW59PC9zcGFuPlxuICAgICAgICAgICAge2Nsb3NlYWJsZSAmJiAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPVwiYmFkZ2VfX2J1dHRvbi1pY29uXCIgb25DbGljaz17b25DbG9zZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiYmFkZ2VfX2Nsb3NlIGljb24gaWNvbl9zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGhyZWY9XCJ1aWtpdC9pY29uL2ljb25zLnN2ZyNjbG9zZVwiPjwvdXNlPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIiwiZXhwb3J0IHsgQmFkZ2UsIEJhZGdlVmFyaWFudCwgQmFkZ2VNYXhXaWR0aDI1MCB9IGZyb20gXCIuL0JhZGdlXCI7XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHRvZG86IEJ1dHRvbiBhcyBsaW5rXG4vLyB0b2RvOiB1c2UgQnV0dG9uLlZhcmlhbnRcbi8vIHRvZG86IGNoYW5nZSBvcmRlciBvZiBtZW1vIGFuZCBmb3J3YXJkUmVmID8/P1xuLy8gdG9kbzogY3JlYXRlIGhlbHBlciBmb3IgZ2VuZXJhdGUgbmV3IGNvbXBvbmVudCAoY2xpLCBzbmlwcGV0KVxuXG5leHBvcnQgY29uc3QgQnV0dG9uVmFyaWFudCA9IHtcbiAgICBTZWNvbmRhcnk6IFwic2Vjb25kYXJ5XCIsXG4gICAgUGxhaW46IFwicGxhaW5cIixcbn07XG5cbmV4cG9ydCBjb25zdCBCdXR0b25UaGVtZSA9IHtcbiAgICBEZXN0cnVjdDogXCJkZXNjdHVjdFwiLFxufTtcblxuY29uc3QgQnV0dG9uUHJvcFR5cGVzID0ge1xuICAgIHRoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuXG4vKipcbiAqIEJ1dHRvblxuICpcbiAqIEBwYXJhbSB7e1xuICogICAgIHZhcmlhbnQ/OiBcInNlY29uZGFyeVwiIHwgXCJwbGFpblwiLFxuICogICAgIHRoZW1lPzogc3RyaW5nLFxuICogICAgIHdpZGU/OiBib29sZWFuLFxuICogICAgIGljb24/OiBzdHJpbmcsXG4gKiAgICAgdHlwZT86IHN0cmluZ1xuICogfSAmIGltcG9ydCgncmVhY3QnKS5IVE1MQXR0cmlidXRlczxIVE1MQnV0dG9uRWxlbWVudD59IHByb3BzXG4gKi9cbmV4cG9ydCBjb25zdCBCdXR0b24gPSBmb3J3YXJkUmVmKFxuICAgICh7IHZhcmlhbnQsIHRoZW1lLCB3aWRlLCBpY29uLCB0eXBlID0gXCJidXR0b25cIiwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4uYnV0dG9uUHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidXNlRWZmZWN0XCIsIHVzZUVmZmVjdCk7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLS0tIGVmZmVjdFwiKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgW2BidXR0b25fJHt2YXJpYW50fWBdOiB2YXJpYW50LFxuICAgICAgICAgICAgICAgIFtgYnV0dG9uXyR7dGhlbWV9YF06IHRoZW1lLFxuICAgICAgICAgICAgICAgIGJ1dHRvbl93aWRlOiB3aWRlLFxuICAgICAgICAgICAgICAgIGJ1dHRvbl9pY29udGV4dDogaWNvbiAmJiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBidXR0b25faWNvbjogaWNvbiAmJiAhY2hpbGRyZW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gdHlwZT17dHlwZX0gey4uLmJ1dHRvblByb3BzfT5cbiAgICAgICAgICAgICAgICB7aWNvbiAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiaWNvbiBidXR0b25fX2ljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgaHJlZj17YHVpa2l0L2ljb24vaWNvbnMuc3ZnIyR7aWNvbn1gfT48L3VzZT5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG4pO1xuXG4vLyBCdXR0b24uVmFyaWFudCA9IEJ1dHRvblZhcmlhbnQ7XG5cbi8vIGNvbnN0IF9CdXR0b24gPSBmb3J3YXJkUmVmKEJ1dHRvbik7XG5cbi8vIE9iamVjdC5hc3NpZ24oX0J1dHRvbiwge1xuLy8gICAgIGRpc3BsYXlOYW1lOiBcIkJ1dHRvblwiLFxuLy8gICAgIHByb3BUeXBlczogQnV0dG9uUHJvcFR5cGVzLFxuLy8gfSk7XG5cbi8vIGV4cG9ydCB7IF9CdXR0b24gYXMgQnV0dG9uIH07XG4iLCJleHBvcnQgeyBCdXR0b24sIEJ1dHRvblRoZW1lLCBCdXR0b25WYXJpYW50IH0gZnJvbSBcIi4vQnV0dG9uXCI7XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuZXhwb3J0IGNvbnN0IENhcmQgPSAoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCB0aGVtZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcImNhcmRcIiwgY2xhc3NOYW1lLCB7IFtgY2FyZF8ke3RoZW1lfWBdOiB0aGVtZSB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuY29uc3QgQ2FyZEZvb3RlciA9ICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkgPT4gPGRpdiBjbGFzc05hbWU9e2NuKFwiY2FyZF9fZm9vdGVyLWludGVyZmFjZVwiLCBjbGFzc05hbWUpfSB7Li4ucHJvcHN9IC8+O1xuXG5DYXJkLkZvb3RlciA9IENhcmRGb290ZXI7XG4iLCJleHBvcnQgeyBDYXJkIH0gZnJvbSBcIi4vQ2FyZFwiO1xuIiwiaW1wb3J0IHsgbWVtbywgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuaW1wb3J0IHsgdXNlRm9ybUNvbnRyb2xSZWYgfSBmcm9tIFwiLi4vLi4vaG9va3NcIjtcblxuaW1wb3J0IHsgQ2hlY2tib3hHcm91cENvbnRleHQgfSBmcm9tIFwiLi9jb250ZXh0XCI7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSBcIi4vQ2hlY2tib3hHcm91cFwiO1xuXG5jb25zdCBDaGVja2JveFZhcmlhbnQgPSB7XG4gICAgQ2hlY2tib3g6IFwiY2hlY2tib3hcIixcbiAgICBTd2l0Y2g6IFwic3dpdGNoXCIsXG59O1xuXG4vLyB0b2RvOiBpcyBuZWVkZWQgcmVxdWlyZWQ/XG5cbmV4cG9ydCBjb25zdCBDaGVja2JveCA9IG1lbW8oXG4gICAgZm9yd2FyZFJlZigocHJvcHMsIGV4dFJlZikgPT4ge1xuICAgICAgICBjb25zdCB7IGxhYmVsLCB0aXRsZSwgZXJyb3IsIGNsYXNzTmFtZSwgb25DaGFuZ2UsIC4uLm90aGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBjaGVja2JveFByb3BzID0geyAuLi5vdGhlclByb3BzIH07XG5cbiAgICAgICAgY29uc3QgeyByZWYsIGNhbGxiYWNrUmVmIH0gPSB1c2VGb3JtQ29udHJvbFJlZihleHRSZWYsIChlbCkgPT4gKHtcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IGVsLmNoZWNrZWQsXG4gICAgICAgICAgICBzZXRWYWx1ZTogKGNoZWNrZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IG9uQ2hlY2tib3hDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uQ2hhbmdlPy4ocmVmLmN1cnJlbnQuZ2V0VmFsdWUoKSwgZXZlbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNoZWNrYm94UHJvcHMub25DaGFuZ2UgPSBvbkNoZWNrYm94Q2hhbmdlO1xuXG4gICAgICAgIC8vISB1c2UgZGVmYXVsdFZhbHVlIGZvciBjb25zaXN0ZW5jeSAodXNlRm9ybSlcbiAgICAgICAgaWYgKGNoZWNrYm94UHJvcHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBjaGVja2JveFByb3BzLmRlZmF1bHRDaGVja2VkID0gY2hlY2tib3hQcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBncm91cENvbnRleHQgPSB1c2VDb250ZXh0KENoZWNrYm94R3JvdXBDb250ZXh0KTtcblxuICAgICAgICBpZiAoZ3JvdXBDb250ZXh0KSB7XG4gICAgICAgICAgICBjaGVja2JveFByb3BzLm5hbWUgPSBncm91cENvbnRleHQubmFtZTtcbiAgICAgICAgICAgIGNoZWNrYm94UHJvcHMuZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCA/PyBncm91cENvbnRleHQuZGlzYWJsZWQ7XG4gICAgICAgICAgICBjaGVja2JveFByb3BzLnZhcmlhbnQgPSBwcm9wcy52YXJpYW50ID8/IGdyb3VwQ29udGV4dC52YXJpYW50O1xuXG4gICAgICAgICAgICBjaGVja2JveFByb3BzLm9uQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgb25DaGVja2JveENoYW5nZT8uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBncm91cENvbnRleHQub25DaGFuZ2U/LihldmVudCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXBDb250ZXh0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3hQcm9wcy5jaGVja2VkID0gZ3JvdXBDb250ZXh0LnZhbHVlLmluY2x1ZGVzKGNoZWNrYm94UHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBDb250ZXh0LmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNoZWNrYm94UHJvcHMuZGVmYXVsdENoZWNrZWQgPSBncm91cENvbnRleHQuZGVmYXVsdFZhbHVlLmluY2x1ZGVzKGNoZWNrYm94UHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB2YXJpYW50ID0gQ2hlY2tib3hWYXJpYW50LkNoZWNrYm94IH0gPSBjaGVja2JveFByb3BzO1xuICAgICAgICBjb25zdCBsYWJlbENsYXNzTmFtZXMgPSBjbih2YXJpYW50LCBjbGFzc05hbWUsIHsgY2hlY2tib3hfZXJyb3I6IGVycm9yIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPXtsYWJlbENsYXNzTmFtZXN9PlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiByZWY9e2NhbGxiYWNrUmVmfSB7Li4uY2hlY2tib3hQcm9wc30gLz5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2Ake3ZhcmlhbnR9X19sYWJlbGB9PntsYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAge3RpdGxlICYmIDxzcGFuIGNsYXNzTmFtZT17YCR7dmFyaWFudH1fX3RpdGxlYH0+e3RpdGxlfTwvc3Bhbj59XG4gICAgICAgICAgICAgICAge2Vycm9yICYmIDxzcGFuIGNsYXNzTmFtZT1cImNoZWNrYm94X19lcnJvclwiPntlcnJvcn08L3NwYW4+fVxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgKTtcbiAgICB9KVxuKTtcblxuQ2hlY2tib3guR3JvdXAgPSBDaGVja2JveEdyb3VwO1xuQ2hlY2tib3guVmFyaWFudCA9IENoZWNrYm94VmFyaWFudDtcbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vLCBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZUZvcm1Db250cm9sUmVmIH0gZnJvbSBcIi4uLy4uL2hvb2tzXCI7XG5cbmltcG9ydCB7IENoZWNrYm94R3JvdXBDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG4vLyB0b2RvOiBvcHRpbWl6ZSByZW5kZXJzIGZvciBjb250cm9sbGVkIHZhcmlhbnRcbi8vIHRvZG86IHNob3cgZXJyb3IgKGlmIGFueSkgb24gbGFzdCBSYWRpbyBvbmx5XG4vLyB0b2RvOiBjcmVhdGUgUmFkaW9zIGZyb20gaXRlbXMgbGlzdCBwcm9wXG5cbmV4cG9ydCBjb25zdCBDaGVja2JveEdyb3VwID0gbWVtbyhcbiAgICBmb3J3YXJkUmVmKChwcm9wcywgZXh0UmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgdmFyaWFudCxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnQgPSBcImRpdlwiLCAvLz8gcHJvcDogYXNcbiAgICAgICAgfSA9IHByb3BzO1xuXG4gICAgICAgIGNvbnN0IHsgcmVmLCBjYWxsYmFja1JlZiB9ID0gdXNlRm9ybUNvbnRyb2xSZWYoZXh0UmVmLCAoZWwpID0+ICh7XG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tib3hOb2RlcyA9IFsuLi5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3R5cGU9J2NoZWNrYm94J11cIildO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gWy4uLmNoZWNrYm94Tm9kZXNdLm1hcCgoeyB2YWx1ZSwgY2hlY2tlZCB9KSA9PiAoY2hlY2tlZCA/IHZhbHVlIDogbnVsbCkpLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0VmFsdWU6ICh2YWx1ZXMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vISBEUllcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveE5vZGVzID0gWy4uLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdHlwZT0nY2hlY2tib3gnXVwiKV07XG5cbiAgICAgICAgICAgICAgICBjaGVja2JveE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGVja2VkID0gdmFsdWVzLmluY2x1ZGVzKG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IG9uQ2hlY2tib3hDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94Tm9kZXMgPSByZWYuY3VycmVudC5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3R5cGU9J2NoZWNrYm94J11cIik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbLi4uY2hlY2tib3hOb2Rlc10ubWFwKCh7IHZhbHVlLCBjaGVja2VkIH0pID0+IChjaGVja2VkID8gdmFsdWUgOiBudWxsKSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICAgICAgICByZWYuY3VycmVudC5lbC52YWx1ZSA9IHZhbHVlczsgLy8gcmVmIHBvaW50cyB0byBkaXZcblxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2U/Lih2YWx1ZXMsIGV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPENvbXBvbmVudCByZWY9e2NhbGxiYWNrUmVmfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgICAgICAgPENoZWNrYm94R3JvdXBDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IG1lbW8/XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogb25DaGVja2JveENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA8L0NoZWNrYm94R3JvdXBDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9Db21wb25lbnQ+XG4gICAgICAgICk7XG4gICAgfSlcbik7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDaGVja2JveEdyb3VwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoKTtcbiIsImV4cG9ydCB7IENoZWNrYm94IH0gZnJvbSBcIi4vQ2hlY2tib3hcIjtcbiIsImltcG9ydCB7IGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gXCIuLi9JbnB1dFwiO1xuXG5pbXBvcnQgeyB1c2VEYXRlcGlja2VyIH0gZnJvbSBcIi4vdXNlRGF0ZXBpY2tlclwiO1xuXG4vLyB0b2RvOiBkZWZhdWx0IG1hc2tzIC0gOTkuOTkuOTk5OSBvciA5OS45OS45OTk5IC0gOTkuOTkuOTk5OVxuXG5leHBvcnQgY29uc3QgRGF0ZUlucHV0ID0gbWVtbyhcbiAgICBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgZXh0UmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2tSZWYsIGhhbmRsZUNoYW5nZSB9ID0gdXNlRGF0ZXBpY2tlcihleHRSZWYsIHByb3BzKTtcblxuICAgICAgICBjb25zdCBjbGFzc2VzID0gY24oXCJpbnB1dF9kYXRlXCIsIGNsYXNzTmFtZSk7XG5cbiAgICAgICAgY29uc3QgaW5wdXRQcm9wcyA9IF8ub21pdChwcm9wcywgW1widmFsdWVcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQmx1clwiLCBcImRhdGVwaWNrZXJPcHRpb25zXCJdKTtcblxuICAgICAgICByZXR1cm4gPElucHV0IHJlZj17Y2FsbGJhY2tSZWZ9IGNsYXNzTmFtZT17Y2xhc3Nlc30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gey4uLmlucHV0UHJvcHN9IC8+O1xuICAgIH0pLFxuICAgIC8vISDQtNC70Y8g0LrQvtC70LHRjdC60L7QsiDQvdGD0LbQvdC+INC40YHQv9C+0LvRjNC30L7QstCw0YLRjCB1c2VDYWxsYmFjayDQv9GA0Lgg0L/QtdGA0LXQtNCw0YfQtSDQsiDQutC+0LzQv9C+0L3QtdC90YIgKNC00L7QsdCw0LLQuNGC0Ywg0LIg0LPQsNC50LQg0L/QviDRgNCw0LfRgNCw0LHQvtGC0LrQtSDQutC+0LzQv9C+0L3QtdC90YLQvtCyKVxuICAgIC8vISDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0YwgZGVlcEVxdWFsINGC0L7Qu9GM0LrQviDQtNC70Y8gb3B0aW9ucyDQuCBpdGVtcyAo0LTQu9GPINC+0YHRgtCw0LvRjNC90YvRhSAtINC/0L7QstC10YDRhdC90L7RgdGC0L3QvtC1INGB0YDQsNCy0L3QtdC90LjQtSkgPz8/XG4gICAgXy5pc0VxdWFsXG4pO1xuIiwiZXhwb3J0IHsgRGF0ZUlucHV0IH0gZnJvbSBcIi4vRGF0ZUlucHV0XCI7XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgdXNlRm9ybUNvbnRyb2xSZWYgfSBmcm9tIFwiLi4vLi4vaG9va3NcIjtcblxuLy8gY29uc3QgREVGQVVMVF9EQVRFX1ZBTFVFID0gXCJcIjtcbi8vIGNvbnN0IERFRkFVTFRfREFURV9SQU5HRSA9IFtdO1xuXG5jb25zdCBERUZBVUxUX0RBVEVfRk9STU1BVCA9IFwiREQuTU0uWVlZWVwiO1xuY29uc3QgREVGQVVMVF9NVUxUSVBMRV9EQVRFU19TRVBBUkFUT1IgPSBcIiAtIFwiO1xuY29uc3QgREFURV9TRUxFQ1RfRVZFTlQgPSBcIkRBVEVfU0VMRUNUX0VWRU5UXCI7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGF1dG9DbG9zZTogdHJ1ZSxcbiAgICBrZXlib2FyZE5hdjogZmFsc2UsXG4gICAgbXVsdGlwbGVEYXRlc1NlcGFyYXRvcjogREVGQVVMVF9NVUxUSVBMRV9EQVRFU19TRVBBUkFUT1IsXG59O1xuXG4vLyB0b2RvOiB1cGRhdGUgcGx1Z2luIHRvIHVzZSBzaWxlbnQgb3B0aW9uP1xuLy8gdG9kbzogY2hlY2sgZGlmZmVyZW50IHRpbWUgZm9ybWF0c1xuLy8gdG9kbzogcHJvY2VzcyBtaW5NYXhEYXRlIChjYW4gaW5wdXQgZGF0ZSA8IG1pbkRhdGUgYnkgaGFuZCEpXG4vLyB0b2RvOiDQsiDQvdC10LrQvtC90YLRgC4g0LLQsNGA0LjQsNC90YLQtSDRgdC00LXQu9Cw0YLRjCDRgtCw0LosINGH0YLQvtCx0Ysg0YfQtdGA0LXQtyByZWYg0LIgcmFuZ2UgbW9kZSDQvtGC0LTQsNCy0LDQu9GB0Y8g0LzQsNGB0YHQuNCyINC00LDRgi3RgdGC0YDQvtC6XG4vLyB0b2RvOiByZXR1cm4gZm9jdXMgdG8gaW5wdXQgYWZ0ZXIgc2V0dGluZyBkYXRlIGJ5IGhhbmQgaW5wdXRcblxuLy8hIHNvcnQgZGF0ZXMgYXJyYXkgb24gcmV0dXJuIG91dHNpZGUgKGNhbiBiZSBbMTk4NSwgMTk4NF0gd2hlbiB0eXBlIGJ5IGhhbmQgaW4gcmV2ZXJzZSBvcmRlciBhbmQgcGx1Z2luIGNoYW5nZXMgb3JkZXIgYnkgaGltc2VsZilcblxuZXhwb3J0IGNvbnN0IHVzZURhdGVwaWNrZXIgPSAoXG4gICAgZXh0UmVmLFxuICAgIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIG9uQmx1cixcbiAgICAgICAgZGF0ZXBpY2tlck9wdGlvbnM6IG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgZm9ybWF0ID0gREVGQVVMVF9EQVRFX0ZPUk1NQVQsXG4gICAgfVxuKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVJlZigpO1xuXG4gICAgLy8gbm90ZTogSW5wdXQgcGFzc2VzIHRvIGNhbGxiYWNrIHJlZiBvYmplY3QgeyBlbCwgc2V0VmFsdWUsIC4uLn0sIG5vdCBET00gaW5wdXQgZWxlbWVudFxuICAgIGNvbnN0IHsgcmVmLCBjYWxsYmFja1JlZiB9ID0gdXNlRm9ybUNvbnRyb2xSZWYoZXh0UmVmLCAoeyBlbCB9KSA9PiAoe1xuICAgICAgICBlbCxcbiAgICAgICAgZ2V0VmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGVWYWx1ZSA9IGdldERhdGVWYWx1ZUZyb21TdHJpbmcoZWwudmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRlVmFsdWUgfSA9IGdldFZhbGlkYXRlZERhdGUocGFyc2VkRGF0ZVZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlVmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFZhbHVlOiBzZXREYXRlLFxuICAgIH0pKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0ICRlbCA9ICQocmVmLmN1cnJlbnQuZWwpO1xuXG4gICAgICAgICRlbC5kYXRlcGlja2VyKHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIG9uU2VsZWN0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zaWxlbnQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlU2VsZWN0RXZlbnQgPSB7IHRhcmdldDogeyBuYW1lIH0sIHR5cGU6IERBVEVfU0VMRUNUX0VWRU5UIH07XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2hhbmdlKHZhbHVlLCBkYXRlU2VsZWN0RXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uSGlkZShpbnN0IC8qIG5vdCB1c2VkICovLCBpc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBvbkJsdXI/Lih7IHRhcmdldDogeyBuYW1lIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgZGF0ZSBmcm9tIGlucHV0IHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICBjb25zdCB2YWwgPSAkZWwudmFsKCk7XG4gICAgICAgIGlmICh2YWwpIHNldERhdGUodmFsLCB7IHBhcnNlOiB0cnVlIH0pO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAkZWwuZGF0YShcImRhdGVwaWNrZXJcIikuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgb25DaGFuZ2VdKTtcblxuICAgIC8vIGZvciBjb250cm9sbGVkIGlucHV0XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0ZVZhbHVlID0gdmFsdWUgfHwgZGVmYXVsdFZhbHVlOyAvLyB0b2RvPzogZG9uJ3QgdXNlIGRlZmF1bHQgdmFsdWUgaGVyZVxuICAgICAgICBpZiAoIWRhdGVWYWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgIHNldERhdGUoZGF0ZVZhbHVlKTtcblxuICAgICAgICBpZiAoY29udGV4dC5vcGVuT25Jbml0KSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9wZW5PbkluaXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgY29uc3QgZHAgPSAkKHJlZi5jdXJyZW50LmVsKS5kYXRhKFwiZGF0ZXBpY2tlclwiKTtcbiAgICAgICAgICAgIGRwLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0sIFt2YWx1ZV0pO1xuXG4gICAgLy8gc2V0IGRhdGUgb24gdmFsdWUgY2hhbmdlXG4gICAgLy8gISEhIGhhbmRsZUNoYW5nZSBnZXRzICh2YWx1ZSwgZXZlbnQpIGJlY2F1c2UgaXMgcGFzc2VkIHRvIDxJbnB1dC8+IGNvbXBvbmVudCAobm90IHRvIHByaW1pdGl2ZSA8aW5wdXQvPilcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodmFsdWUsIGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBzZXREYXRlKHZhbHVlLCB7IHBhcnNlOiB0cnVlIH0pO1xuXG4gICAgICAgIG9uQ2hhbmdlPy4oZGF0ZSwgZXZlbnQpO1xuXG4gICAgICAgIC8vIGlmIGV2ZW50IC0gZGF0ZSBpcyBjaGFuZ2VkIGJ5IGhhbmQgKHR5cGluZyBpbiBpbnB1dClcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgIT09IERBVEVfU0VMRUNUX0VWRU5UKSB7XG4gICAgICAgICAgICBjb25zdCBkcCA9ICQocmVmLmN1cnJlbnQuZWwpLmRhdGEoXCJkYXRlcGlja2VyXCIpO1xuICAgICAgICAgICAgZHAuc2hvdygpOyAvLyBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudCAtIG9wZW4gY2FsZW5kYXJcbiAgICAgICAgICAgIGNvbnRleHQub3Blbk9uSW5pdCA9IHRydWU7IC8vIGZvciBjb250cm9sbGVkIGNvbXBvbmVudCAtIG9wZW4gY2FsZW5kYXIgb24gbmV4dCByZW5kZXJcbiAgICAgICAgfVxuICAgIH0sIFtdKTsgLy8gdG9kbzogZGVwcz9cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRvIFtkMSwgZDJdXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgY29uc3QgZ2V0RGF0ZVZhbHVlRnJvbVN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyB0b2RvOiBvcHRpbWl6ZSBnZXQgc2VwYXJhdG9yXG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/Lm11bHRpcGxlRGF0ZXNTZXBhcmF0b3IgfHwgREVGQVVMVF9NVUxUSVBMRV9EQVRFU19TRVBBUkFUT1I7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM/LnJhbmdlID8gdmFsdWUuc3BsaXQoc2VwYXJhdG9yKS5maWx0ZXIoQm9vbGVhbikgOiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0VmFsaWRhdGVkRGF0ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBpc1JhbmdlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzUmFuZ2UgPyBnZXRWYWxpZGF0ZWREYXRlUmFuZ2UodmFsdWUpIDogZ2V0VmFsaWRhdGVkRGF0ZVNpbmdsZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFZhbGlkYXRlZERhdGVTaW5nbGUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGVWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0ZU9iajogbnVsbCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbURhdGUgPSBtb21lbnQodmFsdWUsIGZvcm1hdCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBtRGF0ZS5pc1ZhbGlkKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICBkYXRlVmFsdWU6IGlzVmFsaWQgPyB2YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICBkYXRlT2JqOiBpc1ZhbGlkID8gbURhdGUudG9EYXRlKCkgOiBudWxsLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRWYWxpZGF0ZWREYXRlUmFuZ2UgPSAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRlVmFsdWU6IFtdLFxuICAgICAgICAgICAgICAgIGRhdGVPYmo6IFtdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBbdmFsdWVCZWdpbiwgdmFsdWVFbmRdID0gdmFsdWU7XG5cbiAgICAgICAgY29uc3QgbURhdGVCZWdpbiA9IG1vbWVudCh2YWx1ZUJlZ2luLCBmb3JtYXQsIHRydWUpO1xuICAgICAgICBjb25zdCBtRGF0ZUVuZCA9IG1vbWVudCh2YWx1ZUVuZCwgZm9ybWF0LCB0cnVlKTtcblxuICAgICAgICBjb25zdCBpc0RhdGVCZWdpblZhbGlkID0gbURhdGVCZWdpbi5pc1ZhbGlkKCk7XG4gICAgICAgIGNvbnN0IGlzRGF0ZUVuZFZhbGlkID0gbURhdGVFbmQuaXNWYWxpZCgpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaXNEYXRlQmVnaW5WYWxpZCAmJiBpc0RhdGVFbmRWYWxpZDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIGRhdGVWYWx1ZTogaXNWYWxpZCA/IFt2YWx1ZUJlZ2luLCB2YWx1ZUVuZF0gOiBudWxsLFxuICAgICAgICAgICAgZGF0ZU9iajogaXNWYWxpZCA/IFttRGF0ZUJlZ2luLnRvRGF0ZSgpLCBtRGF0ZUVuZC50b0RhdGUoKV0gOiBudWxsLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzZXREYXRlID0gKHZhbHVlLCB7IHBhcnNlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIC8vPyBjYWxsIHNlbGVjdERhdGUgdHdvIHRpbWVzID8/PyAoc2VlIGJlbG93KVxuICAgICAgICBpZiAoIXZhbHVlKSBzZWxlY3REYXRlKCk7IC8vIHJlc2V0IGRhdGVcblxuICAgICAgICBpZiAocGFyc2UpIHZhbHVlID0gZ2V0RGF0ZVZhbHVlRnJvbVN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCBkYXRlVmFsdWUsIGRhdGVPYmogfSA9IGdldFZhbGlkYXRlZERhdGUodmFsdWUpO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkKSBzZWxlY3REYXRlKGRhdGVPYmopO1xuXG4gICAgICAgIHJldHVybiBkYXRlVmFsdWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZG9cbiAgICAgICAgICogQHBhcmFtIHsqfSBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZWxlY3REYXRlKGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRwID0gJChyZWYuY3VycmVudC5lbCkuZGF0YShcImRhdGVwaWNrZXJcIik7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRwLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoZGF0ZSkgZHAuc2VsZWN0RGF0ZShkYXRlKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2lsZW50ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBkYXRlIGluIGNhbGVuZGFyIGRyb3Bkb3duXG4gICAgICAgICAgICAvLyBub3RlOiBkcC5zZXRWaWV3RGF0ZShkYXRlLnRvRGF0ZSgpKSBpbiBuZXcgdmVyc2lvbigpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3REYXRlLCBzZWNvbmREYXRlXSA9IGRhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTYW1lID0gbW9tZW50KGZpcnN0RGF0ZSkuaXNTYW1lKG1vbWVudChzZWNvbmREYXRlKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCZWZvcmUgPSBtb21lbnQoZmlyc3REYXRlKS5pc0JlZm9yZShtb21lbnQoc2Vjb25kRGF0ZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2FtZU9yQmVmb3JlID0gaXNTYW1lIHx8IGlzQmVmb3JlO1xuICAgICAgICAgICAgICAgIGRwLmRhdGUgPSBpc1NhbWVPckJlZm9yZSA/IGZpcnN0RGF0ZSA6IHNlY29uZERhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRwLmRhdGUgPSBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNhbGxiYWNrUmVmLFxuICAgICAgICBoYW5kbGVDaGFuZ2UsXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuY29uc3QgRGVmaW5pdGlvbnNWYXJpYW50ID0ge1xuICAgIFJvdzogXCJyb3dcIixcbiAgICBSb3dUYWJsZTogXCJyb3ctdGFibGVcIixcbn07XG5cbmNvbnN0IERlZmluaXRpb25zV2lkdGggPSB7XG4gICAgVzE1MDogMTUwLFxuICAgIFcyMDA6IDIwMCxcbiAgICBXMjUwOiAyNTAsXG4gICAgVzMwMDogMzAwLFxufTtcblxuLy8gdG9kbzogd2hhdCB0byB1c2UgZm9yIGtleT9cblxuZXhwb3J0IGNvbnN0IERlZmluaXRpb25zID0gKHsgaXRlbXMgPSBbXSwgdmFyaWFudCwgZml4V2lkdGgsIHJldmVyc2UgPSBmYWxzZSwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwiZGVmaW5pdGlvbnNcIiwgY2xhc3NOYW1lLCB7XG4gICAgICAgIFtgZGVmaW5pdGlvbnNfJHt2YXJpYW50fWBdOiBCb29sZWFuKHZhcmlhbnQpLFxuICAgICAgICBbYGRlZmluaXRpb25zX2ZpeC13aWR0aC0ke2ZpeFdpZHRofWBdOiB2YXJpYW50ID09PSBEZWZpbml0aW9uc1ZhcmlhbnQuUm93VGFibGUgJiYgQm9vbGVhbihmaXhXaWR0aCksXG4gICAgICAgIGRlZmluaXRpb25zX3JldmVyc2U6IHJldmVyc2UsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfT5cbiAgICAgICAgICAgIHtpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgPERlZmluaXRpb25zSXRlbSBrZXk9e2luZGV4fSB7Li4uaXRlbX0gLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuLy8gdG9kbzogZG8gc2FtZSBmb3IgQnV0dG9uIGFuZCBvdGhlciBjb21wb25lbnRzXG5EZWZpbml0aW9ucy5WYXJpYW50ID0gRGVmaW5pdGlvbnNWYXJpYW50O1xuRGVmaW5pdGlvbnMuV2lkdGggPSBEZWZpbml0aW9uc1dpZHRoO1xuXG5jb25zdCBEZWZpbml0aW9uc0l0ZW0gPSAoeyB0ZXJtLCBkZXNjIH0pID0+IChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImRlZmluaXRpb25zX19pdGVtXCI+XG4gICAgICAgIDxkdCBjbGFzc05hbWU9XCJkZWZpbml0aW9uc19fa2V5XCI+e3Rlcm19PC9kdD5cbiAgICAgICAgPGRkIGNsYXNzTmFtZT1cImRlZmluaXRpb25zX192YWx1ZVwiPntkZXNjfTwvZGQ+XG4gICAgPC9kaXY+XG4pO1xuIiwiZXhwb3J0IHsgRGVmaW5pdGlvbnMgfSBmcm9tIFwiLi9EZWZpbml0aW9uc1wiO1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyBEcm9wZG93bkl0ZW0gfSBmcm9tIFwiLi9Ecm9wZG93bkl0ZW1cIjtcblxuZXhwb3J0IGNvbnN0IERyb3Bkb3duID0gbWVtbygoeyBpdGVtcyA9IFtdLCBvcHRpb25zID0ge30sIHRvZ2dsZSwgY2xhc3NOYW1lLCBvblNlbGVjdCB9KSA9PiB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCAkdG9nZ2xlID0gJChyZWYuY3VycmVudCk7XG5cbiAgICAgICAgaWYgKCEkdG9nZ2xlLmRhdGEoXCJ0b2dnbGVcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcm9wZG93biB0b2dnbGUgZWxlbWVudCBzaG91bGQgaGF2ZSBhdHRyaWJ1dGUgJ2RhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCInXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRvZ2dsZS5kcm9wZG93bihvcHRpb25zKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY24oXCJkcm9wZG93blwiLCBjbGFzc05hbWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAge3RvZ2dsZShyZWYpfVxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgey8qID8/PyBsZWZ0ICovfVxuICAgICAgICAgICAgICAgIHtpdGVtcy5tYXAoKHsgaWQsIC4uLml0ZW1Qcm9wcyB9KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxEcm9wZG93bkl0ZW0ga2V5PXtpZH0gb25DbGljaz17KCkgPT4gb25TZWxlY3QoaWQpfSB7Li4uaXRlbVByb3BzfSAvPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KTtcbiIsImltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5leHBvcnQgY29uc3QgRHJvcGRvd25JdGVtVHlwZSA9IHtcbiAgICBCdXR0b246IFwiYnV0dG9uXCIsXG4gICAgTGluazogXCJsaW5rXCIsXG59O1xuXG5jb25zdCBpdGVtQ2xhc3MgPSBcImRyb3Bkb3duLWl0ZW1cIjtcblxuZXhwb3J0IGNvbnN0IERyb3Bkb3duSXRlbSA9ICh7IHR5cGUgPSBEcm9wZG93bkl0ZW1UeXBlLkJ1dHRvbiwgdGV4dCwgaWNvbiwgaHJlZiwgY2xhc3NOYW1lLCBvbkNsaWNrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIHtpY29uICYmIChcbiAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgPHVzZSBocmVmPXtgdWlraXQvaWNvbi9pY29ucy5zdmcjJHtpY29ufWB9PjwvdXNlPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3Bkb3duLWl0ZW1fX3RleHRcIj57dGV4dH08L3NwYW4+XG4gICAgICAgIDwvPlxuICAgICk7XG5cbiAgICBjb25zdCBjbGFzc2VzID0ge1xuICAgICAgICBbRHJvcGRvd25JdGVtVHlwZS5CdXR0b25dOiBjbihpdGVtQ2xhc3MsIGNsYXNzTmFtZSksXG4gICAgICAgIFtEcm9wZG93bkl0ZW1UeXBlLkxpbmtdOiBjbihpdGVtQ2xhc3MsIFwibGlua1wiLCBcImNvbnRlbnRfbXV0ZWRcIiwgY2xhc3NOYW1lKSxcbiAgICB9O1xuXG4gICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgICAgW0Ryb3Bkb3duSXRlbVR5cGUuQnV0dG9uXTogKFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzZXNbdHlwZV19IG9uQ2xpY2s9e29uQ2xpY2t9IHsuLi5wcm9wc30+XG4gICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKSxcbiAgICAgICAgW0Ryb3Bkb3duSXRlbVR5cGUuTGlua106IChcbiAgICAgICAgICAgIC8vIHRvZG86IHVzZSBMaW5rXG4gICAgICAgICAgICA8YSBocmVmPXtocmVmfSBjbGFzc05hbWU9e2NsYXNzZXNbdHlwZV19IHsuLi5wcm9wc30+XG4gICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICksXG4gICAgfTtcblxuICAgIHJldHVybiBlbGVtZW50W3R5cGVdO1xufTtcbiIsImV4cG9ydCB7IERyb3Bkb3duIH0gZnJvbSBcIi4vRHJvcGRvd25cIjtcbmV4cG9ydCB7IERyb3Bkb3duSXRlbVR5cGUgfSBmcm9tIFwiLi9Ecm9wZG93bkl0ZW1cIjtcbiIsImltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIG1lbW8sIGZvcndhcmRSZWYgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgdXNlRm9ybUNvbnRyb2xSZWYgfSBmcm9tIFwiLi4vLi4vaG9va3NcIjtcblxuaW1wb3J0IHsgRmlsZVByZXZpZXcgfSBmcm9tIFwiLi9GaWxlUHJldmlld1wiO1xuaW1wb3J0IHsgRmlsZUFjdGlvbiB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG4vLyB0b2RvOiBzZWxlY3QgbXVsdGlwbGUgZmlsZXNcblxuZXhwb3J0IGNvbnN0IEZpbGUgPSBtZW1vKFxuICAgIGZvcndhcmRSZWYoXG4gICAgICAgIChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICBsYWJlbEljb24gPSBcImNsaXBcIixcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgPSBcItCf0YDQuNC60YDQtdC/0LjRgtGMXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgZmlsZTogaW5pdEZpbGUgPSBudWxsLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgIC4uLm90aGVyUHJvcHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRSZWZcbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbZmlsZSwgc2V0RmlsZV0gPSB1c2VTdGF0ZShpbml0RmlsZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJGaWxlUmVmID0gdXNlUmVmKG51bGwpOyAvLz8hIGlzIG5lZWRlZCAodXNlIGlucHV0UmVmPz8/KVxuICAgICAgICAgICAgY29uc3QgYWN0aW9uUmVmID0gdXNlUmVmKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgcmVmOiBpbnB1dFJlZiwgY2FsbGJhY2tSZWYgfSA9IHVzZUZvcm1Db250cm9sUmVmKGV4dFJlZiwgKGVsKSA9PiAoe1xuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiBjdXJyRmlsZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHNldFZhbHVlOiAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogY29tYmluZSBzZXRGaWxlIGFuZCBjdXJyRmlsZVJlZi5jdXJyZW50IHNldCB0byBvbmUgZnVuY1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJGaWxlUmVmLmN1cnJlbnQgPSBmaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgICAgICAgICAgICAgc2V0RmlsZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpbGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGFkZC9jaGFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0OiBlbCB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgICAgICAvLz8/P1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25SZWYuY3VycmVudCA9PT0gRmlsZUFjdGlvbi5DaGFuZ2UgJiYgIWVsLmZpbGVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGVsLmZpbGVzWzBdID8/IG51bGw7XG5cbiAgICAgICAgICAgICAgICBzZXRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlUmVmLmN1cnJlbnQgPSBmaWxlO1xuXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U/LihmaWxlLCBldmVudCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVBY3Rpb24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhcmdldDogZWwgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWw6IGlucHV0RWwgfSA9IGlucHV0UmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwgIT09IGlucHV0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBhY3Rpb24gfSA9IGVsLmRhdGFzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb24pIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHNhdmUgY3VycmVudCBhY3Rpb25cbiAgICAgICAgICAgICAgICBhY3Rpb25SZWYuY3VycmVudCA9IGFjdGlvbjtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRmlsZUFjdGlvbi5BZGQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRmlsZUFjdGlvbi5DaGFuZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEVsLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGaWxlQWN0aW9uLlJlbW92ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRFbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNoYW5nZVwiLCB7IGJ1YmJsZXM6IHRydWUgfSkpOyAvLz8/PyBidWJibGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInVwbG9hZFwiIG9uQ2xpY2s9e2hhbmRsZUFjdGlvbn0+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtjYWxsYmFja1JlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwbG9hZF9fY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLm90aGVyUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHshZmlsZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYWN0aW9uPXtGaWxlQWN0aW9uLkFkZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ1cGxvYWRfX2xhYmVsIGJ1dHRvbiBidXR0b25fcGxhaW4gYnV0dG9uX2ljb250ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImljb24gYnV0dG9uX19pY29uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgaHJlZj17YHVpa2l0L2ljb24vaWNvbnMuc3ZnIyR7bGFiZWxJY29ufWB9PjwvdXNlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsYWJlbFRleHR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIHt0aXRsZSAmJiA8c3BhbiBjbGFzc05hbWU9XCJ1cGxvYWRfX3RpdGxlXCI+e3RpdGxlfTwvc3Bhbj59XG4gICAgICAgICAgICAgICAgICAgIHtlcnJvciAmJiA8c3BhbiBjbGFzc05hbWU9XCJ1cGxvYWRfX2Vycm9yXCI+e2Vycm9yfTwvc3Bhbj59XG4gICAgICAgICAgICAgICAgICAgIHtkZXNjcmlwdGlvbiAmJiA8c3BhbiBjbGFzc05hbWU9XCJ1cGxvYWRfX2Rlc2NyaXB0aW9uXCI+e2Rlc2NyaXB0aW9ufTwvc3Bhbj59XG4gICAgICAgICAgICAgICAgICAgIHtmaWxlICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInVwbG9hZF9faW5mb1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGaWxlUHJldmlldyBmaWxlPXtmaWxlfSBlZGl0IHJlbW92ZSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgKVxuKTtcbiIsImltcG9ydCB7IG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyBGaWxlQWN0aW9uIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IERvd25sb2FkQnV0dG9uID0gKHsgZmlsZTogeyB1cmwgfSwgZG93bmxvYWROYW1lID0gdHJ1ZSB9KSA9PiAoXG4gICAgPGEgY2xhc3NOYW1lPVwiYnV0dG9uIGJ1dHRvbl9pY29udGV4dCBidXR0b25fcGxhaW5cIiBkb3dubG9hZD17ZG93bmxvYWROYW1lfSBocmVmPXt1cmx9PlxuICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImljb24gYnV0dG9uX19pY29uXCI+XG4gICAgICAgICAgICA8dXNlIGhyZWY9XCJ1aWtpdC9pY29uL2ljb25zLnN2ZyNkb3dubG9hZFwiPjwvdXNlPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAg0KHQutCw0YfQsNGC0YxcbiAgICA8L2E+XG4pO1xuXG5jb25zdCBFZGl0QnV0dG9uID0gKCkgPT4gKFxuICAgIDxidXR0b24gZGF0YS1hY3Rpb249e0ZpbGVBY3Rpb24uQ2hhbmdlfSBjbGFzc05hbWU9XCJmaWxlLXByZXZpZXdfX2FjdGlvbiBidXR0b24gYnV0dG9uX3BsYWluXCIgdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImljb24gYnV0dG9uX19pY29uXCI+XG4gICAgICAgICAgICA8dXNlIGhyZWY9XCJ1aWtpdC9pY29uL2ljb25zLnN2ZyNwZW5cIj48L3VzZT5cbiAgICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4pO1xuXG5jb25zdCBSZW1vdmVCdXR0b24gPSAoKSA9PiAoXG4gICAgPGJ1dHRvbiBkYXRhLWFjdGlvbj17RmlsZUFjdGlvbi5SZW1vdmV9IGNsYXNzTmFtZT1cImJ1dHRvbi1jbG9zZSBmaWxlLXByZXZpZXdfX2FjdGlvblwiIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJpY29uIGJ1dHRvbl9faWNvblwiPlxuICAgICAgICAgICAgPHVzZSBocmVmPVwidWlraXQvaWNvbi9pY29ucy5zdmcjY2xvc2VcIj48L3VzZT5cbiAgICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4pO1xuXG5jb25zdCBBY3Rpb25CdXR0b25zID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBlZGl0ID0gZmFsc2UsXG4gICAgICAgIHJlbW92ZSA9IGZhbHNlLFxuICAgICAgICBmaWxlOiB7IHVybCA9IFwiXCIgfSxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBjb25zdCBDb21wb25lbnRzID0ge1xuICAgICAgICAuLi4oZWRpdCAmJiB7IGVkaXQ6IEVkaXRCdXR0b24gfSksXG4gICAgICAgIC4uLihyZW1vdmUgJiYgeyByZW1vdmU6IFJlbW92ZUJ1dHRvbiB9KSxcbiAgICAgICAgLi4uKHVybCAmJiB7IGRvd25sb2FkOiBEb3dubG9hZEJ1dHRvbiB9KSxcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzQWN0aW9ucyA9IE9iamVjdC5rZXlzKENvbXBvbmVudHMpLmxlbmd0aCA+IDA7XG5cbiAgICByZXR1cm4gaGFzQWN0aW9ucyA/IChcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmlsZS1wcmV2aWV3X19hY3Rpb25zXCI+XG4gICAgICAgICAgICB7T2JqZWN0LmVudHJpZXMoQ29tcG9uZW50cykubWFwKChba2V5LCBDb21wb25lbnRdKSA9PiAoXG4gICAgICAgICAgICAgICAgPENvbXBvbmVudCBrZXk9e2tleX0gey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICApIDogbnVsbDtcbn07XG5cbmNvbnN0IEluZm8gPSAoeyBmaWxlOiB7IG5hbWUsIHNpemUgfSB9KSA9PiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZmlsZS1wcmV2aWV3X193cmFwcGVyXCI+XG4gICAgICAgIHsvKiBsaW5rID8/PyAqL31cbiAgICAgICAgPGEgY2xhc3NOYW1lPVwiZmlsZS1wcmV2aWV3X19uYW1lIGxpbmtcIiBocmVmPVwiI1wiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAgICAgICAge25hbWV9XG4gICAgICAgIDwvYT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmlsZS1wcmV2aWV3X19kYXRhXCI+e3NpemV9PC9zcGFuPlxuICAgIDwvc3Bhbj5cbik7XG5cbmV4cG9ydCBjb25zdCBGaWxlUHJldmlldyA9IG1lbW8oKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlIH0gPSBwcm9wcztcblxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcImZpbGUtcHJldmlld1wiLCB7IFwiZmlsZS1wcmV2aWV3X2V4dGVuZGVkXCI6IEJvb2xlYW4oZmlsZS51cmwpIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtjbGFzc05hbWVzfT5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmaWxlLXByZXZpZXdfX3R5cGUtaW1nXCJcbiAgICAgICAgICAgICAgICBzcmM9XCJ1aWtpdC9maWxlLXByZXZpZXcvcGRmLnN2Z1wiXG4gICAgICAgICAgICAgICAgd2lkdGg9XCIzMlwiXG4gICAgICAgICAgICAgICAgaGVpZ2h0PVwiMzJcIlxuICAgICAgICAgICAgICAgIGFsdD1cItCk0LDQudC7XCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8SW5mbyBmaWxlPXtmaWxlfSAvPlxuICAgICAgICAgICAgPEFjdGlvbkJ1dHRvbnMgey4uLnByb3BzfSAvPlxuICAgICAgICA8L3NwYW4+XG4gICAgKTtcbn0pO1xuIiwiZXhwb3J0IGNvbnN0IEZpbGVBY3Rpb24gPSB7XG4gICAgQWRkOiBcImFkZFwiLFxuICAgIENoYW5nZTogXCJjaGFuZ2VcIixcbiAgICBSZW1vdmU6IFwicmVtb3ZlXCIsXG59O1xuIiwiZXhwb3J0IHsgRmlsZVByZXZpZXcgfSBmcm9tIFwiLi9GaWxlUHJldmlld1wiO1xuZXhwb3J0IHsgRmlsZSB9IGZyb20gXCIuL0ZpbGVcIjtcbiIsImltcG9ydCB7IHVzZVN0YXRlLCBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IEZpbGUgfSBmcm9tIFwiLi4vRmlsZVwiO1xuXG5leHBvcnQgY29uc3QgZ2V0SWQgPSAoKSA9PiBNYXRoLmNlaWwoMWUxMCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCk7XG5cbmNvbnN0IGdldEZpbGVJbmZvID0gKGZpbGUpID0+ICh7XG4gICAgaWQ6IGdldElkKCksXG4gICAgLi4uXy5waWNrKGZpbGUsIFtcImlkXCIsIFwibmFtZVwiLCBcInNpemVcIiwgXCJ0eXBlXCJdKSxcbn0pO1xuXG5jb25zdCBtb2NrRmlsZSA9IG51bGw7XG5cbmV4cG9ydCBjb25zdCBGaWxlTGlzdCA9IG1lbW8oXG4gICAgKHsgdGl0bGUsIGRlc2NyaXB0aW9uLCBmaWxlczogaW5pdEZpbGVzID0gW10sIG9uQ2hhbmdlLCBtYXggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfSkgPT4ge1xuICAgICAgICAvLyEgaGVyZXMgaXMgdW5jb250cm9sbGVkIHZhcmlhbnRcbiAgICAgICAgY29uc3QgW2ZpbGVzLCBzZXRGaWxlc10gPSB1c2VTdGF0ZShpbml0RmlsZXMpO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChpZCA9IG51bGwsIGZpbGUpID0+IHtcbiAgICAgICAgICAgIHNldEZpbGVzKChmaWxlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaWQpIHJldHVybiBbLi4uZmlsZXMsIGdldEZpbGVJbmZvKGZpbGUpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZmlsZSkgcmV0dXJuIGZpbGVzLmZpbHRlcigoZikgPT4gZi5pZCAhPT0gaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZpbGVzLm1hcCgoZikgPT4gKGYuaWQgPT09IGlkID8gZ2V0RmlsZUluZm8oZmlsZSkgOiBmKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb25DaGFuZ2UoeyBpZCwgZmlsZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYW5BZGQgPSBmaWxlcy5sZW5ndGggPCBtYXg7XG4gICAgICAgIGNvbnN0IGZpbGVzVG9SZW5kZXIgPSBbLi4uZmlsZXNdLmNvbmNhdChjYW5BZGQgPyBtb2NrRmlsZSA6IFtdKTtcblxuICAgICAgICByZXR1cm4gZmlsZXNUb1JlbmRlci5tYXAoKGZpbGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBmaWxlID8/IHt9O1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdCA9IGluZGV4ID09PSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIC8vIDxGaWxlUHJldmlldyBmaWxlPXtmaWxlfSAvPlxuICAgICAgICAgICAgICAgIDxGaWxlXG4gICAgICAgICAgICAgICAgICAgIGtleT17aWQgPz8gZ2V0SWQoKX0gLy8/Pz8gbmVlZCByYW5kb20gaWRcbiAgICAgICAgICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2lzRmlyc3QgJiYgdGl0bGV9XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtpc0ZpcnN0ICYmIGRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KG5ld0ZpbGUpID0+IGhhbmRsZUNoYW5nZShpZCwgbmV3RmlsZSl9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbik7XG4iLCJleHBvcnQgeyBGaWxlTGlzdCB9IGZyb20gXCIuL0ZpbGVMaXN0XCI7XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuLy8gdG9kbzogZm9ybV9fZGVzY3JpcHRlZCAodmFyaWFudClcbi8vIHRvZG86IHJlY3JlYXRlIGFsbCBleGFtcGxlcyBmcm9tIHVpa2l0XG5cbmV4cG9ydCBjb25zdCBGb3JtID0gKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ub3RoZXJQcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwiZm9ybVwiLCBjbGFzc05hbWUsIHt9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxmb3JtIGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLm90aGVyUHJvcHN9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L2Zvcm0+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBGb3JtU2VjdGlvbiA9ICh7IGNsYXNzTmFtZSwgY2hpbGRyZW4sIC4uLm90aGVyUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcImZvcm1fX3NlY3Rpb25cIiwgY2xhc3NOYW1lLCB7fSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLm90aGVyUHJvcHN9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IEZvcm1EZXNjcmlwdGlvbiA9ICh7IGNsYXNzTmFtZSwgY2hpbGRyZW4sIC4uLm90aGVyUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcImZvcm1fX2Rlc2NyaXB0aW9uXCIsIGNsYXNzTmFtZSwge30pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5vdGhlclByb3BzfT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBGb3JtRmllbGRzZXQgPSAoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5vdGhlclByb3BzIH0pID0+IHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY24oXCJmb3JtX19maWVsZHNldFwiLCBjbGFzc05hbWUsIHt9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IHsuLi5vdGhlclByb3BzfT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9maWVsZHNldD5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IEZvcm1UaXRsZSA9ICh7IGNsYXNzTmFtZSwgcmVxdWlyZWQsIHRhZzogVGFnID0gXCJsZWdlbmRcIiwgY2hpbGRyZW4sIC4uLm90aGVyUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IG1haW5DbGFzc05hbWUgPSBcImZvcm1fX3RpdGxlXCI7XG5cbiAgICBjb25zdCBjbGFzc05hbWVzID0gY24obWFpbkNsYXNzTmFtZSwgY2xhc3NOYW1lLCB7XG4gICAgICAgIFtgJHttYWluQ2xhc3NOYW1lfV9yZXF1aXJlZGBdOiByZXF1aXJlZCxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWcgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ub3RoZXJQcm9wc30+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVGFnPlxuICAgICk7XG59O1xuXG5PYmplY3QuYXNzaWduKEZvcm0sIHtcbiAgICBTZWN0aW9uOiBGb3JtU2VjdGlvbixcbiAgICBEZXNjcmlwdGlvbjogRm9ybURlc2NyaXB0aW9uLFxuICAgIEZpZWxkc2V0OiBGb3JtRmllbGRzZXQsXG4gICAgVGl0bGU6IEZvcm1UaXRsZSxcbn0pO1xuIiwiZXhwb3J0IHsgRm9ybSwgRm9ybVNlY3Rpb24sIEZvcm1EZXNjcmlwdGlvbiwgRm9ybUZpZWxkc2V0LCBGb3JtVGl0bGUgfSBmcm9tIFwiLi9Gb3JtXCI7XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuY29uc3QgY29sV2lkdGhzID0gW1wieHNcIiwgXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiLCBcInh4bFwiXTtcblxuY29uc3QgZ2V0Q29sdW1uU2l6ZUNsYXNzID0gKGlzWHMsIGNvbFdpZHRoLCBjb2xTaXplKSA9PiB7XG4gICAgaWYgKGNvbFNpemUgPT09IHRydWUgfHwgY29sU2l6ZSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gaXNYcyA/IFwiY29sXCIgOiBgY29sLSR7Y29sV2lkdGh9YDtcbiAgICB9XG4gICAgaWYgKGNvbFNpemUgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIHJldHVybiBpc1hzID8gXCJjb2wtYXV0b1wiIDogYGNvbC0ke2NvbFdpZHRofS1hdXRvYDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNYcyA/IGBjb2wtJHtjb2xTaXplfWAgOiBgY29sLSR7Y29sV2lkdGh9LSR7Y29sU2l6ZX1gO1xufTtcblxuY29uc3QgZ2V0Q29sdW1uQ2xhc3NlcyA9IChhdHRyaWJ1dGVzLCB3aWR0aHMgPSBjb2xXaWR0aHMpID0+IHtcbiAgICBjb25zdCBtb2RpZmllZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNvbENsYXNzZXMgPSBbXTtcblxuICAgIHdpZHRocy5mb3JFYWNoKChjb2xXaWR0aCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBjb2x1bW5Qcm9wID0gbW9kaWZpZWRBdHRyaWJ1dGVzW2NvbFdpZHRoXTtcblxuICAgICAgICBkZWxldGUgbW9kaWZpZWRBdHRyaWJ1dGVzW2NvbFdpZHRoXTtcblxuICAgICAgICBpZiAoIWNvbHVtblByb3AgJiYgY29sdW1uUHJvcCAhPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNYcyA9ICFpO1xuXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGNvbHVtblByb3ApKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xTaXplSW50ZXJmaXggPSBpc1hzID8gXCItXCIgOiBgLSR7Y29sV2lkdGh9LWA7XG4gICAgICAgICAgICBjb25zdCBjb2xDbGFzcyA9IGdldENvbHVtblNpemVDbGFzcyhpc1hzLCBjb2xXaWR0aCwgY29sdW1uUHJvcC5zaXplKTtcblxuICAgICAgICAgICAgY29sQ2xhc3Nlcy5wdXNoKFxuICAgICAgICAgICAgICAgIGNuKHtcbiAgICAgICAgICAgICAgICAgICAgW2NvbENsYXNzXTogY29sdW1uUHJvcC5zaXplIHx8IGNvbHVtblByb3Auc2l6ZSA9PT0gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgW2BvcmRlciR7Y29sU2l6ZUludGVyZml4fSR7Y29sdW1uUHJvcC5vcmRlcn1gXTogY29sdW1uUHJvcC5vcmRlciB8fCBjb2x1bW5Qcm9wLm9yZGVyID09PSAwLFxuICAgICAgICAgICAgICAgICAgICBbYG9mZnNldCR7Y29sU2l6ZUludGVyZml4fSR7Y29sdW1uUHJvcC5vZmZzZXR9YF06IGNvbHVtblByb3Aub2Zmc2V0IHx8IGNvbHVtblByb3Aub2Zmc2V0ID09PSAwLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29sQ2xhc3MgPSBnZXRDb2x1bW5TaXplQ2xhc3MoaXNYcywgY29sV2lkdGgsIGNvbHVtblByb3ApO1xuICAgICAgICAgICAgY29sQ2xhc3Nlcy5wdXNoKGNvbENsYXNzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sQ2xhc3NlcyxcbiAgICAgICAgbW9kaWZpZWRBdHRyaWJ1dGVzLFxuICAgIH07XG59O1xuXG4vLyB0b2RvOiBybSBjc3NNb2R1bGVcbmV4cG9ydCBjb25zdCBDb2wgPSAoeyBjbGFzc05hbWUsIGNzc01vZHVsZSwgd2lkdGhzID0gY29sV2lkdGhzLCB0YWc6IFRhZyA9IFwiZGl2XCIsIC4uLmF0dHJpYnV0ZXMgfSkgPT4ge1xuICAgIGNvbnN0IHsgbW9kaWZpZWRBdHRyaWJ1dGVzLCBjb2xDbGFzc2VzIH0gPSBnZXRDb2x1bW5DbGFzc2VzKGF0dHJpYnV0ZXMsIGNzc01vZHVsZSwgd2lkdGhzKTtcblxuICAgIGlmICghY29sQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgY29sQ2xhc3Nlcy5wdXNoKFwiY29sXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbihjbGFzc05hbWUsIGNvbENsYXNzZXMpO1xuXG4gICAgcmV0dXJuIDxUYWcgey4uLm1vZGlmaWVkQXR0cmlidXRlc30gY2xhc3NOYW1lPXtjbGFzc2VzfSAvPjtcbn07XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuZXhwb3J0IGNvbnN0IENvbnRhaW5lciA9ICh7IHRhZzogVGFnID0gXCJkaXZcIiwgZmx1aWQsIGNsYXNzTmFtZSwgLi4ub3RoZXJQcm9wcyB9KSA9PiB7XG4gICAgbGV0IGNvbnRhaW5lckNsYXNzID0gXCJjb250YWluZXJcIjtcblxuICAgIC8vID8/P1xuICAgIGlmIChmbHVpZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250YWluZXJDbGFzcyA9IFwiY29udGFpbmVyLWZsdWlkXCI7XG4gICAgICAgIC8vdG9kbzogaW4gdWlraXQgb25seSBmbHVpZCBjb250YWluZXIgKG5vIHNtLCBtZCwgLi4uKVxuICAgIH0gZWxzZSBpZiAoZmx1aWQpIHtcbiAgICAgICAgY29udGFpbmVyQ2xhc3MgPSBgY29udGFpbmVyLSR7Zmx1aWR9YDtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY24oY2xhc3NOYW1lLCBjb250YWluZXJDbGFzcyk7XG5cbiAgICByZXR1cm4gPFRhZyB7Li4ub3RoZXJQcm9wc30gY2xhc3NOYW1lPXtjbGFzc2VzfSAvPjtcbn07XG4iLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuY29uc3Qgcm93Q29sV2lkdGhzID0gW1wieHNcIiwgXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiLCBcInh4bFwiXTtcblxuZXhwb3J0IGNvbnN0IFJvdyA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgbm9HdXR0ZXJzLCB0YWc6IFRhZyA9IFwiZGl2XCIsIHdpZHRocyA9IHJvd0NvbFdpZHRocywgLi4ub3RoZXJQcm9wcyB9ID0gcHJvcHM7XG5cbiAgICBjb25zdCBjb2xDbGFzc2VzID0gW107XG5cbiAgICB3aWR0aHMuZm9yRWFjaCgoY29sV2lkdGgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY29sU2l6ZSA9IHByb3BzW2NvbFdpZHRoXTtcblxuICAgICAgICBkZWxldGUgb3RoZXJQcm9wc1tjb2xXaWR0aF07XG5cbiAgICAgICAgaWYgKCFjb2xTaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1hzID0gIWk7XG4gICAgICAgIC8vIHRvZG86IG5vIHJvdy1jb2xzIGluIHVpa2l0XG4gICAgICAgIGNvbENsYXNzZXMucHVzaChpc1hzID8gYHJvdy1jb2xzLSR7Y29sU2l6ZX1gIDogYHJvdy1jb2xzLSR7Y29sV2lkdGh9LSR7Y29sU2l6ZX1gKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbihjbGFzc05hbWUsIG5vR3V0dGVycyA/IFwiZ3gtMFwiIDogbnVsbCwgXCJyb3dcIiwgY29sQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gPFRhZyByZWY9e3JlZn0gY2xhc3NOYW1lPXtjbGFzc2VzfSB7Li4ub3RoZXJQcm9wc30gLz47XG59KTtcbiIsImV4cG9ydCB7IENvbCB9IGZyb20gXCIuL0NvbFwiO1xuZXhwb3J0IHsgUm93IH0gZnJvbSBcIi4vUm93XCI7XG5leHBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi9Db250YWluZXJcIjtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5leHBvcnQgY29uc3QgR3JvdXBDb250YWluZXIgPSAoeyBjbGFzc05hbWUsIGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gY24oXCJncm91cC1jb250YWluZXJcIiwgY2xhc3NOYW1lKTtcblxuICAgIGNvbnN0IG1vZGlmeUNoaWxkcmVuID0gKGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNuKGNoaWxkLnByb3BzLmNsYXNzTmFtZSwgXCJncm91cC1jb250YWluZXJfX2l0ZW1cIik7XG4gICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgY2xhc3NOYW1lIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9PntSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIG1vZGlmeUNoaWxkcmVuKX08L2Rpdj47XG59O1xuIiwiZXhwb3J0IHsgR3JvdXBDb250YWluZXIgfSBmcm9tIFwiLi9Hcm91cENvbnRhaW5lclwiO1xuIiwiaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBtZW1vLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyEg0LHRg9C00LXRgiDRgtCw0YnQuNGC0YzRgdGPINCyINC60LDQttC00YvQuSDQsdCw0L3QtNC7XG4vLyEg0L/QvtC00YPQvNCw0YLRjCDQviDQtNC40L3QsNC80LjRh9C10YHQutC4INC/0L7QtNCz0YDRg9C20LDQtdC80YvRhSDQu9C40LHQsNGFINC4INC00LjQvdCw0LzQuNGH0LXRgdC60Lgg0L/QvtC00LPRgNGD0LbQsNC10LzRi9GFINC60L7QvNC/0L7QvdC10L3RgtCw0YVcbmltcG9ydCBJbnB1dG1hc2sgZnJvbSBcImlucHV0bWFza1wiOyAvLyB0b2RvOiBjaGVjayB2ZXJzaW9uIHdpdGggZXhpc3RpbmdcblxuLy8gdG9kbzogdXNlSW5wdXRNYXNrIGhvb2tcbi8vIHRvZG86IHVzZURhdGVpbnB1dCBob29rXG4vLyB0b2RvOiB1c2UgY29uc3QgZm9yIGZvcm1hdCAoYW5kIG9wdGlvbilcbi8vIHRvZG86IHVzZSBjb25zdGFudHMgZm9yIGlucHV0IHR5cGU6IHRleHQsIHNlYXJjaCwgZGF0ZVxuLy8gdG9kbzogdXBkYXRlIGRwIHRvIHVzZSBzaWxlbnQgb3B0aW9uIChpcyBuZWVkZWQgaGVyZT8pXG4vLyB0b2RvOiBob29rIHVzZUlucHV0bWFza1xuXG4vLz8g0LHRg9C00LXRgiDQstC+0L/RgNC+0YEsINC/0L7Rh9C10LzRgyDQv9GA0L7RgdGC0L4g0L3QtSDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0YwganNkb2NcblxuLyoqXG4gKiBAcGFyYW0ge3tcbiAqICAgIHRpdGxlPzogc3RyaW5nLFxuICogICAgZXJyb3I/OiBzdHJpbmdcbiAqICAgIG1hc2tPcHRpb25zPzogUmVjb3JkPFwic3RyaW5nXCIsIGFueT5cbiAqICAgIG9uQ2hhbmdlPzogKCkgPT4ge31cbiAqICAgIGNsYXNzTmFtZT86IHN0cmluZ1xuICogICAgdmFsdWU/OiBcInN0cmluZ1wiXG4gKiAgICBkZWZhdWx0VmFsdWU/OiBzdHJpbmdcbiAqIH0gJiBpbXBvcnQoJ3JlYWN0JykuSFRNTEF0dHJpYnV0ZXM8SFRNTElucHV0RWxlbWVudD59IHByb3BzXG4gKi9cbi8vID8/PyB3aHkgbm8gYHBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgPz8/XG5mdW5jdGlvbiBJbnB1dChcbiAgICB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgdHlwZSA9IFwidGV4dFwiLFxuICAgICAgICBtYXNrT3B0aW9ucyxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICBvbkJsdXIsXG4gICAgICAgIG9uU3VibWl0LFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIC4uLmlucHV0T3B0aW9uc1xuICAgIH0sXG4gICAgZXh0UmVmXG4pIHtcbiAgICAvLyB0b2RvITog0LLQtdGA0L3Rg9GC0Ywg0L3QsNC30LDQtFxuICAgIC8vIGNvbnN0IHsgcmVmLCBjYWxsYmFja1JlZiB9ID0gdXNlRm9ybUNvbnRyb2xSZWYoZXh0UmVmLCAoZWwpID0+ICh7XG4gICAgLy8gICAgIGVsLFxuICAgIC8vICAgICBnZXRWYWx1ZTogKCkgPT4gZWwudmFsdWUsXG4gICAgLy8gICAgIHNldFZhbHVlOiAodmFsdWUgPSBcIlwiKSA9PiB7XG4gICAgLy8gICAgICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgIC8vICAgICB9LFxuICAgIC8vICAgICAvLyEgc2V0RXJyb3I/XG4gICAgLy8gfSkpO1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8hIGRvbid0IHdvcmsgUmVhY3Qgb25DaGFuZ2Ugd2l0biBqcXVlcnkgaW5wdXRtYXNrXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Sb2JpbkhlcmJvdHMvSW5wdXRtYXNrL2lzc3Vlcy8xMzc3XG4gICAgICAgIGxldCBpbSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG1hc2tPcHRpb25zKSB7XG4gICAgICAgICAgICBpbSA9IG5ldyBJbnB1dG1hc2sobWFza09wdGlvbnMpO1xuICAgICAgICAgICAgaW0ubWFzayhyZWYuY3VycmVudC5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaW0/LnJlbW92ZShyZWYuY3VycmVudCk7XG4gICAgICAgICAgICAvLyByZXN0b3JlIGRlZmF1bHQgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGlmIChyZWYuY3VycmVudD8uZWwgJiYgcGxhY2Vob2xkZXIpIHJlZi5jdXJyZW50LmVsLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIH07XG4gICAgfSwgW0pTT04uc3RyaW5naWZ5KG1hc2tPcHRpb25zKV0pO1xuXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIG9uQ2hhbmdlPy4ocmVmLmN1cnJlbnQuZ2V0VmFsdWUoKSwgZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgb25TdWJtaXQ/LihyZWYuY3VycmVudC5nZXRWYWx1ZSgpLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlQmx1ciA9IChldmVudCkgPT4ge1xuICAgICAgICBvbkJsdXI/LihldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzU2VhcmNoID0gdHlwZSA9PT0gXCJzZWFyY2hcIjtcblxuICAgIGNvbnN0IGxhYmVsQ2xhc3NOYW1lcyA9IGNuKFwiaW5wdXRcIiwgeyBpbnB1dF9lcnJvcjogZXJyb3IsIGlucHV0X3NlYXJjaDogaXNTZWFyY2ggfSwgY2xhc3NOYW1lKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9e2xhYmVsQ2xhc3NOYW1lc30+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAvLyByZWY9e2NhbGxiYWNrUmVmfVxuICAgICAgICAgICAgICAgIHJlZj17KGVsKSA9PiAocmVmLmN1cnJlbnQgPSBlbCl9XG4gICAgICAgICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtkZWZhdWx0VmFsdWV9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259IC8vIGZvciBzZWFyY2ggaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgIG9uQmx1cj17aGFuZGxlQmx1cn1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbnB1dF9fY29udHJvbFwiXG4gICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgey4uLmlucHV0T3B0aW9uc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7aXNTZWFyY2ggJiYgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3NOYW1lPVwiaW5wdXRfX3NlYXJjaC1idXR0b25cIiAvPn1cbiAgICAgICAgICAgIHt0aXRsZSAmJiA8c3BhbiBjbGFzc05hbWU9XCJpbnB1dF9fdGl0bGVcIj57dGl0bGV9PC9zcGFuPn1cbiAgICAgICAgICAgIHtlcnJvciAmJiA8c3BhbiBjbGFzc05hbWU9XCJpbnB1dF9fZXJyb3JcIj57ZXJyb3J9PC9zcGFuPn1cbiAgICAgICAgPC9sYWJlbD5cbiAgICApO1xufVxuXG5jb25zdCBfSW5wdXQgPSBtZW1vKGZvcndhcmRSZWYoSW5wdXQpLCBfLmlzRXF1YWwpO1xuXG5leHBvcnQgeyBfSW5wdXQgYXMgSW5wdXQgfTtcbiIsImV4cG9ydCB7IElucHV0IH0gZnJvbSBcIi4vSW5wdXRcIjtcbiIsImltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5leHBvcnQgY29uc3QgTGlzdFR5cGUgPSB7XG4gICAgT3JkZXJlZDogXCJvcmRlcmVkXCIsXG4gICAgVW5vcmRlcmVkOiBcInVub3JkZXJlZFwiLFxufTtcblxuZXhwb3J0IGNvbnN0IE9yZGVyZWRMaXN0VHlwZSA9IHtcbiAgICBCcmFja2VkOiBcImJyYWNrZWRcIixcbiAgICBMZXR0ZXI6IFwibGV0dGVyXCIsXG59O1xuXG5jb25zdCBJdGVtID0gKHsgdGFnOiBUYWcgPSBcImxpXCIsIGNsYXNzTmFtZSwgLi4ub3RoZXJQcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwibGlzdF9faXRlbVwiLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiA8VGFnIGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLm90aGVyUHJvcHN9IC8+O1xufTtcblxuZXhwb3J0IGNvbnN0IExpc3QgPSAoeyB0eXBlID0gTGlzdFR5cGUuVW5vcmRlcmVkLCBsZXR0ZXIsIGJyYWNrZXQsIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGlzT3JkZXJlZCA9IHR5cGUgPT09IExpc3RUeXBlLk9yZGVyZWQ7XG4gICAgY29uc3QgVGFnID0gaXNPcmRlcmVkID8gXCJvbFwiIDogXCJ1bFwiO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwibGlzdFwiLCBjbGFzc05hbWUsIHtcbiAgICAgICAgbGlzdF9vcmRlcmVkOiBpc09yZGVyZWQsXG4gICAgICAgIFwibGlzdF9vcmRlcmVkLWxldHRlclwiOiBsZXR0ZXIsIC8vIHRvZG86IG9yZGVyZWRMaXN0VHlwZSBwcm9wXG4gICAgICAgIFwibGlzdF9vcmRlcmVkLWJyYWNrZXRcIjogYnJhY2tldCxcbiAgICB9KTtcblxuICAgIHJldHVybiA8VGFnIGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPjtcbn07XG5cbmV4cG9ydCBjb25zdCBPTGlzdCA9IChwcm9wcykgPT4gPExpc3Qgey4uLnByb3BzfSB0eXBlPXtMaXN0VHlwZS5PcmRlcmVkfSAvPjtcbmV4cG9ydCBjb25zdCBVTGlzdCA9IChwcm9wcykgPT4gPExpc3Qgey4uLnByb3BzfSB0eXBlPXtMaXN0VHlwZS5Vbm9yZGVyZWR9IC8+O1xuXG5MaXN0Lkl0ZW0gPSBJdGVtO1xuT0xpc3QuSXRlbSA9IEl0ZW07XG5VTGlzdC5JdGVtID0gSXRlbTtcbiIsImV4cG9ydCB7IExpc3QsIE9MaXN0LCBVTGlzdCwgTGlzdFR5cGUgfSBmcm9tIFwiLi9MaXN0XCI7XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuZXhwb3J0IGNvbnN0IExvYWRlciA9ICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBjbihcImxvYWRlclwiLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30gey4uLnByb3BzfSAvPjtcbn07XG4iLCJleHBvcnQgeyBMb2FkZXIgfSBmcm9tIFwiLi9Mb2FkZXJcIjtcbiIsImltcG9ydCB7IG1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gXCIuLi9Qb3J0YWxcIjtcblxuLy8gdG9kbzogY2xvc2Ugb24gRVNDIGRvbnQgd29ya1xuLy8gdG9kbzogdXNlIFBvcnRhbFxuLy8gdG9kbzogdmFsaWRhdGlvblxuLy8gdG9kbzogZG9udCBjbG9zZSBvbiBvdXRzaWRlXG4vLyB0b2RvOiB0aGVtZTogRGFuZ2VyXG4vLyB0b2RvOiBjcnQgbW9kYWxcbi8vIHRvZG86IGNsb3NlIGJ1dHRvbiBoaWRlXG4vLyB0b2RvOiB3aXRoIHByb3B0eXBlcyBkb250IG5lZWQgY29uc3RhbnRzID8/P1xuLy8gdG9kbzogZG9udCBjbG9zZSBldmVudHMgd2hlbiBkaXNhYmxlZFxuLy8gdG9kbzogbXVsdGlwbGUgY29uZmlybVxuLy8gdG9kbzogYm9vdHN0cmFwIG1vZGFsIGV2ZW50c1xuXG5leHBvcnQgY29uc3QgTW9kYWxWYXJpYW50ID0ge1xuICAgIE1vZGFsOiBcIm1vZGFsXCIsXG4gICAgRGlhbG9nOiBcImRpYWxvZ1wiLFxufTtcblxuLy8gY29uc3QgTW9kYWxUeXBlID0ge1xuLy8gICAgIEFsZXJ0OiBcImFsZXJ0XCIsXG4vLyAgICAgQ29uZmlybTogXCJjb25maXJtXCIsXG4vLyB9O1xuXG5jb25zdCBNb2RhbEV2ZW50ID0ge1xuICAgIEhpZGU6IFwiaGlkZS5icy5tb2RhbFwiLFxufTtcblxuY29uc3QgRGVmYXVsdEhlYWRlckNvbnRlbnQgPSAoeyB0aXRsZSwgaWNvbiwgZGlzYWJsZWQgfSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsX19oZWFkZXItYm94XCI+XG4gICAgICAgICAgICAgICAge2ljb24gJiYgKFxuICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImljb24gaWNvbl9icmFuZCBtb2RhbF9faGVhZGVyLWljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgaHJlZj17YC9hc3NldHMvcmVkZXNpZ24tdGhlbWUvdWlraXQvaWNvbi9pY29ucy5zdmcjJHtpY29ufWB9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cIm1vZGFsX190aXRsZVwiPnt0aXRsZX08L2gyPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkaXNhYmxlZD17ZGlzYWJsZWR9IGNsYXNzTmFtZT1cIm1vZGFsX19jbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+PC9idXR0b24+XG4gICAgICAgIDwvPlxuICAgICk7XG59O1xuXG5jb25zdCBEZWZhdWx0Rm9vdGVyQ29udGVudCA9ICh7IGNvbmZpcm1MYWJlbCA9IFwiT0tcIiwgY2FuY2VsTGFiZWwgPSBcItCe0YLQvNC10L3QuNGC0YxcIiwgZGlzYWJsZWQsIG9uQ29uZmlybSB9KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncm91cC1jb250YWluZXJcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnV0dG9uIGJ1dHRvbl9zZWNvbmRhcnkgZ3JvdXAtY29udGFpbmVyX19pdGVtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWRpc21pc3M9XCJtb2RhbFwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCLQl9Cw0LrRgNGL0YLRjCDQtNC40LDQu9C+0LPQvtCy0L7QtSDQvtC60L3QvlwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2NhbmNlbExhYmVsfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkaXNhYmxlZD17ZGlzYWJsZWR9IGNsYXNzTmFtZT1cImJ1dHRvbiBncm91cC1jb250YWluZXJfX2l0ZW1cIiBvbkNsaWNrPXtvbkNvbmZpcm19PlxuICAgICAgICAgICAgICAgIHtjb25maXJtTGFiZWx9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmNvbnN0IHJlbmRlckhlYWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgaGFzSGVhZGVyID0gdHJ1ZSB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gaGFzSGVhZGVyID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsX19oZWFkZXJcIj5cbiAgICAgICAgICAgIDxEZWZhdWx0SGVhZGVyQ29udGVudCB7Li4ucHJvcHN9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICkgOiBudWxsO1xufTtcblxuY29uc3QgcmVuZGVyRm9vdGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBoYXNGb290ZXIgPSB0cnVlIH0gPSBwcm9wcztcblxuICAgIHJldHVybiBoYXNGb290ZXIgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWxfX2Zvb3RlclwiPlxuICAgICAgICAgICAgPERlZmF1bHRGb290ZXJDb250ZW50IHsuLi5wcm9wc30gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgKSA6IG51bGw7XG59O1xuXG5jb25zdCByZW5kZXJCb2R5ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJtb2RhbF9fYm9keVwiPntjaGlsZHJlbn08L2Rpdj47XG59O1xuXG4vLyB0b2RvOiBsYXp5XG5leHBvcnQgY29uc3QgTW9kYWwgPSBtZW1vKChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgb3Blbiwgb25DbG9zZSwgdmFyaWFudCA9IE1vZGFsVmFyaWFudC5Nb2RhbCwgZWxlbWVudCwgbGF6eSA9IHRydWUgfSA9IHByb3BzO1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG4gICAgY29uc3QgW2lzTW91bnRlZCwgc2V0SXNNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNNb3VudGVkICYmIG9wZW4pIHtcbiAgICAgICAgICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtvcGVuXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgJG1vZGFsID0gJChyZWYuY3VycmVudCk7XG5cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICRtb2RhbC5vbihNb2RhbEV2ZW50LkhpZGUsICgpID0+IG9uQ2xvc2U/LigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRtb2RhbC5tb2RhbChvcGVuID8gXCJzaG93XCIgOiBcImhpZGVcIik7XG5cbiAgICAgICAgcmV0dXJuICgpID0+ICRtb2RhbC5vZmYoTW9kYWxFdmVudC5IaWRlKTtcbiAgICB9LCBbb3BlbiwgaXNNb3VudGVkXSk7XG5cbiAgICBjb25zdCBtb2RhbENsYXNzTmFtZXMgPSBjbihcIm1vZGFsXCIsIHsgW2Btb2RhbF9kaWFsb2dgXTogdmFyaWFudCA9PT0gTW9kYWxWYXJpYW50LkRpYWxvZyB9KTtcblxuICAgIGlmIChsYXp5ICYmICFpc01vdW50ZWQpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFBvcnRhbCBlbGVtZW50PXtlbGVtZW50fT5cbiAgICAgICAgICAgIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17bW9kYWxDbGFzc05hbWVzfSB0YWJJbmRleD1cIi0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbF9fY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVySGVhZGVyKHByb3BzKX1cbiAgICAgICAgICAgICAgICAgICAge3JlbmRlckJvZHkocHJvcHMpfVxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyRm9vdGVyKHByb3BzKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1BvcnRhbD5cbiAgICApO1xufSk7XG5cbi8vIHRvZG9cbmV4cG9ydCBjb25zdCBEaWFsb2cgPSAoKSA9PiB7fTtcbmV4cG9ydCBjb25zdCBBbGVydCA9ICgpID0+IHt9O1xuZXhwb3J0IGNvbnN0IENvbmZpcm0gPSAoKSA9PiB7fTtcbiIsImV4cG9ydCB7IE1vZGFsLCBNb2RhbFZhcmlhbnQgfSBmcm9tIFwiLi9Nb2RhbFwiO1xuIiwiaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbi8vIHRvZG86IHRpdGxlIGljb25cblxuZXhwb3J0IGNvbnN0IE5vdGlmaWNhdGlvbiA9ICh7IGlkLCB0aXRsZSwgY29udGVudCwgaWNvbiwgdmlzaWJsZUNsb3NlQnV0dG9uID0gdHJ1ZSwgdHlwZSB9KSA9PiB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwibm90aWZpY2F0aW9uc19fY2FyZFwiLCB7IFtgbm90aWZpY2F0aW9uc19fY2FyZF8ke3R5cGV9YF06IHR5cGUgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lc30+XG4gICAgICAgICAgICB7aWNvbiAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJub3RpZmljYXRpb25zX19jYXJkLWljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJpY29uIGljb25faW4tdGV4dFwiIGlkPVwicXVlc3Rpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgaHJlZj17YC9hc3NldHMvcmVkZXNpZ24tdGhlbWUvdWlraXQvaWNvbi9pY29ucy5zdmcjJHtpY29ufWB9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJub3RpZmljYXRpb25zX19jYXJkLXRpdGxlXCI+e3RpdGxlfTwvZGl2PlxuXG4gICAgICAgICAgICB7Y29udGVudCAmJiA8ZGl2IGNsYXNzTmFtZT1cIm5vdGlmaWNhdGlvbnNfX2NhcmQtY29udGVudFwiPntjb250ZW50fTwvZGl2Pn1cblxuICAgICAgICAgICAge3Zpc2libGVDbG9zZUJ1dHRvbiAmJiAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1pZD17aWR9IGNsYXNzTmFtZT1cImJ1dHRvbi1jbG9zZSBub3RpZmljYXRpb25zX19jYXJkLWNsb3NlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiYnV0dG9uX19pY29uIGljb24gaWNvbl9tXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGhyZWY9XCIvYXNzZXRzL3JlZGVzaWduLXRoZW1lL3Vpa2l0L2ljb24vaWNvbnMuc3ZnI2Nsb3NlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gXCIuLi9Qb3J0YWxcIjtcblxuaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSBcIi4vTm90aWZpY2F0aW9uXCI7XG5cbi8vIHRvZG86IHRpdGxlIGljb25cbi8vIHRvZG86IGNvbnRlbnQgbWFya3VwXG4vLyB0b2RvOiByZW1vdmVBbGxcbi8vIHRvZG86IGFkZCBpY29uXG5cbi8vIHRvZG86INC60LDQuiDRg9C00L7QsdC90L4g0L/QtdGA0LXQtNCw0LLQsNGC0Ywg0L3QsNGB0YLRgNC+0LnQutC4Pz8/IChzZWUgdG9hc3RpZnkpXG5cbi8vIHslIHNldCBjbGFzc05hbWVOYW1lID0gKHR5cGU9PVwiaW5mb1wiKT8gXCJhY2NlbnRcIiA6IHR5cGUgICV9XG4vLyB7JSBzZXQgaWNvbkF0dHIgPSAodHlwZT09XCJzdWNjZXNzXCIpPyB0eXBlIDogXCJxdWVzdGlvblwiICV9XG5cbmNvbnN0IFR5cGUgPSB7XG4gICAgQWNjZW50OiBcImFjY2VudFwiLFxuICAgIFdhcm5pbmc6IFwid2FybmluZ1wiLFxuICAgIERhbmdlcjogXCJkYW5nZXJcIixcbiAgICBTdWNjZXNzOiBcInN1Y2Nlc3NcIixcbn07XG5cbmNvbnN0IGZuID0ge307XG5cbmNvbnN0IHNob3cgPSAoZGF0YSwgeyB0eXBlID0gVHlwZS5BY2NlbnQgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBhZGRJdGVtIC8qIHJlbW92ZUl0ZW0gKi8gfSA9IGZuO1xuXG4gICAgY29uc3QgaWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBpdGVtID0geyBpZCwgdGl0bGU6IGlkLCB0eXBlIH07XG5cbiAgICBhZGRJdGVtKGl0ZW0pO1xuXG4gICAgLy8gdG9kbzogcmVtb3ZlVGltZW91dFxuICAgIC8vIHNldFRpbWVvdXQoKCkgPT4gcmVtb3ZlSXRlbShpZCksIDUwMDApOyAvLyB0b2RvOiBvcHRpb25zXG59O1xuXG5leHBvcnQgY29uc3Qgbm90aWZpY2F0aW9uID0ge1xuICAgIGluZm86IChkYXRhKSA9PiBzaG93KGRhdGEsIHsgdHlwZTogVHlwZS5BY2NlbnQgfSksXG4gICAgc3VjY2VzczogKGRhdGEpID0+IHNob3coZGF0YSwgeyB0eXBlOiBUeXBlLlN1Y2Nlc3MgfSksXG4gICAgZGFuZ2VyOiAoZGF0YSkgPT4gc2hvdyhkYXRhLCB7IHR5cGU6IFR5cGUuRGFuZ2VyIH0pLFxuICAgIHdhcm5pbmc6IChkYXRhKSA9PiBzaG93KGRhdGEsIHsgdHlwZTogVHlwZS5XYXJuaW5nIH0pLFxufTtcblxuZXhwb3J0IGNvbnN0IE5vdGlmaWNhdGlvbkNvbnRhaW5lciA9ICh7IC8qIGF1dG9DbG9zZSA9IHRydWUgKi8gZWxlbWVudCB9KSA9PiB7XG4gICAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgICBjb25zdCBhZGRJdGVtID0gdXNlQ2FsbGJhY2soKGl0ZW0pID0+IHtcbiAgICAgICAgc2V0SXRlbXMoKGl0ZW1zKSA9PiBbaXRlbSwgLi4uaXRlbXNdKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCByZW1vdmVJdGVtID0gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIHNldEl0ZW1zKChpdGVtcykgPT4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmlkICE9PSBpZCksIFtdKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGhhbmRsZUNsb3NlID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9ICQoZXZlbnQudGFyZ2V0KS5kYXRhKCk7XG4gICAgICAgIC8vIHRvZG86IHJlbW92ZVRpbWVvdXQgaWYgYW55XG4gICAgICAgIGlmIChpZCkgcmVtb3ZlSXRlbShpZCk7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm4uYWRkSXRlbSA9IGFkZEl0ZW07XG4gICAgICAgIGZuLnJlbW92ZUl0ZW0gPSByZW1vdmVJdGVtO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxQb3J0YWwgZWxlbWVudD17ZWxlbWVudH0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5vdGlmaWNhdGlvbnNcIiBvbkNsaWNrPXtoYW5kbGVDbG9zZX0+XG4gICAgICAgICAgICAgICAge2l0ZW1zLm1hcCgoaXRlbSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8Tm90aWZpY2F0aW9uIGtleT17aXRlbS5pZH0gey4uLml0ZW19IG9uQ2xvc2U9e2hhbmRsZUNsb3NlfSAvPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICk7XG59O1xuIiwiZXhwb3J0IHsgTm90aWZpY2F0aW9uQ29udGFpbmVyLCBub3RpZmljYXRpb24gfSBmcm9tIFwiLi9Ob3RpZmljYXRpb25Db250YWluZXJcIjtcbiIsImltcG9ydCB7IG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG4vLyB0b2RvOiBtdiB0byBzaGFyZWQgdXRpbHM/XG4vLyB0b2RvOiBkb24ndCBzaG93IHBhZ2luYXRpb24gaWYgbm8gZGF0YSBhdmFpbGFibGUgKHRvdGFsID0gMClcbmltcG9ydCB7IHBhZ2luYXRpb24gfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBQcmV2QnV0dG9uID0gKHsgcGFnZSwgcGFnZXMgfSkgPT4ge1xuICAgIGNvbnN0IGlzQ3VycmVudEZpcnN0ID0gcGFnZSA9PT0gXy5maXJzdChwYWdlcyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGNuKFwicGFnaW5hdGlvbl9faXRlbVwiLCBcInBhZ2luYXRpb25fX2l0ZW1fcHJldmlvdXNcIiwge1xuICAgICAgICBwYWdpbmF0aW9uX19pdGVtX2Rpc2FibGVkOiBpc0N1cnJlbnRGaXJzdCxcbiAgICB9KTtcbiAgICByZXR1cm4gPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzfSBkYXRhLXBhZ2U9e3BhZ2UgLSAxfT48L2J1dHRvbj47XG59O1xuXG5jb25zdCBOZXh0QnV0dG9uID0gKHsgcGFnZSwgcGFnZXMgfSkgPT4ge1xuICAgIGNvbnN0IGlzQ3VycmVudExhc3QgPSBwYWdlID09PSBfLmxhc3QocGFnZXMpO1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcInBhZ2luYXRpb25fX2l0ZW1cIiwgXCJwYWdpbmF0aW9uX19pdGVtX25leHRcIiwge1xuICAgICAgICBwYWdpbmF0aW9uX19pdGVtX2Rpc2FibGVkOiBpc0N1cnJlbnRMYXN0LFxuICAgIH0pO1xuICAgIHJldHVybiA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9e2NsYXNzTmFtZXN9IGRhdGEtcGFnZT17cGFnZSArIDF9PjwvYnV0dG9uPjtcbn07XG5cbmNvbnN0IFBhZ2VzID0gKHsgcGFnZSwgcGFnZXMgfSkgPT5cbiAgICBwYWdlcy5tYXAoKGN1cnJQYWdlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gY24oXCJwYWdpbmF0aW9uX19pdGVtIFwiLCB7IHBhZ2luYXRpb25fX2l0ZW1fYWN0aXZlOiBjdXJyUGFnZSA9PT0gcGFnZSB9KTtcblxuICAgICAgICByZXR1cm4gY3VyclBhZ2UgPT09IFwi4oCmXCIgPyAoXG4gICAgICAgICAgICA8c3BhbiBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJwYWdpbmF0aW9uX19rZWJhYlwiPlxuICAgICAgICAgICAgICAgIOKAplxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICApIDogKFxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e2luZGV4fSBkYXRhLXBhZ2U9e2N1cnJQYWdlfSB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzfT5cbiAgICAgICAgICAgICAgICB7Y3VyclBhZ2V9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9KTtcblxuLy8gdG9kbzogcHJldkJ1dHRvblRleHQsIG5leHRCdXR0b25UZXh0XG5leHBvcnQgY29uc3QgUGFnaW5hdGlvbiA9IG1lbW8oXG4gICAgKHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgcGFnZVNpemUsXG4gICAgICAgIHRvdGFsLFxuICAgICAgICBkZWx0YSxcbiAgICAgICAgYXJyb3dzID0gdHJ1ZSxcbiAgICAgICAgLy8gdG9kb1xuICAgICAgICAvLyBwcmV2QnV0dG9uVGV4dCA9IFwi0J3QsNC30LDQtFwiLFxuICAgICAgICAvLyBuZXh0QnV0dG9uVGV4dCA9IFwi0JLQv9C10YDRkdC0XCIsXG4gICAgICAgIG9uUGFnZUNoYW5nZSxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFnZXMgPSBwYWdpbmF0aW9uKHBhZ2UsIE1hdGguY2VpbCh0b3RhbCAvIHBhZ2VTaXplKSwgZGVsdGEpO1xuXG4gICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDEpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudDtcblxuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBzZWxlY3RlZFBhZ2UgfSA9IHRhcmdldC5kYXRhc2V0O1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFBhZ2UpIHJldHVybjtcblxuICAgICAgICAgICAgb25QYWdlQ2hhbmdlKE51bWJlcihzZWxlY3RlZFBhZ2UpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjbGFzc2VzID0gY24oXCJwYWdpbmF0aW9uXCIsIGNsYXNzTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfSBvbkNsaWNrPXtoYW5kbGVDbGlja30+XG4gICAgICAgICAgICAgICAge2Fycm93cyAmJiA8UHJldkJ1dHRvbiBwYWdlPXtwYWdlfSBwYWdlcz17cGFnZXN9IC8+fVxuICAgICAgICAgICAgICAgIDxQYWdlcyBwYWdlPXtwYWdlfSBwYWdlcz17cGFnZXN9IC8+XG4gICAgICAgICAgICAgICAge2Fycm93cyAmJiA8TmV4dEJ1dHRvbiBwYWdlPXtwYWdlfSBwYWdlcz17cGFnZXN9IC8+fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuKTtcbiIsImV4cG9ydCB7IFBhZ2luYXRpb24gfSBmcm9tIFwiLi9QYWdpbmF0aW9uXCI7XG4iLCIvKipcbiAqINCT0LXQvdC10YDQuNGA0YPQtdGCINC90LDQsdC+0YAg0YHRgtGA0LDQvdC40YYg0LTQu9GPINC/0LDQs9C40L3QsNGG0LjQuFxuICogQHBhcmFtIGN1cnJlbnQge251bWJlcn0gLSDRgtC10LrRg9GJ0LDRjyDRgdGC0YDQsNC90LjRhtCwXG4gKiBAcGFyYW0gdG90YWwge251bWJlcn0gLSDQvtCx0YnQtdC1INC60L7Qu9C40YfQtdGB0YLQstC+INGB0YLRgNCw0L3QuNGGXG4gKiBAcGFyYW0gZGVsdGEge251bWJlcn0gLSDRgNCw0LfQvNC10YAg0LfQsNC30L7RgNCwINCy0L7QutGA0YPQsyDRgtC10LrRg9GJ0LXQuSDRgdGC0YDQsNC90LjRhtGLXG4gKiBAcGFyYW0gdGFpbCB7bnVtYmVyfSAtINGA0LDQt9C80LXRgCBcItGF0LLQvtGB0YLQvtCyXCJcbiAqIEByZXR1cm5zIHtbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZ2luYXRpb24oY3VycmVudCwgdG90YWwsIGRlbHRhID0gMiwgdGFpbCA9IDEpIHtcbiAgICAvLyBQcmV2ZW50IGVycm9yc1xuICAgIGlmICh0eXBlb2YgdG90YWwgIT09IFwibnVtYmVyXCIgfHwgIXRvdGFsKSB7XG4gICAgICAgIHRvdGFsID0gMTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUGFnaW5hdGlvbjogcGFyYW0gYHRvdGFsYCBpcyByZXF1aXJlZC4gQXV0b2ZpeGVkXCIpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCA+IHRvdGFsKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0b3RhbDtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUGFnaW5hdGlvbjogcGFyYW0gYGN1cnJlbnRgIG1vcmUgdGhhbiBgdG90YWxgLiBBdXRvZml4ZWRcIik7XG4gICAgfVxuXG4gICAgLy8gUGFnaW5hdGlvbiBwYXJ0c1xuICAgIHZhciBsUGFydCA9IFtdLFxuICAgICAgICByUGFydCA9IFtdLFxuICAgICAgICBTcGFjZSA9IFtcIuKAplwiXTtcblxuICAgIC8vIE1ha2UgbGVmdCBwYXJ0ICh3aXRoIGltcHJvdmUgMSAuLi4gMyA0KVxuICAgIC8vINCV0YHQu9C4INC80LXQttC00YMgKGN1cnJlbnQgLSBkZWx0YSkg0LggKHRhaWwpINC10YHRgtGMIDIg0Lgg0LHQvtC70LXQtSDQv9GD0L3QutGC0L7QslxuICAgIGlmICh0b3RhbCA+PSAxMCAmJiBjdXJyZW50IC0gZGVsdGEgLSB0YWlsID49IDIpIHtcbiAgICAgICAgdmFyIGxUYWlsID0gXy5yYW5nZSgxLCB0YWlsICsgMSksXG4gICAgICAgICAgICBsRGVsdGE7XG4gICAgICAgIGlmIChjdXJyZW50ID4gdG90YWwgLSAzKSB7XG4gICAgICAgICAgICBsRGVsdGEgPSBfLnJhbmdlKHRvdGFsIC0gNCwgY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsRGVsdGEgPSBfLnJhbmdlKGN1cnJlbnQgLSBkZWx0YSwgY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbFBhcnQgPSBsUGFydC5jb25jYXQobFRhaWwsIFNwYWNlLCBsRGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxQYXJ0ID0gXy5yYW5nZSgxLCBjdXJyZW50KTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHJpZ2h0IHBhcnQgKHdpdGggaW1wcm92ZSA2IDcgLi4uIDkpXG4gICAgLy8g0JXRgdC70Lgg0LzQtdC20LTRgyAoY3VycmVudCArIGRlbHRhKSDQuCAodGFpbCkg0LXRgdGC0YwgMiDQuCDQsdC+0LvQtdC1INC/0YPQvdC60YLQvtCyXG4gICAgaWYgKHRvdGFsID49IDEwICYmIHRvdGFsIC0gMiA+PSBjdXJyZW50ICsgZGVsdGEgKyB0YWlsIC0gMSkge1xuICAgICAgICB2YXIgclRhaWwgPSBfLnJhbmdlKDEgKyB0b3RhbCAtIHRhaWwsIDEgKyB0b3RhbCksXG4gICAgICAgICAgICByRGVsdGE7XG4gICAgICAgIGlmIChjdXJyZW50IDwgNCkge1xuICAgICAgICAgICAgckRlbHRhID0gXy5yYW5nZSgxICsgY3VycmVudCwgNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByRGVsdGEgPSBfLnJhbmdlKDEgKyBjdXJyZW50LCAxICsgY3VycmVudCArIGRlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJQYXJ0ID0gclBhcnQuY29uY2F0KHJEZWx0YSwgU3BhY2UsIHJUYWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByUGFydCA9IF8ucmFuZ2UoMSArIGN1cnJlbnQsIDEgKyB0b3RhbCk7XG4gICAgfVxuXG4gICAgLy8gQWRkaXRpb25hbCBvcHRpbWl6YXRpb25cbiAgICAvLyBJZiBjdXJyZW50IHBhZ2UgKyB0YWlscyArIGRlbHRhcyBpcyBtb3JlIHBhZ2VzIHRoYW4gdG90YWxcbiAgICBpZiAoMSArICh0YWlsICsgZGVsdGEpICogMiA+PSB0b3RhbCkge1xuICAgICAgICByZXR1cm4gXy5yYW5nZSgxLCAxICsgdG90YWwpO1xuICAgIH1cblxuICAgIHJldHVybiBbXS5jb25jYXQobFBhcnQsIGN1cnJlbnQsIHJQYXJ0KTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIjtcblxuLy8gdG9kbzogc2hvdWxkIGhhdmUgc3RvcmllcyBmb3IgUG9ydGFsID8/P1xuZXhwb3J0IGNvbnN0IFBvcnRhbCA9ICh7IGNoaWxkcmVuLCBlbGVtZW50ID0gZG9jdW1lbnQuYm9keSB9KSA9PiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGVsZW1lbnQpO1xuIiwiZXhwb3J0IHsgUG9ydGFsIH0gZnJvbSBcIi4vUG9ydGFsXCI7XG4iLCJpbXBvcnQgUmVhY3QsIHsgbWVtbywgdXNlQ29udGV4dCwgdXNlUmVmLCBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuaW1wb3J0IHsgY29tcG9zZVJlZiB9IGZyb20gXCIuLi8uLi9ob29rcy91c2VFbGVtZW50UmVmXCI7XG5cbmltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tIFwiLi9SYWRpb0dyb3VwXCI7XG5pbXBvcnQgeyBSYWRpb0dyb3VwQ29udGV4dCB9IGZyb20gXCIuL2NvbnRleHRcIjtcblxuLy8gdG9kbzogb3B0aW1pemUgcmVuZGVyc1xuXG5leHBvcnQgY29uc3QgUmFkaW8gPSBtZW1vKFxuICAgIGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgeyBsYWJlbCwgdGl0bGUsIGVycm9yLCBjbGFzc05hbWUsIC4uLm90aGVyUHJvcHMgfSA9IHByb3BzO1xuXG4gICAgICAgIGNvbnN0IGlubmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgICBjb25zdCBtZXJnZWRSZWYgPSBjb21wb3NlUmVmKHJlZiwgaW5uZXJSZWYpO1xuXG4gICAgICAgIGNvbnN0IGdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoUmFkaW9Hcm91cENvbnRleHQpO1xuXG4gICAgICAgIGNvbnN0IG9uUmFkaW9DaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2U/LihlKTtcbiAgICAgICAgICAgIGdyb3VwQ29udGV4dD8ub25DaGFuZ2U/LihlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByYWRpb1Byb3BzID0geyAuLi5vdGhlclByb3BzIH07XG5cbiAgICAgICAgaWYgKGdyb3VwQ29udGV4dCkge1xuICAgICAgICAgICAgcmFkaW9Qcm9wcy5uYW1lID0gZ3JvdXBDb250ZXh0Lm5hbWU7XG4gICAgICAgICAgICByYWRpb1Byb3BzLm9uQ2hhbmdlID0gb25SYWRpb0NoYW5nZTtcbiAgICAgICAgICAgIHJhZGlvUHJvcHMuZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCA/PyBncm91cENvbnRleHQuZGlzYWJsZWQ7XG5cbiAgICAgICAgICAgIGlmIChncm91cENvbnRleHQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmFkaW9Qcm9wcy5kZWZhdWx0Q2hlY2tlZCA9IHByb3BzLnZhbHVlID09PSBncm91cENvbnRleHQuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBDb250ZXh0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmFkaW9Qcm9wcy5jaGVja2VkID0gcHJvcHMudmFsdWUgPT09IGdyb3VwQ29udGV4dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhYmVsQ2xhc3NOYW1lcyA9IGNuKFwicmFkaW9cIiwgY2xhc3NOYW1lLCB7IHJhZGlvX2Vycm9yOiBlcnJvciB9KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT17bGFiZWxDbGFzc05hbWVzfT5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgcmVmPXttZXJnZWRSZWZ9IHsuLi5yYWRpb1Byb3BzfSAvPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInJhZGlvX19sYWJlbFwiPntsYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAge3RpdGxlICYmIDxzcGFuIGNsYXNzTmFtZT1cInJhZGlvX190aXRsZVwiPnt0aXRsZX08L3NwYW4+fVxuICAgICAgICAgICAgICAgIHtlcnJvciAmJiA8c3BhbiBjbGFzc05hbWU9XCJyYWRpb19fZXJyb3JcIj57ZXJyb3J9PC9zcGFuPn1cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICk7XG4gICAgfSlcbik7XG5cblJhZGlvLkdyb3VwID0gUmFkaW9Hcm91cDtcbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vLCBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZUZvcm1Db250cm9sUmVmIH0gZnJvbSBcIi4uLy4uL2hvb2tzXCI7XG5cbmltcG9ydCB7IFJhZGlvR3JvdXBDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG4vLyB0b2RvOiBvcHRpbWl6ZSByZW5kZXJzIGZvciBjb250cm9sbGVkIHZhcmlhbnRcbi8vIHRvZG86IHNob3cgZXJyb3IgKGlmIGFueSkgb24gbGFzdCBSYWRpbyBvbmx5XG4vLyB0b2RvOiBjcmVhdGUgUmFkaW9zIGZyb20gaXRlbXMgbGlzdCBwcm9wXG5cbmV4cG9ydCBjb25zdCBSYWRpb0dyb3VwID0gbWVtbyhcbiAgICBmb3J3YXJkUmVmKChwcm9wcywgZXh0UmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSwgZGlzYWJsZWQsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIGNvbXBvbmVudDogQ29tcG9uZW50ID0gXCJkaXZcIiB9ID0gcHJvcHM7XG5cbiAgICAgICAgY29uc3QgeyByZWYsIGNhbGxiYWNrUmVmIH0gPSB1c2VGb3JtQ29udHJvbFJlZihleHRSZWYsIChlbCkgPT4gKHtcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkRWwgPSBlbC5xdWVyeVNlbGVjdG9yKFwiW3R5cGU9J3JhZGlvJ106Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tlZEVsID8gY2hlY2tlZEVsLnZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRWYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBlbC5xdWVyeVNlbGVjdG9yKGBbdHlwZT0ncmFkaW8nXVt2YWx1ZT0nJHt2YWx1ZX0nXWApO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IFsuLi5lbC5xdWVyeVNlbGVjdG9yQWxsKGBbdHlwZT0ncmFkaW8nXWApXTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHRvZG86IHNob3VsZCByZXR1cm4gKHZhbHVlLCBldmVudClcbiAgICAgICAgY29uc3Qgb25SYWRpb0NoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgcHJvcHM/Lm9uQ2hhbmdlKHJlZi5jdXJyZW50LmdldFZhbHVlKCksIGV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gdG9kbzogdXNlIENvbXBvbmVudCBpbiBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICA8Q29tcG9uZW50IHJlZj17Y2FsbGJhY2tSZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgICA8UmFkaW9Hcm91cENvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogbWVtbz9cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IG9uUmFkaW9DaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC9SYWRpb0dyb3VwQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIDwvQ29tcG9uZW50PlxuICAgICAgICApO1xuICAgIH0pXG4pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgUmFkaW9Hcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG4iLCJleHBvcnQgeyBSYWRpbyB9IGZyb20gXCIuL1JhZGlvXCI7XG4iLCJpbXBvcnQgeyBtZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyB1c2VGb3JtQ29udHJvbFJlZiB9IGZyb20gXCIuLi8uLi9ob29rc1wiO1xuXG5pbXBvcnQgeyBTZWxlY3RFdmVudCwgc2VsZWN0cGlja2VyRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCBkZWZhdWx0U2VsZWN0cGlja2VyT3B0aW9ucyA9IHt9O1xuY29uc3QgZGVmYXVsdEl0ZW1zID0gW107XG5cbi8vIHRvZG86IFwiQWxsXCIgb3B0aW9ucyBmb3Igc2luZ2xlL211bHRpcGxlIHNlbGVjdCAoaG93IHRvIHNldD8pXG4vLyB0b2RvOiBlbXB0eSBvcHRpb24gKGhvdyB0byBzZXQ/KVxuXG5jb25zdCByZW5kZXJPcHRpb25zID0gKGl0ZW1zKSA9PlxuICAgIGl0ZW1zLm1hcChcbiAgICAgICAgKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBncm91cEl0ZW1zLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgIHRva2VuID0gXCJcIixcbiAgICAgICAgICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgICAgICAgICAgY29udGVudCA9IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VidGV4dCA9IFwiXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gXCJcIixcbiAgICAgICAgICAgICAgICBkaXZpZGVyLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICkgPT5cbiAgICAgICAgICAgIGdyb3VwSXRlbXMgPyAoXG4gICAgICAgICAgICAgICAgPG9wdGdyb3VwIGtleT17bGFiZWwgfHwgaW5kZXh9IGxhYmVsPXtsYWJlbH0gZGlzYWJsZWQ9e2Rpc2FibGVkfT5cbiAgICAgICAgICAgICAgICAgICAge3JlbmRlck9wdGlvbnMoZ3JvdXBJdGVtcyl9XG4gICAgICAgICAgICAgICAgPC9vcHRncm91cD5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgPG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBrZXk9e3ZhbHVlIHx8IGBub1ZhbHVlJHtpbmRleH1gfVxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLXRva2Vucz17dG9rZW59XG4gICAgICAgICAgICAgICAgICAgIGRhdGEtY29udGVudD17Y29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1zdWJ0ZXh0PXtzdWJ0ZXh0fVxuICAgICAgICAgICAgICAgICAgICBkYXRhLWRpdmlkZXI9e2RpdmlkZXJ9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgICApXG4gICAgKTtcblxuZXhwb3J0IGNvbnN0IFNlbGVjdCA9IG1lbW8oXG4gICAgZm9yd2FyZFJlZihcbiAgICAgICAgKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGl0ZW1zID0gZGVmYXVsdEl0ZW1zLFxuICAgICAgICAgICAgICAgIHNlbGVjdHBpY2tlck9wdGlvbnMgPSBkZWZhdWx0U2VsZWN0cGlja2VyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICBjbG9zZWFibGUsXG4gICAgICAgICAgICAgICAgbm9EZWNvcixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgICAgICBvbkNsb3NlLFxuICAgICAgICAgICAgICAgIC8vIG9uQmx1ciwgLy8gdG9kbzogaXMgbmVlZGVkIGZvciB1c2VGb3JtICg/KVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAuLi5zZWxlY3RPcHRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXh0UmVmXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhamF4T3B0aW9ucywgYWRkSXRlbXNPcHRpb25zIH0gPSBzZWxlY3RwaWNrZXJPcHRpb25zO1xuXG4gICAgICAgICAgICBjb25zdCB7IHJlZiwgY2FsbGJhY2tSZWYgfSA9IHVzZUZvcm1Db250cm9sUmVmKGV4dFJlZiwgKGVsKSA9PiAoe1xuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gJChlbCkuc2VsZWN0cGlja2VyKFwidmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGVsO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20ob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgc2VsZWN0ZWQgfSkgPT4gc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXVsdGlwbGUgPyB2YWx1ZXMgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldFZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gbXVsdGlwbGUgPyBbXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICQoZWwpLnNlbGVjdHBpY2tlcihcInZhbFwiLCB2YWx1ZSA/PyBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHNlbGVjdCA9ICQocmVmLmN1cnJlbnQuZWwpO1xuXG4gICAgICAgICAgICAgICAgd2luZG93LmluaXRCb290c3RyYXBTZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50LmVsLFxuICAgICAgICAgICAgICAgICAgICBfLm9taXQoc2VsZWN0cGlja2VyT3B0aW9ucywgW1wiYWpheE9wdGlvbnNcIiwgXCJhZGRJdGVtc09wdGlvbnNcIl0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIHRvZG86IGluaXQgcGx1Z2lucyBpbiBzZXBhcmF0ZSBlZmZlY3RzID8/P1xuICAgICAgICAgICAgICAgIGlmIChhamF4T3B0aW9ucykgJHNlbGVjdC5hamF4U2VsZWN0UGlja2VyKGFqYXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkSXRlbXNPcHRpb25zKSAkc2VsZWN0LmFkZFNlbGVjdFBpY2tlcihhZGRJdGVtc09wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogaXMgbmVlZGVkIGZvciB1c2VGb3JtICg/KVxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHsgJGJ1dHRvbiB9ID0gJHNlbGVjdC5kYXRhKFwic2VsZWN0cGlja2VyXCIpO1xuICAgICAgICAgICAgICAgIC8vICRidXR0b24ucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpO1xuICAgICAgICAgICAgICAgIC8vICRidXR0b25cbiAgICAgICAgICAgICAgICAvLyAgICAgLm9uKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhcImJsdXIgYnV0dG9uXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgb25CbHVyPy4oeyB0YXJnZXQ6IHsgbmFtZTogc2VsZWN0T3B0aW9ucy5uYW1lIH0gfSk7XG4gICAgICAgICAgICAgICAgLy8gICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gICAgIC5vbihcImZvY3VzXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZm9jdXMgYnV0dG9uXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICB9KVxuICAgICAgICAgICAgICAgIC8vICAgICAub24oXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAkc2VsZWN0LnNlbGVjdHBpY2tlcihcInRvZ2dsZVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgc2VsZWN0cGlja2VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogY2hlY2sgb3JkZXIgb2YgZXZlbnRzXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc2VsZWN0T3B0aW9ucykuZm9yRWFjaCgoW3Byb3BOYW1lLCBmbl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgZXZlbnROYW1lXSA9IHByb3BOYW1lLnNwbGl0KFwib25cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnROYW1lKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZVVwcGVyY2FzZSA9IGV2ZW50TmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lVXBwZXJjYXNlIGluIFNlbGVjdEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RwaWNrZXJFdmVudE5hbWUgPSBTZWxlY3RFdmVudFtldmVudE5hbWVVcHBlcmNhc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNlbGVjdC5vbihzZWxlY3RwaWNrZXJFdmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdC5kYXRhKFwiQWRkQm9vdHN0cmFwU2VsZWN0XCIpPy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3Qub2ZmKCkuc2VsZWN0cGlja2VyKFwiZGVzdHJveVwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgIC8vISBOT1RFOlxuICAgICAgICAgICAgICAgIC8vISDQuNGB0L/QvtC70YzQt9GD0LXQvCBKU09OLnN0cmluZ2lmeSwg0YfRgtC+0LHRiyDQv9GA0LXQtNC+0YLQstGA0LDRgtC40YLRjCDQv9C10YDQtdC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGOINCyINGB0LvRg9GH0LDQtSwg0LXRgdC70Lgg0L/RgNC+0LjQt9C+0YjQtdC7INGA0LXQvdC00LXRgCAo0L/RgNC+0L/RgdGLINC40LfQvNC10L3QuNC70LjRgdGMLCBtZW1vINC90LUg0L/QvtC80L7Qs9C70L4pLFxuICAgICAgICAgICAgICAgIC8vISDQvdC+INC/0YDQuCDRjdGC0L7QvCDQvtCx0YrQtdC60YLQvdGL0Lkg0L/RgNC+0L/RgdGLINC90LUg0LHRi9C70Lgg0LzQtdC80L7QuNC30LjRgNC+0LLQsNC90Ysg0LIg0LrQu9C40LXQvdGC0YHQutC+0Lwg0LrQvtC00LUgKNGN0YLQviDRgNCw0YHQv9GA0L7RgdGC0YDQsNC90LjRj9C10YLRgdGPINGC0LDQutC20LUg0L3QsCBJbnB1dCwgRGF0ZUlucHV0LCDQs9C00LVcbiAgICAgICAgICAgICAgICAvLyEg0LjRgdC/0L7Qu9GM0LfRg9GO0YLRgdGPINC/0LvQsNCz0LjQvdGLIGFpci1kYXRlcGlja2VyINC4IGlucHV0bWFzaylcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShpdGVtcyksXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2VsZWN0cGlja2VyT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHsgb3B0aW9ucywgdmFsdWUgfSxcbiAgICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyEgRFJZIChzZWUgcmVmKVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20ob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoeyBzZWxlY3RlZCB9KSA9PiBzZWxlY3RlZClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT8uKG11bHRpcGxlID8gdmFsdWVzIDogdmFsdWUsIGV2ZW50KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGxhYmVsQ2xhc3NOYW1lcyA9IGNuKFxuICAgICAgICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBbYCR7Y2xvc2VhYmxlID8gXCJzZWxlY3RfY2xvc2VhYmxlX2Vycm9yXCIgOiBcInNlbGVjdF9lcnJvclwifWBdOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0X2Nsb3NlYWJsZTogY2xvc2VhYmxlLFxuICAgICAgICAgICAgICAgICAgICBcInNlbGVjdF9uby1kZWNvclwiOiBub0RlY29yLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RfcmVxdWlyZWQ6IHNlbGVjdE9wdGlvbnMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdENsYXNzTmFtZXMgPSBjbihcInNlbGVjdF9fY29udHJvbFwiLCB7XG4gICAgICAgICAgICAgICAgZHJvcHVwOiBzZWxlY3RwaWNrZXJPcHRpb25zLmRyb3B1cEF1dG8gPT09IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCAoIWFqYXhPcHRpb25zICYmICFpdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyB0b2RvOiB1c2UgZGF0YS1pbml0PWZhbHNlXG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT17bGFiZWxDbGFzc05hbWVzfT5cbiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtjYWxsYmFja1JlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c2VsZWN0Q2xhc3NOYW1lc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZT17bXVsdGlwbGV9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5fLm9taXQoc2VsZWN0T3B0aW9ucywgc2VsZWN0cGlja2VyRXZlbnRIYW5kbGVycyl9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiA8b3B0aW9uIGRhdGEtaGlkZGVuPVwidHJ1ZVwiIGtleT1cImRlZmF1bHRcIiAvPiAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJPcHRpb25zKGl0ZW1zKX1cbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG5cbiAgICAgICAgICAgICAgICAgICAge2Nsb3NlYWJsZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnV0dG9uIGJ1dHRvbl9wbGFpbiBidXR0b25faWNvbiBzZWxlY3RfX2Nsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNsb3NlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiaWNvbiBidXR0b25fX2ljb24gc2VsZWN0X19jbG9zZS1pY29uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgaHJlZj1cInVpa2l0L2ljb24vaWNvbnMuc3ZnI2Nsb3NlXCI+PC91c2U+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICAgICAgICB7dGl0bGUgJiYgIWNsb3NlYWJsZSAmJiA8c3BhbiBjbGFzc05hbWU9XCJzZWxlY3RfX3RpdGxlXCI+e3RpdGxlfTwvc3Bhbj59XG5cbiAgICAgICAgICAgICAgICAgICAgey8qIGlzIHVzZWQgd2l0aCBub0RlY29yIG1vZGUgKi99XG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbCAmJiAhY2xvc2VhYmxlICYmIDxzcGFuIGNsYXNzTmFtZT1cInNlbGVjdF9fbGFiZWxcIj57bGFiZWx9PC9zcGFuPn1cblxuICAgICAgICAgICAgICAgICAgICB7ZXJyb3IgJiYgIWNsb3NlYWJsZSAmJiAhbm9EZWNvciAmJiA8c3BhbiBjbGFzc05hbWU9XCJzZWxlY3RfX2Vycm9yXCI+e2Vycm9yfTwvc3Bhbj59XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICApLFxuICAgIF8uaXNFcXVhbFxuKTtcbiIsImV4cG9ydCBjb25zdCBTZWxlY3RFdmVudCA9IHtcbiAgICBTSE9XOiBcInNob3cuYnMuc2VsZWN0XCIsXG4gICAgU0hPV046IFwic2hvd24uYnMuc2VsZWN0XCIsXG4gICAgSElERTogXCJoaWRlLmJzLnNlbGVjdFwiLFxuICAgIEhJRERFTjogXCJoaWRkZW4uYnMuc2VsZWN0XCIsXG4gICAgTE9BREVEOiBcImxvYWRlZC5icy5zZWxlY3RcIixcbiAgICBSRU5ERVJFRDogXCJyZW5kZXJlZC5icy5zZWxlY3RcIixcbiAgICBSRUZSRVNIRUQ6IFwicmVmcmVzaGVkLmJzLnNlbGVjdFwiLFxuICAgIENIQU5HRUQ6IFwiY2hhbmdlZC5icy5zZWxlY3RcIixcbn07XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RwaWNrZXJFdmVudEhhbmRsZXJzID0gT2JqZWN0LmtleXMoU2VsZWN0RXZlbnQpLm1hcCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gXCJvblwiICsgbGNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBsY05hbWUuc2xpY2UoMSk7XG59KTtcbiIsImV4cG9ydCB7IFNlbGVjdCB9IGZyb20gXCIuL1NlbGVjdFwiO1xuZXhwb3J0IHsgU2VsZWN0RXZlbnQgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbiIsImltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5leHBvcnQgY29uc3QgU2VwYXJhdG9yID0gKHsgY2xhc3NOYW1lLCB3aWRlLCB2ZXJ0aWNhbCwgY2hpbGRyZW4gfSkgPT4ge1xuICAgIGNvbnN0IG1haW5DbGFzcyA9IFwic2VwYXJhdG9yXCI7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY24obWFpbkNsYXNzLCBjbGFzc05hbWUsIHtcbiAgICAgICAgW2Ake21haW5DbGFzc31fd2lkZWBdOiB3aWRlLFxuICAgICAgICBbYCR7bWFpbkNsYXNzfV92ZXJ0aWNhbGBdOiB2ZXJ0aWNhbCxcbiAgICB9KTtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic2VwYXJhdG9yXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic2VwYXJhdG9yX190ZXh0XCI+e2NoaWxkcmVufTwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gPGhyIGNsYXNzTmFtZT17Y2xhc3Nlc30gLz47XG59O1xuIiwiZXhwb3J0IHsgU2VwYXJhdG9yIH0gZnJvbSBcIi4vU2VwYXJhdG9yXCI7XG4iLCJpbXBvcnQgY24gZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuaW1wb3J0IHsgU3BhbiB9IGZyb20gXCIuLi9UZXh0XCI7XG5cbi8vIHRvZG86IHVzZSBTdGF0dXMuVHlwZSA9IHsuLi59XG5cbmV4cG9ydCBjb25zdCBTdGF0dXNUeXBlID0ge1xuICAgIFN1Y2Nlc3M6IFwic3VjY2Vzc1wiLFxuICAgIFdhcm5pbmc6IFwid2FybmluZ1wiLFxuICAgIERhbmdlcjogXCJkYW5nZXJcIixcbiAgICBNdXRlZDogXCJtdXRlZFwiLFxufTtcblxuZXhwb3J0IGNvbnN0IFN0YXR1cyA9ICh7IHR5cGUgPSBTdGF0dXNUeXBlLk5vcm1hbCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcbiAgICAgICAgXCJzdGF0dXNcIixcbiAgICAgICAge1xuICAgICAgICAgICAgW2BzdGF0dXNfJHt0eXBlfWBdOiB0eXBlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNwYW4gY2xhc3NOYW1lPXtjbGFzc05hbWVzfSB7Li4ucHJvcHN9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NwYW4+XG4gICAgKTtcbn07XG4iLCJleHBvcnQgeyBTdGF0dXMsIFN0YXR1c1R5cGUgfSBmcm9tIFwiLi9TdGF0dXNcIjtcbiIsImltcG9ydCB7IG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyBUYWJsZUhlYWRlciB9IGZyb20gXCIuL1RhYmxlSGVhZGVyXCI7XG5pbXBvcnQgeyBUYWJsZUJvZHkgfSBmcm9tIFwiLi9UYWJsZUJvZHlcIjtcblxuLy8gdG9kbzogbm9EYXRhIGljb24gaW4gYm9keSAoaWYgbm8gaGlkZSB0YWJsZSBmb3IgZW1wdHkgaXRlbXMpXG5cbmV4cG9ydCBjb25zdCBUYWJsZSA9IG1lbW8oKHsgY29sdW1ucywgaXRlbXMsIHNvcnRDb2x1bW4sIG9uU29ydCwgY2xhc3NOYW1lIH0pID0+IHtcbiAgICBjb25zdCBjbGFzc2VzID0gY24oXCJ0YWJsZV9fd3JhcHBlclwiLCBjbGFzc05hbWUpO1xuXG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXN9IHRhYkluZGV4PVwiMFwiPlxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XG4gICAgICAgICAgICAgICAgPFRhYmxlSGVhZGVyIGNvbHVtbnM9e2NvbHVtbnN9IHNvcnRDb2x1bW49e3NvcnRDb2x1bW59IG9uU29ydD17b25Tb3J0fSAvPlxuICAgICAgICAgICAgICAgIDxUYWJsZUJvZHkgY29sdW1ucz17Y29sdW1uc30gaXRlbXM9e2l0ZW1zfSAvPlxuICAgICAgICAgICAgICAgIHsvKiB0b2RvOiBmb290ZXIgKi99XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG4iLCJpbXBvcnQgeyBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUYWJsZUJvZHkgPSBtZW1vKCh7IGNvbHVtbnMsIGl0ZW1zLCBpZEZpZWxkTmFtZSA9IFwiaWRcIiB9KSA9PiAoXG4gICAgPHRib2R5IGNsYXNzTmFtZT1cInRhYmxlX19ib2R5XCI+XG4gICAgICAgIHtpdGVtcy5tYXAoKGl0ZW0pID0+IChcbiAgICAgICAgICAgIDx0ciBjbGFzc05hbWU9XCJ0YWJsZV9faXRlbVwiIGtleT17aXRlbVtpZEZpZWxkTmFtZV19PlxuICAgICAgICAgICAgICAgIHtjb2x1bW5zLm1hcCgoY29sKSA9PiByZW5kZXJDZWxsKGNvbCwgaXRlbSkpfVxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgKSl9XG4gICAgPC90Ym9keT5cbikpO1xuXG4vKipcbiAqIFJlbmRlciBjZWxsXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNlbGwoY29sLCBpdGVtKSB7XG4gICAgY29uc3Qga2V5ID0gY29sLnBhdGggfHwgY29sLmtleTtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbC52YWx1ZSA/IGNvbC52YWx1ZShpdGVtKSA6IGdldChpdGVtLCBjb2wucGF0aCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPHRkIGNsYXNzTmFtZT1cInRhYmxlX19jZWxsXCIga2V5PXtrZXl9PlxuICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICA8L3RkPlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBmb3IgKHZhciBpID0gMCwgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbiIsImltcG9ydCB7IG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZGVyID0gbWVtbygoeyBjb2x1bW5zLCBzb3J0Q29sdW1uLCBvblNvcnQgfSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDx0aGVhZCBjbGFzc05hbWU9XCJ0YWJsZV9faGVhZGVyXCI+XG4gICAgICAgICAgICA8dHIgY2xhc3NOYW1lPVwidGFibGVfX2hlYWRcIj57Y29sdW1ucy5tYXAocmVuZGVyQ29sdW1uKX08L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICk7XG5cbiAgICAvLyBGdW5jdGlvbnNcbiAgICAvLyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLlxuXG4gICAgZnVuY3Rpb24gcmVuZGVyQ29sdW1uKGNvbHVtbikge1xuICAgICAgICBjb25zdCB7IHBhdGgsIGtleSwgbGFiZWwgfSA9IGNvbHVtbjtcbiAgICAgICAgLy8gY29uc3QgaWNvbiA9IHJlbmRlclNvcnRJY29uKHsgY29sdW1uLCBzb3J0Q29sdW1uIH0pO1xuXG4gICAgICAgIGlmIChjb2x1bW4ucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8dGgga2V5PXtwYXRofSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVTb3J0KHBhdGgpfSBjbGFzc05hbWU9XCJ0YWJsZV9fdGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICAgICAgICB7Lyoge2ljb259ICovfVxuICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDx0aCBrZXk9e2tleX0+PC90aD47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU29ydChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBzb3J0Q29sdW1uLnBhdGgpIHtcbiAgICAgICAgICAgIG9uU29ydCh7XG4gICAgICAgICAgICAgICAgLi4uc29ydENvbHVtbixcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IHNvcnRDb2x1bW4uZGlyZWN0aW9uID09PSBcImFzY1wiID8gXCJkZXNjXCIgOiBcImFzY1wiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblNvcnQoe1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcImFzY1wiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy8gRnVuY3Rpb25zXG4vLyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLlxuXG4vLyBmdW5jdGlvbiByZW5kZXJTb3J0SWNvbih7IGNvbHVtbiwgc29ydENvbHVtbiB9KSB7XG4vLyAgICAgaWYgKCFjb2x1bW4ucGF0aCB8fCBjb2x1bW4ucGF0aCAhPT0gc29ydENvbHVtbi5wYXRoKSByZXR1cm4gbnVsbDtcbi8vICAgICBjb25zdCBjbGFzc2VzID0gYGZhIGZhLXNvcnQtJHtzb3J0Q29sdW1uLmRpcmVjdGlvbn1gO1xuLy8gICAgIHJldHVybiA8aSBjbGFzc05hbWU9e2NsYXNzZXN9IC8+O1xuLy8gfVxuIiwiZXhwb3J0IHsgVGFibGUgfSBmcm9tIFwiLi9UYWJsZVwiO1xuIiwiaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmNvbnN0IFZhcmlhbnQgPSB7XG4gICAgVGl0bGU6IFwiVGl0bGVcIixcbiAgICBTdWJ0aXRsZTogXCJTdWJ0aXRsZVwiLFxuICAgIFNlY3Rpb25UaXRsZTogXCJTZWN0aW9uVGl0bGVcIixcbiAgICBTZWN0aW9uU3VidGl0bGU6IFwiU2VjdGlvblN1YnRpdGxlXCIsXG4gICAgUGFyYWdyYXBoOiBcIlBhcmFncmFwaFwiLFxuICAgIFNwYW46IFwiU3BhblwiLFxufTtcblxuY29uc3QgVGFnID0ge1xuICAgIFtWYXJpYW50LlRpdGxlXTogXCJoMVwiLFxuICAgIFtWYXJpYW50LlN1YnRpdGxlXTogXCJoMlwiLFxuICAgIFtWYXJpYW50LlNlY3Rpb25UaXRsZV06IFwiaDNcIixcbiAgICBbVmFyaWFudC5TZWN0aW9uU3VidGl0bGVdOiBcImg0XCIsXG4gICAgW1ZhcmlhbnQuUGFyYWdyYXBoXTogXCJwXCIsXG4gICAgW1ZhcmlhbnQuU3Bhbl06IFwic3BhblwiLFxufTtcblxuY29uc3QgVGFnQ2xhc3NOYW1lID0ge1xuICAgIFtWYXJpYW50LlRpdGxlXTogXCJjb250ZW50X190aXRsZVwiLFxuICAgIFtWYXJpYW50LlN1YnRpdGxlXTogXCJjb250ZW50X19zdWJ0aXRsZVwiLFxuICAgIFtWYXJpYW50LlNlY3Rpb25UaXRsZV06IFwiY29udGVudF9fc2VjdGlvbi10aXRsZVwiLFxuICAgIFtWYXJpYW50LlNlY3Rpb25TdWJ0aXRsZV06IFwiY29udGVudF9fc2VjdGlvbi1zdWJ0aXRsZVwiLFxuICAgIFtWYXJpYW50LlBhcmFncmFwaF06IFwiY29udGVudF9fcGFyYWdyYXBoXCIsXG4gICAgW1ZhcmlhbnQuU3Bhbl06IFwiXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVGV4dENvbG9yID0ge1xuICAgIFBvc2l0aXZlOiBcInBvc2l0aXZlXCIsXG4gICAgQnJhbmQ6IFwiYnJhbmRcIixcbiAgICBXYXJuaW5nOiBcIndhcm5pbmdcIixcbiAgICBJbXBvcnRhbnQ6IFwiaW1wb3J0YW50XCIsXG4gICAgQXBwcm92ZWQ6IFwiYXBwcm92ZWRcIixcbiAgICBNdXRlZDogXCJtdXRlZFwiLFxuICAgIFBhbGU6IFwicGFsZVwiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRleHRTaXplID0ge1xuICAgIEJpZzogXCJiaWdcIixcbiAgICBTbWFsbDogXCJzbWFsbFwiLFxuICAgIFNtYWxsZXI6IFwic21hbGxlclwiLFxufTtcblxuY29uc3QgVGV4dCA9ICh7IHZhcmlhbnQgPSBWYXJpYW50LlNwYW4sIGNvbG9yLCBzaXplLCBzdHJvbmcsIHVwcGVyLCBjbGFzc05hbWUsIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBUYWdOYW1lID0gVGFnW3ZhcmlhbnRdO1xuICAgIGNvbnN0IHRhZ0NsYXNzTmFtZSA9IFRhZ0NsYXNzTmFtZVt2YXJpYW50XTtcblxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBjbihcbiAgICAgICAgdGFnQ2xhc3NOYW1lLFxuICAgICAgICB7XG4gICAgICAgICAgICBbYGNvbnRlbnRfJHtzaXplfWBdOiBzaXplLFxuICAgICAgICAgICAgW2Bjb250ZW50XyR7Y29sb3J9YF06IGNvbG9yLFxuICAgICAgICAgICAgY29udGVudF9zdHJvbmc6IHN0cm9uZyxcbiAgICAgICAgICAgIGNvbnRlbnRfdXBwZXI6IHVwcGVyLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICApO1xuXG4gICAgcmV0dXJuIDxUYWdOYW1lIGNsYXNzTmFtZT17Y2xhc3NOYW1lc30gey4uLnByb3BzfSAvPjtcbn07XG5cbmV4cG9ydCBjb25zdCBUaXRsZSA9IChwcm9wcykgPT4gPFRleHQgey4uLnByb3BzfSB2YXJpYW50PXtWYXJpYW50LlRpdGxlfSAvPjtcbmV4cG9ydCBjb25zdCBTdWJ0aXRsZSA9IChwcm9wcykgPT4gPFRleHQgey4uLnByb3BzfSB2YXJpYW50PXtWYXJpYW50LlN1YnRpdGxlfSAvPjtcbmV4cG9ydCBjb25zdCBTZWN0aW9uVGl0bGUgPSAocHJvcHMpID0+IDxUZXh0IHsuLi5wcm9wc30gdmFyaWFudD17VmFyaWFudC5TZWN0aW9uVGl0bGV9IC8+O1xuZXhwb3J0IGNvbnN0IFNlY3Rpb25TdWJ0aXRsZSA9IChwcm9wcykgPT4gPFRleHQgey4uLnByb3BzfSB2YXJpYW50PXtWYXJpYW50LlNlY3Rpb25TdWJ0aXRsZX0gLz47XG5leHBvcnQgY29uc3QgUGFyYWdyYXBoID0gKHByb3BzKSA9PiA8VGV4dCB7Li4ucHJvcHN9IHZhcmlhbnQ9e1ZhcmlhbnQuUGFyYWdyYXBofSAvPjtcbmV4cG9ydCBjb25zdCBTcGFuID0gKHByb3BzKSA9PiA8VGV4dCB7Li4ucHJvcHN9IHZhcmlhbnQ9e1ZhcmlhbnQuU3Bhbn0gLz47XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9UZXh0XCI7XG4iLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyB1c2VGb3JtQ29udHJvbFJlZiB9IGZyb20gXCIuLi8uLi9ob29rc1wiO1xuXG5jb25zdCBUZXh0YXJlYSA9IG1lbW8oXG4gICAgZm9yd2FyZFJlZigoeyB2YWx1ZSwgdGl0bGUsIGVycm9yLCB3eXNpd3lnLCBvbkNoYW5nZSwgY2xhc3NOYW1lLCAuLi50ZXh0YXJlYVByb3BzIH0sIGV4dFJlZikgPT4ge1xuICAgICAgICBjb25zdCB7IHJlZiwgY2FsbGJhY2tSZWYgfSA9IHVzZUZvcm1Db250cm9sUmVmKGV4dFJlZiwgKGVsKSA9PiAoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gZWwudmFsdWUsXG4gICAgICAgICAgICBzZXRWYWx1ZTogKHZhbHVlID0gXCJcIikgPT4ge1xuICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8hIHNldEVycm9yP1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICR0ZXh0YXJlYSA9ICQocmVmLmN1cnJlbnQuZWwpO1xuXG4gICAgICAgICAgICBpZiAod3lzaXd5Zykgd2luZG93LmluaXRXWVNJV1lHKCR0ZXh0YXJlYSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7fTsgLy8gdG9kb1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgbGFiZWxDbGFzc05hbWVzID0gY24oXCJ0ZXh0YXJlYVwiLCB7IHRleHRhcmVhX2Vycm9yOiBlcnJvciB9LCBjbGFzc05hbWUpO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgb25DaGFuZ2UodmFsdWUsIGV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT17bGFiZWxDbGFzc05hbWVzfT5cbiAgICAgICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtjYWxsYmFja1JlZn1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0YXJlYV9fY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgIHsuLi50ZXh0YXJlYVByb3BzfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAge3RpdGxlICYmIDxzcGFuIGNsYXNzTmFtZT1cInRleHRhcmVhX190aXRsZVwiPnt0aXRsZX08L3NwYW4+fVxuICAgICAgICAgICAgICAgIHtlcnJvciAmJiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0YXJlYV9fZXJyb3JcIj57ZXJyb3J9PC9zcGFuPn1cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICk7XG4gICAgfSlcbik7XG5cbmV4cG9ydCB7IFRleHRhcmVhIH07XG4iLCJleHBvcnQgeyBUZXh0YXJlYSB9IGZyb20gXCIuL1RleHRhcmVhXCI7XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbi8vIHRvZG86IGFkZCBleHQgcmVmID9cbi8vIHRvZG86IHByb2dyYW1tYXRpYyBjYWxsXG4vLyB0b2RvOiBodG1sIGluIHRvb2x0aXBcblxuLy8gY29uc3QgVG9vbHRpcFBsYWNlbWVudCA9IHt9O1xuXG5leHBvcnQgY29uc3QgVG9vbHRpcCA9IG1lbW8oXG4gICAgKHsgY2xhc3NOYW1lLCB0b29sdGlwLCBwbGFjZW1lbnQgPSBcImF1dG9cIiwgb3B0aW9ucyA9IHt9LCB0b2dnbGUsIHRoZW1lLCBoYW5kbGVyLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHVzZVJlZigpO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBzaG93VG9vbHRpcCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmluaXRUb29sVGlwKCQoZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvZG86IGRlc3Rvcnk/Pz9cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgc2hvd1Rvb2x0aXApO1xuICAgICAgICB9LCBbb3B0aW9uc10pO1xuXG4gICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgLi4uKHRvZ2dsZSAmJiB7IFwiZGF0YS10b29sdGlwLXRvZ2dsZVwiOiB0cnVlIH0pLFxuICAgICAgICAgICAgLi4uKHRoZW1lICYmIHsgXCJkYXRhLXRvb2x0aXAtdGhlbWVcIjogdGhlbWUgfSksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNuKGNsYXNzTmFtZSwgeyB0b29sdGlwX19oYW5kbGVyOiBoYW5kbGVyIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICBkYXRhLXRvb2x0aXA9e3Rvb2x0aXB9XG4gICAgICAgICAgICAgICAgZGF0YS1wbGFjZW1lbnQ9e3BsYWNlbWVudH1cbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLmF0dHJzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICB9XG4pO1xuIiwiZXhwb3J0IHsgVG9vbHRpcCB9IGZyb20gXCIuL1Rvb2x0aXBcIjtcbiIsImltcG9ydCB7IENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gdG9kbzog0L3QsNGB0YLRgNC+0LjRgtGMINC+0YLQvtCx0YDQsNC20LXQvdC40LUg0LrQu9Cw0YHRgdC+0LIgY3NzLdC80L7QtNGD0LvQtdC5INCy0L4g0LLQutC70LDQtNC10LogRWxlbWVudHMg0L/RgNC4INC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC4IFNCINC4INCyIHByb2R1Y3Rpb25cblxuZXhwb3J0IGNvbnN0IFZTdGFjayA9ICh7IGdhcCA9IDAsIGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW5XaXRoR2FwID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGNoaWxkO1xuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSA9IFwiXCIgfSA9IHByb3BzO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPT09IGxlbmd0aCAtIDE7XG5cbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgLi4uY2hpbGQucHJvcHMsXG4gICAgICAgICAgICAuLi4oIWlzTGFzdCAmJiB7IGNsYXNzTmFtZTogYCR7Y2xhc3NOYW1lfSBtYi0ke2dhcH1gIH0pLFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHRvZG86IGlzIG5lZWQgZWxlbWVudCBkaXY/IChjYW4gYmUgPD4gPylcbiAgICByZXR1cm4gPGRpdiB7Li4ucHJvcHN9PntjaGlsZHJlbldpdGhHYXB9PC9kaXY+O1xufTtcblxuLy8gZXhwb3J0IGNvbnN0IFZTdGFjayA9ICh7IGdhcCA9IDAsIGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiB7XG4vLyAgICAgcmV0dXJuIChcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NuKGNscy5mbGV4KX0gey4uLnByb3BzfT5cbi8vICAgICAgICAgICAgIHtjaGlsZHJlbn1cbi8vICAgICAgICAgPC9kaXY+XG4vLyAgICAgKTtcbi8vIH07XG5cbi8vIGV4cG9ydCBjb25zdCBIU3RhY2sgPSAoeyBjaGlsZHJlbiwgZ2FwID0gMCB9KSA9PiB7XG4vLyAgICAgY29uc3QgY2hpbGRyZW5XaXRoR2FwID0gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KSA9PiB7XG4vLyAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGNoaWxkO1xuLy8gICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSA9IFwiXCIgfSA9IHByb3BzO1xuXG4vLyAgICAgICAgIC8vIGNvbnN0IGxlbmd0aCA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbi8vICAgICAgICAgLy8gY29uc3QgaXNMYXN0ID0gaW5kZXggPT09IGxlbmd0aCAtIDE7XG5cbi8vICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuLy8gICAgICAgICAgICAgLi4uY2hpbGQucHJvcHMsXG4vLyAgICAgICAgICAgICAuLi4oIWlzTGFzdCAmJiB7IGNsYXNzTmFtZTogYCR7Y2xhc3NOYW1lfSBtbC0ke2dhcH1gIH0pLFxuLy8gICAgICAgICB9KTtcbi8vICAgICB9KTtcblxuLy8gICAgIHJldHVybiA8ZGl2PntjaGlsZHJlbldpdGhHYXB9PC9kaXY+O1xuLy8gfTtcbiIsImV4cG9ydCB7IFZTdGFjayB9IGZyb20gXCIuL1ZTdGFja1wiO1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vQXZhdGFyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CYWRnZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQm94XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CdXR0b25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NhcmRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NoZWNrYm94XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EYXRlSW5wdXRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0RlZmluaXRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Ecm9wZG93blwiO1xuZXhwb3J0ICogZnJvbSBcIi4vRmlsZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vRmlsZUxpc3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0Zvcm1cIjtcbmV4cG9ydCAqIGZyb20gXCIuL0dyaWRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0dyb3VwQ29udGFpbmVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9JbnB1dFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vTGlzdFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vTG9hZGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Nb2RhbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vTm90aWZpY2F0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9QYWdpbmF0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Qb3J0YWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1JhZGlvXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9TZWxlY3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1NlcGFyYXRvclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vU3RhdHVzXCI7XG4vLyB0b2RvOiB1c2UgdmFyaWFudCB3aXRoIG1vZGlmeWluZyBjaGlsZHJlbiBjbGFzc2VzIHdpdGggbWIteFxuLy8gZXhwb3J0ICogZnJvbSBcIi4vU3RhY2tcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1RhYmxlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9UZXh0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9UZXh0YXJlYVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vVG9vbHRpcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vVlN0YWNrXCI7XG4iLCJleHBvcnQgeyB1c2VGb3JtIH0gZnJvbSBcIi4vdXNlRm9ybVwiO1xuZXhwb3J0IHsgdXNlRm9ybUNvbnRyb2xSZWYgfSBmcm9tIFwiLi91c2VGb3JtQ29udHJvbFJlZlwiO1xuZXhwb3J0IHsgdXNlUHJveHlTdGF0ZSB9IGZyb20gXCIuL3VzZVByb3h5U3RhdGVcIjtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsUmVmKHJlZiwgbm9kZSkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJiByZWYgJiYgXCJjdXJyZW50XCIgaW4gcmVmKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICB9XG59XG5cbi8qKlxuICogTWVyZ2UgcmVmcyBpbnRvIG9uZSByZWYgZnVuY3Rpb24gdG8gc3VwcG9ydCByZWYgcGFzc2luZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VSZWYoLi4ucmVmcykge1xuICAgIGNvbnN0IHJlZkxpc3QgPSByZWZzLmZpbHRlcigocmVmKSA9PiByZWYpO1xuXG4gICAgaWYgKHJlZkxpc3QubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlZkxpc3RbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChub2RlKSA9PiB7XG4gICAgICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICAgICAgICBmaWxsUmVmKHJlZiwgbm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbn1cbiIsImV4cG9ydCB7IHVzZUVsZW1lbnRSZWYgfSBmcm9tIFwiLi91c2VFbGVtZW50UmVmXCI7XG5leHBvcnQgeyBjb21wb3NlUmVmIH0gZnJvbSBcIi4vY29tcG9zZVJlZlwiO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vKipcbiAqIHRvZG9cbiAqIEBwYXJhbSB7Kn0gZXh0UmVmXG4gKi9cbi8vIHRvZG86INGB0LTQtdC70LDRgtGMINC10LTQuNC90YPRjiDRgtC+0YfQutGDINGN0LrQv9C+0YDRgtCwINC00LvRjyBob29rc1xuLy8gdG9kbzogcmV0dXJuICRlbCA/Pz9cbi8vIHRvZG86IHJlbmFtZSA9PiB1c2VFbGVtZW50XG4vLyB0b2RvITogcmVwbGFjZSB3aXRoIGNvbXBvc2VSZWYgPz8/XG5leHBvcnQgY29uc3QgdXNlRWxlbWVudFJlZiA9IChleHRSZWYpID0+IHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoKTtcblxuICAgIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKGVsKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gZWw7XG5cbiAgICAgICAgaWYgKCFleHRSZWYpIHJldHVybjtcblxuICAgICAgICBpZiAodHlwZW9mIGV4dFJlZiA9PT0gXCJmdW5jdGlvblwiKSBleHRSZWYoZWwpO1xuICAgICAgICBlbHNlIGV4dFJlZi5jdXJyZW50ID0gZWw7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gdG9kbzogcm1cbiAgICBpZiAoIU9iamVjdC5oYXNPd24ocmVmLCBcImVsXCIpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWYsIFwiZWxcIiwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHRvZG86IHJtXG4gICAgaWYgKCFPYmplY3QuaGFzT3duKHJlZiwgXCIkZWxcIikpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZiwgXCIkZWxcIiwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IGNhY2hlIGdldCAkZWxcbiAgICAgICAgICAgICAgICByZXR1cm4gJChyZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZWYsXG4gICAgICAgIHJlZkNhbGxiYWNrLFxuICAgIH07XG59O1xuIiwiZXhwb3J0IHsgdXNlRm9ybSB9IGZyb20gXCIuL3VzZUZvcm1cIjtcbiIsImltcG9ydCAqIGFzIHl1cCBmcm9tIFwieXVwXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZVByb3h5U3RhdGUgfSBmcm9tIFwiLi4vdXNlUHJveHlTdGF0ZVwiO1xuXG4vLyB0b2RvOiBzY2hlbWEgc2hvdWxkIGJlIG9wdGlvbmFsXG4vLyB0b2RvOiB1c2VDYWxsYmFja3Ncbi8vIHRvZG86IGlmIHNlbGVjdDptdWx0aXBsZSA9PiB2YWxpZGF0ZSBmaWVsZCBhbmQgY3JlYXRlIGVycm9ycyBvbiBjbG9zZSBkcm9wZG93biAo0YfRgtC+0LHRiyDQv9GA0Lgg0LLRi9Cx0L7RgNC1INC+0YLQtNC10LvRjNC90YvRhSDQv9GD0L3QutGC0L7QsiDQvdC1INC/0LXRgNC10YDQtdC00LjRgNCy0LDQu9GB0Y8g0YHQtdC70LXQutGCINC40Lct0LfQsCDQstC+0LfQstC+0LbQvdC+0Lkg0L7RiNC40LHQutC4INCy0LDQu9C40LTQsNGG0LjQuClcbi8vIHRvZG86IGZvY3VzIG9uIGZpcnN0IGZvcm0gZWxlbWVudCBpbml0aWFsbHlcbi8vIHRvZG86IHdoYXQgaWYgY29udHJvbCB1bm1vdW50ZWQgKHNlZSBSSEYpOiB1cGRhdGUgcmVmU3RvcmUsIHNjaGVtYSBldGMuXG4vLyB0b2RvOiBwcm9jZXNzIG1vdW50L3Vub3VudCBjb21wb25lbnRzICh0dW5lIHN0YXRlLCBzY2hlbWEpXG4vLyB0b2RvOiDQvdGD0LbQvdCwINC40L3RgdGC0YDRg9C60YbQuNGPINC/0L4g0LTQvtCx0LDQstC70LXQvdC40Y4g0L3QvtCy0L7Qs9C+INC60L7QvdGC0YDQvtC70LAsINGB0L7QstC80LXRgdGC0LjQvNC+0LPQviDRgSB1c2VGb3JtXG4vLyB0b2RvOiDRgdC00LXQu9Cw0YLRjCBzdG9yeSB1c2VGb3JtINGB0L4g0LLRgdC10LzQuCDQutC+0L3RgtGA0L7Qu9Cw0LzQuFxuLy8gdG9kbzogaG93IHRvIHByb2Nlc3MgZGlzYWJsZWQgZmllbGRzXG4vLyB0b2RvOiByZXNldCBzaW5nbGUgZmllbGRcbi8vIHRvZG86IHNldCBzaW5nbGUgZmllbGRcbi8vIHRvZG86IHZhbGlkYXRlIG9uQmx1ciBmbGFnXG4vLyB0b2RvOiBjaGVjayB1c2VGb3JtIHdpdGggb3V0ZXIgbGliIGNvbXBvbmVudHMgcmVhY3Qtc2VsZWN0LCByZWFjdC1kYXRlcGlja2VyXG4vLyB0b2RvOiBzY3JvbGwgdG8gZmlyc3QgZXJyb3IgKCsgZmxhdCBzY3JvbGxUb0ZpcnN0RXJyb3IsIGFuZCBmb2N1cz8pXG4vLyB0b2RvOiBmb2N1cyBvbiBmaXJzdCBlcnJvclxuLy8gdG9kbzogYWJpbGl0eSB0byBhZGQgaGlkZGVuIG5vIHZhbGlkYXRlIGZpbGVkcz9cbi8vIHRvZG86IG12IHRvIGhvb2tzIHV0aWxzXG4vLyB0b2RvOiBjcmVhdGUgZ2V0VmFsdWVzIHRvIGdldCBhbGwgZm9ybSB2YWx1ZXMgd2l0aG91dCByZXJlbmRlcnMgYW5kIHN1YnNjcmlwdGlvblxuLy8gdG9kbzogY2hlY2sgY2FzZSB3aXRoIG5lc3RlZCBkYXRhIG9iamVjdCAobm90IGZsYXQpXG4vLyB0b2RvOiBmbGFnIHVucmVnaXN0ZXJPblVubW91bnRcbi8vIHRvZG86IGNhc2Ugb2YgZGVlcGx5IG5lc3RlZCBjb21wb25lbnRzIGluIGZvcm0gKG5lZWQgY29udGV4dD8pXG4vLyB0b2RvOiBjaGVjayByZXJlbmRlcnMgYW5kIG1ha2Ugc3RvcnkgZm9yIGl0XG4vLyB0b2RvOiBhZGQgY29udHJvbHM6IFJhbmdlLCBTZWxlY3RMaXN0IChzb3J0aW5nLCBhZGQsIGRlbGV0ZSwuLi4pLCAuLi5cbi8vIHRvZG86IHRlc3Qgd2l0aCBGaWxlLCBGaWxlTGlzdFxuLy8gdG9kbzog0LLRi9C00LXQu9C40YLRjCDQsiBTQiDQuNC90L/Rg9GC0Ysg0L7RgtC00LXQu9GM0L3QvlxuLy8gdG9kbzogc2hvdWxkIGhhdmUgc2V0RXJyb3IgaW4gcmVmPyAobGlrZSBzZXRWYWx1ZSwgZ2V0VmFsdWUpXG4vLyB0b2RvOiB2YWxpZGF0ZSBvbiBpbml0ID9cbi8vIHRvZG8hOiBjYXNlIG9mIGR5bmFtaWNhbGx5IGFkZGVkL3JlbW92ZWQgYXJyYXktbGlrZSBmb3JtIGZpZWxkcyAoYW5hbG9nIG9mIHVzZUFycmF5RmllbGQpXG4vLyB0b2RvITogY2FzZSBvZiBuZXN0ZWQgZm9ybSBvYmplY3Qgb2YgdmFsdWVzIChub3QgZmxhdCBhcyBub3cpXG5cbi8vISBub3RlOiDQv9GA0LXQuNC80YPRidC10YHRgtCy0L4gLSDRhdGD0Log0L3QuNGH0LXQs9C+INC90LUg0LfQvdCw0LXRgiDQv9GA0L4g0YLQuNC/0Ysg0LrQvtC90YLRgNC+0LvQvtCyICjQtNC70Y8g0LTQvtC60YPQvNC10L3RgtCw0YbQuNC4KVxuXG4vLyAgIGNvbnN0IGdldCA9IChvYmosIG5hbWUsIGRlZmF1bHRWYWx1ZSkgPT4ge307XG5cbi8vICFUT0RPOiBjcmVhdGUgVFdPIHJlZnM6IG1haW5FbCwgaW5wdXRFbFxuLy8gIVRPRE86INC/0L7QvNC10YHRgtC40YLRjCBuYW1lINCyIHJlZj9cblxuY29uc3QgaXNVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbmV4cG9ydCBjb25zdCB1c2VGb3JtID0gKHsgZGVmYXVsdFZhbHVlcyA9IHt9LCBzY2hlbWEgfSA9IHt9KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCLimqEgdXNlRm9ybTogcmVuZGVyXCIpO1xuXG4gICAgY29uc3QgcmVmU3RvcmUgPSB1c2VSZWYoe30pO1xuXG4gICAgLy8gY29uc3QgcmVnaXN0ZXJPcmRlciA9IFtdO1xuXG4gICAgY29uc3QgW3ZhbHVlcywgc2V0VmFsdWVzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCBbZXJyb3JzLCBzZXRFcnJvcnNdID0gdXNlU3RhdGUoe30pO1xuXG4gICAgY29uc3QgX25hbWVzID0gdXNlTWVtbyhcbiAgICAgICAgKCkgPT4gKHtcbiAgICAgICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaEFsbDogZmFsc2UsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICAvLyB0b2RvOiBmb3JtU3RhdGUgc2hvdWxkIGJlIHByb3hpZWRcbiAgICAvLyB0b2RvOiBjYXNlIG9mIGVycm9yIG5vdCByZWFkZWQgPz8/XG4gICAgLy8gdG9kbzogc2V0IGRlZmF1bHQgdmFsdWVzIHRvIHdhdGNoZWQgZmllbGRzXG4gICAgY29uc3Qge1xuICAgICAgICAvLyBzdGF0ZTogZm9ybVN0YXRlLFxuICAgICAgICBwcm94eVN0YXRlOiBwcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IHVwZGF0ZUZvcm1TdGF0ZSxcbiAgICB9ID0gdXNlUHJveHlTdGF0ZSh7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsIC8vIHRvZG8hOiBjYWxjdWxhdGUgaW5pdGlhbGx5ICh1c2UgZnVuYyBhcmd1bWVudCkgZG8gaXQgc2lsZW50bHkgKGRvbid0IHNob3cgZXJyb3IgbWVzc2FnZXMgYmVmb3JlIHN1Ym1pdCBidXR0b24gaXMgY2xpY2tlZClcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBkaXJ0eTogLi4uLFxuICAgICAgICAvLz8gZXJyb3JzOiAuLi5cbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHRWYWx1ZXMoeyBpbml0OiB0cnVlIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldERlZmF1bHRWYWx1ZXMgPSAoeyBpbml0ID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhyZWZTdG9yZS5jdXJyZW50KSkge1xuICAgICAgICAgICAgLy8gbm90ZTogZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlc1tuYW1lXSB8fCBpbm5lckRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgY29uc3QgeyBzZXRWYWx1ZSwgZGVmYXVsdFZhbHVlIH0gPSByZWZTdG9yZS5jdXJyZW50W25hbWVdO1xuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHRlcm5hbERlZmF1bHRWYWx1ZSA9ICFpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWVzW25hbWVdKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNldERlZmF1bHRWYWx1ZSA9ICFpbml0IHx8IChpbml0ICYmIGhhc0V4dGVybmFsRGVmYXVsdFZhbHVlKTtcblxuICAgICAgICAgICAgLy8gdG9kbzogZG9uJ3Qgc2V0IGRlZmF1bHQgdmFsdWUgaWYgY3VycmVudCB2YWx1ZSBkaWRuJ3QgY2hhbmdlXG5cbiAgICAgICAgICAgIGlmIChzaG91bGRTZXREZWZhdWx0VmFsdWUpIHNldFZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVzZXRWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhyZWZTdG9yZS5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgeyBzZXRWYWx1ZSB9ID0gcmVmU3RvcmUuY3VycmVudFtuYW1lXTtcbiAgICAgICAgICAgIHNldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVzZXRFcnJvcnMgPSAoKSA9PiBzZXRFcnJvcnMoe30pO1xuXG4gICAgY29uc3QgZ2V0RGF0YSA9ICgpID0+XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJlZlN0b3JlLmN1cnJlbnQpLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIFtuYW1lLCB7IGdldFZhbHVlIH1dKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICBbbmFtZV06IGdldFZhbHVlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHt9XG4gICAgICAgICk7XG4gICAgW107XG5cbiAgICBjb25zdCBnZXRTY2hlbWEgPSAoKSA9PlxuICAgICAgICBPYmplY3QuZW50cmllcyhyZWZTdG9yZS5jdXJyZW50KS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjLCBbbmFtZSwgeyBzY2hlbWEgfV0pID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgICAgIFtuYW1lXTogc2NoZW1hLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7fVxuICAgICAgICApO1xuXG4gICAgLy8gdG9kbzogZXh0cmFjdCBhcyB1dGlsXG4gICAgY29uc3QgdmFsaWRhdGUgPSAoZGF0YSwgc2NoZW1hKSA9PiB5dXAub2JqZWN0KHNjaGVtYSkudmFsaWRhdGUoZGF0YSwgeyBhYm9ydEVhcmx5OiB0cnVlIH0pO1xuXG4gICAgY29uc3QgdmFsaWRhdGVGaWVsZCA9IGFzeW5jIChuYW1lLCB7IHNob3VsZFVwZGF0ZVZhbHVlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2V0VmFsdWUsIHNjaGVtYSB9ID0gcmVmU3RvcmUuY3VycmVudFtuYW1lXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZSgpO1xuXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVPYmogPSB7IFtuYW1lXTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFPYmogPSB7IFtuYW1lXTogc2NoZW1hIH07XG5cbiAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZSh2YWx1ZU9iaiwgc2NoZW1hT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeyBtZXNzYWdlIH0pIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlcygodmFsdWVzKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBbbmFtZV06IHZhbHVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbzog0YDQsNC30L7QsdGA0LDRgtGM0YHRjyDRgSDQu9C40YjQvdC40Lwg0YDQtdC90LTQtdGA0L7QvFxuICAgICAgICAvLyB0b2RvOiBcIjFcIiAtPiBcIlwiIC0+IFwiMVwiIC0+IFwiMTFcIiAocmVuZGVyIGhlcmUpXG4gICAgICAgIC8vIHRvZG86IHJlbW92ZSBlcnJvciBmaWVsZCBpZiBubyBlcnJvciBjYXNlXG4gICAgICAgIHNldEVycm9ycygocHJldkVycm9ycykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VyckVycm9yTWVzc2FnZSA9IHByZXZFcnJvcnNbbmFtZV0gfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZUVycm9yID0gZXJyb3JNZXNzYWdlICE9PSBjdXJyRXJyb3JNZXNzYWdlO1xuXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkVXBkYXRlRXJyb3JcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5wcmV2RXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgIFtuYW1lXTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogcHJldkVycm9ycztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9ICFoYXNFcnJvcnMoeyAuLi5lcnJvcnMsIFtuYW1lXTogZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgICB1cGRhdGVGb3JtU3RhdGUoXCJpc1ZhbGlkXCIsIGlzVmFsaWQpO1xuICAgIH07XG5cbiAgICAvLyDQuNGB0LrQu9GO0YfQuNGC0Ywg0LvQuNGI0L3QuNC1INGA0LXQvdC00LXRgNGLINC/0YDQuCDQstCw0LvQuNC00LDRhtC40LhcbiAgICAvLyB1bnJlZ2lzdGVyIGZpZWxkINC/0YDQuCDQtNC10LzQvtC90YLQuNGA0L7QstCw0L3QuNC4INC60L7QvNC/0L7QvdC10L3RgtCwXG4gICAgLy8g0L/RgNC+0LLQtdGA0LjRgtGMLCDRh9GC0L4g0YHRhdC10LzQsCDQvdCw0YHRgtGA0LjQstCw0LXRgtGB0Y8g0LDQstGC0L7QvNCw0YLQuNGH0LXRgdC60LhcbiAgICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKGFzeW5jICh2YWx1ZSwgZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0OiB7IG5hbWUgfSxcbiAgICAgICAgfSA9IGV2ZW50O1xuXG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbHVlID0gX25hbWVzLndhdGNoQWxsIHx8IF9uYW1lcy53YXRjaC5oYXMobmFtZSk7XG4gICAgICAgIHZhbGlkYXRlRmllbGQobmFtZSwgeyBzaG91bGRVcGRhdGVWYWx1ZSB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBjb25zdCBvbkJsdXIgPSB1c2VDYWxsYmFjaygoeyB0YXJnZXQ6IHsgbmFtZSB9IH0pID0+IHtcbiAgICAvLyAgICAgLy8hIHZhbGlkYXRlIHRyaWdnZXJzIHJlZHVuZGFudCByZW5kZXJcbiAgICAvLyAgICAgLy8gdmFsaWRhdGVGaWVsZChuYW1lKTtcbiAgICAvLyB9LCBbXSk7XG5cbiAgICAvLyB0b2RvOiByZXNldCBzaG91bGQgd29yayBmb3Igbm8gZGVmYXVsdFZhbHVlcyBjYXNlIChyZXNldCB0byBjbGVhciBmb3JtKVxuICAgIC8vIHRvZG86IGNsZWFyIGZvcm0gbWV0aG9kIGlzIG5lZWRlZCB0byAoYW5kIGNsZWFyIHNpbmdsZSBmaWVsZClcbiAgICAvLyB0b2RvOiByZXNldC9jbGVhci9jbGVhckVycm9yIGZvciBzaW5nbGUgZmllbGRcbiAgICBjb25zdCByZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0RGVmYXVsdFZhbHVlcygpO1xuICAgICAgICByZXNldEVycm9ycygpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNsZWFyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXNldFZhbHVlcygpO1xuICAgICAgICByZXNldEVycm9ycygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIHVzZSBzdGFibGUgY2FsbGJhY2sgZm9yIGV2ZXJ5IG5hbWVcbiAgICAvLyDQuNC90LDRh9C1INC/0YDQvtC40YHQutC+0LTQuNGCINC00LLQvtC50L3QvtC5INCy0YvQt9C+0LIgcmVmIGNhbGxiYWNrIChudWxsICgxKSA9PiBub2RlICgyKSlcbiAgICAvLyB0b2RvOiB1c2UgcmVmU3RvcmVcbiAgICAvLz8hIGlzIG5lZWRlZCBlbCBpbiByZWYgb2JqZWN0XG4gICAgY29uc3QgZ2V0Q2FsbGJhY2tSZWYgPSAobmFtZSkgPT4gKHJlZikgPT4ge1xuICAgICAgICAvLyB1bnJlZ2lzdGVyXG4gICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVmU3RvcmUuY3VycmVudFtuYW1lXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlZ2lzdGVyXG4gICAgICAgIGNvbnN0IGV4dGVybmFsRGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaW5uZXJEZWZhdWx0VmFsdWUgPSByZWYuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBub3RlOiBkZWZhdWx0VmFsdWUgY2FuIGJlIG51bGxcbiAgICAgICAgY29uc3QgaGFzRXh0ZXJuYWxEZWZhdWx0VmFsdWUgPSAhaXNVbmRlZmluZWQoZXh0ZXJuYWxEZWZhdWx0VmFsdWUpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVmU3RvcmUuY3VycmVudFtuYW1lXSwgcmVmLCB7XG4gICAgICAgICAgICBzY2hlbWE6IHNjaGVtYT8uW25hbWVdID8/IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGhhc0V4dGVybmFsRGVmYXVsdFZhbHVlID8gZXh0ZXJuYWxEZWZhdWx0VmFsdWUgOiBpbm5lckRlZmF1bHRWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUpID0+IHtcbiAgICAgICAgLy8gdG9kbzogcmVmYWN0b3JcbiAgICAgICAgLy8gdG9kbzogdXNlIGRlZXAgc2V0XG4gICAgICAgIC8vIG5vdGU6INC+0LHQtdGB0L/QtdGH0LjQstCw0LXQvCDRgdGC0LDQsdC40LvRjNC90L7RgdGC0Ywg0YHRgdC70LrQuCDQvdCwIGNhbGxiYWNrUmVmXG4gICAgICAgIGlmICghcmVmU3RvcmUuY3VycmVudFtuYW1lXSkgcmVmU3RvcmUuY3VycmVudFtuYW1lXSA9IHt9OyAvLyEgRFJZXG4gICAgICAgIGlmICghcmVmU3RvcmUuY3VycmVudFtuYW1lXS5yZWZDYWxsYmFjaykge1xuICAgICAgICAgICAgcmVmU3RvcmUuY3VycmVudFtuYW1lXS5yZWZDYWxsYmFjayA9IGdldENhbGxiYWNrUmVmKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IG5hbWVzIHRvIHdhdGNoXG4gICAgICAgIGlmIChfbmFtZXMud2F0Y2hBbGwpIF9uYW1lcy53YXRjaC5hZGQobmFtZSk7XG5cbiAgICAgICAgY29uc3QgcmVnaXN0ZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICByZWY6IHJlZlN0b3JlLmN1cnJlbnRbbmFtZV0ucmVmQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgIC8vIG9uQmx1cixcbiAgICAgICAgICAgIC8vIHRvZG86INC10YHQu9C4INC90LXRgiDRgdGF0LXQvNGLINCy0LDQu9C40LTQsNGG0LjQuCwg0YLQviDQuCDQvtGI0LjQsdC60YMg0L3QtSDQv9C10YDQtdC00LDQstCw0YLRjFxuICAgICAgICAgICAgLy8gdG9kbzogdXNlIHNob3VsZEV4cG9zZUVycm9yXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JzW25hbWVdLCAvLyB0b2RvOiDQvtGC0LTQsNCy0LDRgtGMINC+0YjQuNCx0LrRgywg0LXRgdC70LggaXNTdWJtaXR0ZWQ6IHRydWUg0LjQu9C4IGlzVmFsaWQ6IGlzVXNlZFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZWdpc3RlclByb3BzO1xuICAgIH07XG5cbiAgICAvLyB1c2VDYWxsYmFjaz8/P1xuICAgIC8vIHRvZG86IHVuaWZ5IHZhbGlkYXRpb24gZnVsbCBvYmplY3QgYW5kIHNlcGFyYXRlIGZpZWxkXG4gICAgLy8gdG9kbzogb3B0aW1pemUgcmVuZGVycyAobm90IGFsd2F5cyByZXJlbmRlciBpcyBuZWNlc3NhcnkpXG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gKHN1Ym1pdEhhbmRsZXIpID0+IGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoKTtcblxuICAgICAgICAvLyB0b2RvOiBtb3ZlIHRvIHV0aWxzIChhbmQgb3RoZXJzKVxuICAgICAgICAvLyBSdW4gdmFsaWRhdGlvbiBmb3IgZWFjaCBmaWVsZCB3aXRoIGFib3J0RWFybHk6IHRydWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVuc2UveXVwL2lzc3Vlcy81NjlcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhyZWZTdG9yZS5jdXJyZW50KS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkRGF0YSA9IHsgW25hbWVdOiBkYXRhW25hbWVdIH07XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHsgW25hbWVdOiBzY2hlbWFbbmFtZV0gfTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZShmaWVsZERhdGEsIGZpZWxkU2NoZW1hKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSByZXN1bHRcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgc3RhdHVzIH0pID0+IHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKVxuICAgICAgICAgICAgLm1hcCgoeyByZWFzb24gfSkgPT4gcmVhc29uKVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB7IHBhdGgsIG1lc3NhZ2UgfSkgPT4gKHsgLi4uYWNjLCBbcGF0aF06IG1lc3NhZ2UgfSksIHt9KTtcblxuICAgICAgICAvLyB0b2RvOiBkb24ndCBzZXQgZXJyb3JzIGlmIGVycm9ycyBkaWRuJ3QgY2hhbmdlXG4gICAgICAgIHNldEVycm9ycyhlcnJvcnMpO1xuXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSAhaGFzRXJyb3JzKGVycm9ycyk7XG4gICAgICAgIGlmIChpc1ZhbGlkKSBzdWJtaXRIYW5kbGVyKGRhdGEpO1xuXG4gICAgICAgIHVwZGF0ZUZvcm1TdGF0ZShcImlzU3VibWl0dGVkXCIsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLyB0b2RvOiB0byB1dGlsc1xuICAgIGNvbnN0IGhhc0Vycm9ycyA9IChlcnJvcnMpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlcnJvcnNcIiwgZXJyb3JzKTtcbiAgICAgICAgaWYgKCFlcnJvcnMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCBoYXNLZXlzID0gT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoIWhhc0tleXMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhlcnJvcnMpLmZpbHRlcihCb29sZWFuKS5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXx1bmRlZmluZWR9IG5hbWVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICEgbmFtZSBjYW4gYmUgY2FsbGJhY2sgZnVuY3Rpb24gKGNhbGwgb24gZmllbGQgY2hhbmdlLCByZXR1cm4gdW5zdWIpXG4gICAgICovXG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB3YXRjaEFsbCA9ICFuYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIF9uYW1lcy53YXRjaEFsbCA9IHdhdGNoQWxsO1xuXG4gICAgICAgIGxldCBuYW1lc0FyciA9IFtdO1xuICAgICAgICBpZiAoIXdhdGNoQWxsKSBuYW1lc0FyciA9IEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lIDogW25hbWVdO1xuICAgICAgICBuYW1lc0Fyci5mb3JFYWNoKChuYW1lKSA9PiBfbmFtZXMud2F0Y2guYWRkKG5hbWUpKTtcblxuICAgICAgICBjb25zdCByZXMgPSBbLi4uX25hbWVzLndhdGNoXS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAhaXNVbmRlZmluZWQodmFsdWVzW25hbWVdKSA/IHZhbHVlc1tuYW1lXSA6IHJlZlN0b3JlLmN1cnJlbnQ/LltuYW1lXT8uZ2V0VmFsdWUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgW25hbWVdOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXRjaEFsbCA/IGRlZmF1bHRWYWx1ZXMgOiBfLnBpY2soZGVmYXVsdFZhbHVlcywgbmFtZXNBcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gcmVzW25hbWVdIDogcmVzO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgLy8gdW5yZWdpc3RlcixcbiAgICAgICAgd2F0Y2gsXG4gICAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgICAgZm9ybVN0YXRlOiBwcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgLy8gZ2V0Rm9ybVN0YXRlV2l0aG91dFJlZG5lcixcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBnZXREYXRhLFxuICAgIH07XG59O1xuIiwiZXhwb3J0IHsgdXNlRm9ybUNvbnRyb2xSZWYgfSBmcm9tIFwiLi91c2VGb3JtQ29udHJvbFJlZlwiO1xuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGV4dFJlZlxuICogQHBhcmFtIHsqfSBnZXRSZWZQcm9wcyAtIEFQSSBmb3IgdXNlRm9ybSBob29rXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybUNvbnRyb2xSZWYoZXh0UmVmLCBnZXRSZWZQcm9wcykge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcInJlYWN0XCIpLkRPTUVsZW1lbnQgfCBPYmplY3R9IHJlZlBhcmFtXG4gICAgICovXG4gICAgY29uc3QgY2FsbGJhY2tSZWYgPSB1c2VDYWxsYmFjaygocmVmUGFyYW0pID0+IHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSByZWZQYXJhbSA/IGdldFJlZlByb3BzKHJlZlBhcmFtKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFleHRSZWYpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRSZWYgPT09IFwiZnVuY3Rpb25cIikgZXh0UmVmKHJlZi5jdXJyZW50KTtcbiAgICAgICAgZWxzZSBleHRSZWYuY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IHJlZiwgY2FsbGJhY2tSZWYgfTtcbn1cbiIsImV4cG9ydCB7IHVzZVByb3h5U3RhdGUgfSBmcm9tIFwiLi91c2VQcm94eVN0YXRlXCI7XHJcbiIsImltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VQcm94eVN0YXRlID0gKGluaXRTdGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShpbml0U3RhdGUpO1xyXG5cclxuICAgIGNvbnN0IHdhdGNoRmllbGRzUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IHByb3h5U3RhdGVSZWYgPSB1c2VSZWYoeyAuLi5zdGF0ZSB9KTtcclxuXHJcbiAgICBjb25zdCBwcm94eVN0YXRlID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdGF0ZSkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB3YXRjaEZpZWxkc1JlZi5jdXJyZW50W25hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlTdGF0ZVJlZi5jdXJyZW50W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIHRvZG86IHVzZSBvYmplY3QgdG8gc2V0IHZhbHVlIChjYW4gc2V0IG11bHRpcGxlIHZhbHVlcylcclxuICAgIC8vIHRvZG86IHVzZSB1cGRhdGVTdGF0ZSB0byBzZXQgaW5pdGlhbCBlcnJvcnNcclxuICAgIC8vIHRvZG86IHJlZm9ybWF0IGVycm9ycyBzdGF0ZSB3aXRoIHByb3h5U3RhdGUgZnVuY3Rpb25cclxuICAgIC8vIHRvZG86IGlzIHNob3VsZFJlbmRlciB1c2VkID8/P1xyXG4gICAgY29uc3QgdXBkYXRlU3RhdGUgPSAobmFtZSwgdmFsdWUsIHsgc2hvdWxkUmVuZGVyID0gdHJ1ZSB9ID0ge30pID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBwcm94eVN0YXRlUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICAgICAgY29uc3QgaXNTYW1lVmFsdWUgPSB2YWx1ZSA9PT0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGlzV2F0Y2hlZCA9IHdhdGNoRmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcblxyXG4gICAgICAgIHByb3h5U3RhdGVSZWYuY3VycmVudFtuYW1lXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICBjb25zdCBzaG91bGRTZXRTdGF0ZSA9IHNob3VsZFJlbmRlciAmJiBpc1dhdGNoZWQgJiYgIWlzU2FtZVZhbHVlO1xyXG4gICAgICAgIGlmIChzaG91bGRTZXRTdGF0ZSkgc2V0U3RhdGUoeyAuLi5wcm94eVN0YXRlUmVmLmN1cnJlbnQgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vPyBzaG91bGQgdXNlIHR3byBzdGF0ZXNcclxuICAgIHJldHVybiB7IHN0YXRlLCBwcm94eVN0YXRlLCB1cGRhdGVTdGF0ZSB9O1xyXG59O1xyXG4iLCIvKiFcblx0Q29weXJpZ2h0IChjKSAyMDE4IEplZCBXYXRzb24uXG5cdExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG5cdGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cdHZhciBuYXRpdmVDb2RlU3RyaW5nID0gJ1tuYXRpdmUgY29kZV0nO1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJiAhYXJnLnRvU3RyaW5nLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyohXG4gKiBkaXN0L2lucHV0bWFza1xuICogaHR0cHM6Ly9naXRodWIuY29tL1JvYmluSGVyYm90cy9JbnB1dG1hc2tcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMjMgUm9iaW4gSGVyYm90c1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBWZXJzaW9uOiA1LjAuOFxuICovXG4hZnVuY3Rpb24oZSwgdCkge1xuICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSB0KCk7IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgdCk7IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHQoKTtcbiAgICAgICAgZm9yICh2YXIgbiBpbiBpKSAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMgOiBlKVtuXSA9IGlbbl07XG4gICAgfVxufShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IHRoaXMsIChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIDg3NDE6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaSA9ICEoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgIXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSBpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDM5NzY6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGkoMjgzOSksIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9tYXhUZXN0UG9zOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIl9cIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxtYXJrZXI6IFsgXCJbXCIsIFwiXVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aWZpZXJtYXJrZXI6IFsgXCJ7XCIsIFwifVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwbWFya2VyOiBbIFwiKFwiLCBcIilcIiBdLFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdG9ybWFya2VyOiBcInxcIixcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ2hhcjogXCJcXFxcXCIsXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbmluY29tcGxldGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uY2xlYXJlZDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICAgICAgICAgICAgICBncmVlZHk6ICExLFxuICAgICAgICAgICAgICAgICAgICBhdXRvVW5tYXNrOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTWFza09uU3VibWl0OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJNYXNrT25Mb3N0Rm9jdXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRNb2RlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TW9kZVZpc3VhbDogITAsXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW5jb21wbGV0ZTogITEsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlTWFzazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVQYXN0ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdC5vbkJlZm9yZU1hc2sgPyB0Lm9uQmVmb3JlTWFzay5jYWxsKHRoaXMsIGUsIHQpIDogZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVXcml0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNob3dNYXNrT25Gb2N1czogITAsXG4gICAgICAgICAgICAgICAgICAgIHNob3dNYXNrT25Ib3ZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgIG9uS2V5VmFsaWRhdGlvbjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjogXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIG51bWVyaWNJbnB1dDogITEsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0QWxpZ246ICExLFxuICAgICAgICAgICAgICAgICAgICB1bmRvT25Fc2NhcGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICByYWRpeFBvaW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBfcmFkaXhEYW5jZTogITEsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBrZWVwU3RhdGljOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNhcmV0T25UYWI6ICEwLFxuICAgICAgICAgICAgICAgICAgICB0YWJUaHJvdWdoOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNJbnB1dFR5cGU6IFsgXCJ0ZXh0XCIsIFwidGVsXCIsIFwidXJsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiBdLFxuICAgICAgICAgICAgICAgICAgICBpZ25vcmFibGVzOiBbIG4ua2V5cy5CYWNrc3BhY2UsIG4ua2V5cy5UYWIsIG4ua2V5cy5QYXVzZSwgbi5rZXlzLkVzY2FwZSwgbi5rZXlzLlBhZ2VVcCwgbi5rZXlzLlBhZ2VEb3duLCBuLmtleXMuRW5kLCBuLmtleXMuSG9tZSwgbi5rZXlzLkFycm93TGVmdCwgbi5rZXlzLkFycm93VXAsIG4ua2V5cy5BcnJvd1JpZ2h0LCBuLmtleXMuQXJyb3dEb3duLCBuLmtleXMuSW5zZXJ0LCBuLmtleXMuRGVsZXRlLCBuLmtleXMuQ29udGV4dE1lbnUsIG4ua2V5cy5GMSwgbi5rZXlzLkYyLCBuLmtleXMuRjMsIG4ua2V5cy5GNCwgbi5rZXlzLkY1LCBuLmtleXMuRjYsIG4ua2V5cy5GNywgbi5rZXlzLkY4LCBuLmtleXMuRjksIG4ua2V5cy5GMTAsIG4ua2V5cy5GMTEsIG4ua2V5cy5GMTIsIG4ua2V5cy5Qcm9jZXNzLCBuLmtleXMuVW5pZGVudGlmaWVkLCBuLmtleXMuU2hpZnQsIG4ua2V5cy5Db250cm9sLCBuLmtleXMuQWx0LCBuLmtleXMuVGFiLCBuLmtleXMuQWx0R3JhcGgsIG4ua2V5cy5DYXBzTG9jayBdLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcmVWYWxpZGF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3N0VmFsaWRhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljRGVmaW5pdGlvblN5bWJvbDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBqaXRNYXNraW5nOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dEV2ZW50T25seTogITEsXG4gICAgICAgICAgICAgICAgICAgIG5vVmFsdWVQYXRjaGluZzogITEsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FyZXRPbkNsaWNrOiBcImx2cFwiLFxuICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0bW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydERhdGFBdHRyaWJ1dGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRQb3NpdGlvbnM6ICEwLFxuICAgICAgICAgICAgICAgICAgICB1c2VQcm90b3R5cGVEZWZpbml0aW9uczogITAsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FdmVudFRpbWVPdXQ6IDNlMyxcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZXM6IHt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSBhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDczOTI6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05XFx1ZmYxMC1cXHVmZjE5XVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvblN5bWJvbDogXCIqXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIltBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjVdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcIipcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlcXHVmZjEwLVxcdWZmMTlBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjVdXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjUzOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGkpIHJldHVybiBlLl9fZGF0YSA/IGUuX19kYXRhW3RdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZS5fX2RhdGEgPSBlLl9fZGF0YSB8fCB7fSwgZS5fX2RhdGFbdF0gPSBpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMzc3NjogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5FdmVudCA9IHZvaWQgMCwgdC5vZmYgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBuO1xuICAgICAgICAgICAgICAgICAgICBmKHRoaXNbMF0pICYmIGUgJiYgKGkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIG4gPSB0aGlzWzBdLCBlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGwoZS5zcGxpdChcIi5cIiksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgciwgbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aCA+IDApIGlmICh2b2lkIDAgPT09IHQpIGZvciAoYSA9IDAsIHIgPSBpW2VdW25dLmxlbmd0aDsgYSA8IHI7IGErKykgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbiAmJiBuLmxlbmd0aCA+IDAgPyBuIDogXCJnbG9iYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogaVtlXVtuXVthXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2OiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG4gJiYgbi5sZW5ndGggPiAwID8gbiA6IFwiZ2xvYmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgZWxzZSBpZiAobi5sZW5ndGggPiAwKSBmb3IgKHZhciBzIGluIGkpIGZvciAodmFyIGwgaW4gaVtzXSkgaWYgKGwgPT09IG4pIGlmICh2b2lkIDAgPT09IHQpIGZvciAoYSA9IDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBpW3NdW2xdLmxlbmd0aDsgYSA8IHI7IGErKykgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogaVtzXVtsXVthXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2OiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGFbMF0sIGFbMV0pLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZXYsIGEgPSBlLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW4gaSA9PSAxKSBpZiAobi5yZW1vdmVFdmVudExpc3RlbmVyID8gbi5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGEsICExKSA6IG4uZGV0YWNoRXZlbnQgJiYgbi5kZXRhY2hFdmVudChcIm9uXCIuY29uY2F0KGUpLCBhKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2xvYmFsXCIgPT09IHQpIGZvciAodmFyIHIgaW4gaVtlXSkgaVtlXVtyXS5zcGxpY2UoaVtlXVtyXS5pbmRleE9mKGEpLCAxKTsgZWxzZSBpW2VdW3RdLnNwbGljZShpW2VdW3RdLmluZGV4T2YoYSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odCwgZS5uYW1lc3BhY2UsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LCB0Lm9uID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZih0aGlzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIG4gPSB0aGlzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zcGxpdChcIiBcIikuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbChlLnNwbGl0KFwiLlwiKSwgMiksIHIgPSBhWzBdLCBvID0gYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZSwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIgPyBuLmFkZEV2ZW50TGlzdGVuZXIoZSwgdCwgITEpIDogbi5hdHRhY2hFdmVudCAmJiBuLmF0dGFjaEV2ZW50KFwib25cIi5jb25jYXQoZSksIHQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVtlXSA9IGlbZV0gfHwge30sIGlbZV1bYV0gPSBpW2VdW2FdIHx8IFtdLCBpW2VdW2FdLnB1c2godCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShyLCB2b2lkIDAgPT09IG8gPyBcImdsb2JhbFwiIDogbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSwgdC50cmlnZ2VyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYodGhpc1swXSkpIGZvciAodmFyIGkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIG4gPSB0aGlzWzBdLCByID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGUuc3BsaXQoXCIgXCIpIDogWyBlLnR5cGUgXSwgcyA9IDA7IHMgPCByLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHJbc10uc3BsaXQoXCIuXCIpLCBjID0gbFswXSwgdSA9IGxbMV0gfHwgXCJnbG9iYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGRvY3VtZW50ICYmIFwiZ2xvYmFsXCIgPT09IHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCwgcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NlZDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogYXJndW1lbnRzWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImlucHV0XCIgPT09IGMpIHAuaW5wdXRUeXBlID0gXCJpbnNlcnRUZXh0XCIsIGQgPSBuZXcgSW5wdXRFdmVudChjLCBwKTsgZWxzZSBkID0gbmV3IEN1c3RvbUV2ZW50KGMsIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChjLCBwLmJ1YmJsZXMsIHAuY2FuY2VsYWJsZSwgcC5kZXRhaWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudHlwZSAmJiAoMCwgYS5kZWZhdWx0KShkLCBlKSwgbi5kaXNwYXRjaEV2ZW50KGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAoZCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCkpLmV2ZW50VHlwZSA9IGMsIGQuZGV0YWlsID0gYXJndW1lbnRzWzFdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnR5cGUgJiYgKDAsIGEuZGVmYXVsdCkoZCwgZSksIG4uZmlyZUV2ZW50KFwib25cIiArIGQuZXZlbnRUeXBlLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodm9pZCAwICE9PSBpW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdLnR5cGUgPyBhcmd1bWVudHNbMF0gOiBvLmRlZmF1bHQuRXZlbnQoYXJndW1lbnRzWzBdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLmRldGFpbCA9IGFyZ3VtZW50cy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGlbY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiZ2xvYmFsXCIgPT09IHUgPyBPYmplY3QudmFsdWVzKGgpLmZsYXQoKSA6IGhbdV0pLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYXBwbHkobiwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIG4sIGEgPSB1KGkoNjAwKSksIHIgPSB1KGkoOTM4MCkpLCBvID0gdShpKDQ5NjMpKSwgcyA9IHUoaSg4NzQxKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH0oZSkgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBudWxsID09IGUgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiwgYSwgciwgbywgcyA9IFtdLCBsID0gITAsIGMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IChpID0gaS5jYWxsKGUpKS5uZXh0LCAwID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KGkpICE9PSBpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKDshKGwgPSAobiA9IHIuY2FsbChpKSkuZG9uZSkgJiYgKHMucHVzaChuLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyBsID0gITApIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAhMCwgYSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbCAmJiBudWxsICE9IGkucmV0dXJuICYmIChvID0gaS5yZXR1cm4oKSwgT2JqZWN0KG8pICE9PSBvKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHRocm93IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oZSwgdCkgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIGMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBpICYmIGUuY29uc3RydWN0b3IgJiYgKGkgPSBlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiTWFwXCIgPT09IGkgfHwgXCJTZXRcIiA9PT0gaSkgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJBcmd1bWVudHNcIiA9PT0gaSB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKSkgcmV0dXJuIGMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIH0oZSwgdCkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSB0IHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbmV3IEFycmF5KHQpOyBpIDwgdDsgaSsrKSBuW2ldID0gZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBFbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0LkV2ZW50ID0gbiwgXCJmdW5jdGlvblwiID09IHR5cGVvZiByLmRlZmF1bHQuQ3VzdG9tRXZlbnQgPyB0LkV2ZW50ID0gbiA9IHIuZGVmYXVsdC5DdXN0b21FdmVudCA6IHMuZGVmYXVsdCAmJiAodC5FdmVudCA9IG4gPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0IHx8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NlZDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpLmluaXRDdXN0b21FdmVudChlLCB0LmJ1YmJsZXMsIHQuY2FuY2VsYWJsZSwgdC5kZXRhaWwpLCBpO1xuICAgICAgICAgICAgICAgIH0sIG4ucHJvdG90eXBlID0gci5kZWZhdWx0LkV2ZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNjAwOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIGkoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIG4sIGEsIHIsIG8sIHMsIGwgPSBhcmd1bWVudHNbMF0gfHwge30sIGMgPSAxLCB1ID0gYXJndW1lbnRzLmxlbmd0aCwgZiA9ICExO1xuICAgICAgICAgICAgICAgICAgICBcImJvb2xlYW5cIiA9PSB0eXBlb2YgbCAmJiAoZiA9IGwsIGwgPSBhcmd1bWVudHNbY10gfHwge30sIGMrKyk7XG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IGkobCkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBsICYmIChsID0ge30pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDtjIDwgdTsgYysrKSBpZiAobnVsbCAhPSAodCA9IGFyZ3VtZW50c1tjXSkpIGZvciAobiBpbiB0KSBhID0gbFtuXSwgbCAhPT0gKHIgPSB0W25dKSAmJiAoZiAmJiByICYmIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikgfHwgKG8gPSBBcnJheS5pc0FycmF5KHIpKSkgPyAobyA/IChvID0gITEsIFxuICAgICAgICAgICAgICAgICAgICBzID0gYSAmJiBBcnJheS5pc0FycmF5KGEpID8gYSA6IFtdKSA6IHMgPSBhICYmIFwiW29iamVjdCBPYmplY3RdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA/IGEgOiB7fSwgXG4gICAgICAgICAgICAgICAgICAgIGxbbl0gPSBlKGYsIHMsIHIpKSA6IHZvaWQgMCAhPT0gciAmJiAobFtuXSA9IHIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0OTYzOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzKGkoNjAwKSksIGEgPSBzKGkoOTM4MCkpLCByID0gcyhpKDI1MykpLCBvID0gaSgzNzc2KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhLmRlZmF1bHQuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgYyA/IGUgOiB0aGlzIGluc3RhbmNlb2YgYyA/IHZvaWQgKG51bGwgIT0gZSAmJiBlICE9PSBhLmRlZmF1bHQgJiYgKHRoaXNbMF0gPSBlLm5vZGVOYW1lID8gZSA6IHZvaWQgMCAhPT0gZVswXSAmJiBlWzBdLm5vZGVOYW1lID8gZVswXSA6IGwucXVlcnlTZWxlY3RvcihlKSwgXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpc1swXSAmJiBudWxsICE9PSB0aGlzWzBdICYmICh0aGlzWzBdLmV2ZW50UmVnaXN0cnkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnkgfHwge30pKSkgOiBuZXcgYyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYy5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBvLm9uLFxuICAgICAgICAgICAgICAgICAgICBvZmY6IG8ub2ZmLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBvLnRyaWdnZXJcbiAgICAgICAgICAgICAgICB9LCBjLmV4dGVuZCA9IG4uZGVmYXVsdCwgYy5kYXRhID0gci5kZWZhdWx0LCBjLkV2ZW50ID0gby5FdmVudDtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IGM7XG4gICAgICAgICAgICAgICAgdC5kZWZhdWx0ID0gdTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5ODQ1OiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0Lm1vYmlsZSA9IHQuaXBob25lID0gdC5pZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbiwgYSA9IChuID0gaSg5MzgwKSkgJiYgbi5fX2VzTW9kdWxlID8gbiA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBhLmRlZmF1bHQubmF2aWdhdG9yICYmIGEuZGVmYXVsdC5uYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCIsIG8gPSByLmluZGV4T2YoXCJNU0lFIFwiKSA+IDAgfHwgci5pbmRleE9mKFwiVHJpZGVudC9cIikgPiAwLCBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEubW9iaWxlIHx8IGEuZGVmYXVsdC5uYXZpZ2F0b3IgJiYgYS5kZWZhdWx0Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCBcIm9udG91Y2hzdGFydFwiIGluIGEuZGVmYXVsdCwgbCA9IC9pcGhvbmUvaS50ZXN0KHIpO1xuICAgICAgICAgICAgICAgIHQuaXBob25lID0gbCwgdC5tb2JpbGUgPSBzLCB0LmllID0gbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3MTg0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoaSwgXCJcXFxcJDFcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG5ldyBSZWdFeHAoXCIoXFxcXFwiICsgWyBcIi9cIiwgXCIuXCIsIFwiKlwiLCBcIitcIiwgXCI/XCIsIFwifFwiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBcIlxcXFxcIiwgXCIkXCIsIFwiXlwiIF0uam9pbihcInxcXFxcXCIpICsgXCIpXCIsIFwiZ2ltXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDYwMzA6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuRXZlbnRIYW5kbGVycyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGkoODcxMSksIGEgPSBpKDI4MzkpLCByID0gaSg5ODQ1KSwgbyA9IGkoNzIxNSksIHMgPSBpKDc3NjApLCBsID0gaSg0NzEzKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgZVtTeW1ib2wuaXRlcmF0b3JdIHx8IGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpIHx8IChpID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gdShlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gaSAmJiBlLmNvbnN0cnVjdG9yICYmIChpID0gZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJNYXBcIiA9PT0gaSB8fCBcIlNldFwiID09PSBpKSByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJBcmd1bWVudHNcIiA9PT0gaSB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKSkgcmV0dXJuIHUoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KGUpKSB8fCB0ICYmIGUgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICYmIChlID0gaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAwLCBhID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID49IGUubGVuZ3RoID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlW24rK11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGY6IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByLCBvID0gITAsIHMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpLmNhbGwoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbyA9IGUuZG9uZSwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9ICEwLCByID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvIHx8IG51bGwgPT0gaS5yZXR1cm4gfHwgaS5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocykgdGhyb3cgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSB0IHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbmV3IEFycmF5KHQpOyBpIDwgdDsgaSsrKSBuW2ldID0gZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXlFdmVudDogZnVuY3Rpb24oZSwgdCwgaSwgYywgdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmlucHV0bWFzaywgcCA9IGQub3B0cywgaCA9IGQuZGVwZW5kZW5jeUxpYiwgdiA9IGQubWFza3NldCwgbSA9IHRoaXMsIGcgPSBoKG0pLCB5ID0gZS5rZXksIGsgPSBuLmNhcmV0LmNhbGwoZCwgbSksIGIgPSBwLm9uS2V5RG93bi5jYWxsKHRoaXMsIGUsIG4uZ2V0QnVmZmVyLmNhbGwoZCksIGssIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYikgcmV0dXJuIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA9PT0gYS5rZXlzLkJhY2tzcGFjZSB8fCB5ID09PSBhLmtleXMuRGVsZXRlIHx8IHIuaXBob25lICYmIHkgPT09IGEua2V5cy5CQUNLU1BBQ0VfU0FGQVJJIHx8IGUuY3RybEtleSAmJiB5ID09PSBhLmtleXMueCAmJiAhKFwib25jdXRcIiBpbiBtKSkgZS5wcmV2ZW50RGVmYXVsdCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaGFuZGxlUmVtb3ZlLmNhbGwoZCwgbSwgeSwgayksICgwLCBzLndyaXRlQnVmZmVyKShtLCBuLmdldEJ1ZmZlci5jYWxsKGQsICEwKSwgdi5wLCBlLCBtLmlucHV0bWFzay5fdmFsdWVHZXQoKSAhPT0gbi5nZXRCdWZmZXIuY2FsbChkKS5qb2luKFwiXCIpKTsgZWxzZSBpZiAoeSA9PT0gYS5rZXlzLkVuZCB8fCB5ID09PSBhLmtleXMuUGFnZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBuLnNlZWtOZXh0LmNhbGwoZCwgbi5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmNhcmV0LmNhbGwoZCwgbSwgZS5zaGlmdEtleSA/IGsuYmVnaW4gOiB4LCB4LCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeSA9PT0gYS5rZXlzLkhvbWUgJiYgIWUuc2hpZnRLZXkgfHwgeSA9PT0gYS5rZXlzLlBhZ2VVcCA/IChlLnByZXZlbnREZWZhdWx0KCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5jYXJldC5jYWxsKGQsIG0sIDAsIGUuc2hpZnRLZXkgPyBrLmJlZ2luIDogMCwgITApKSA6IHAudW5kb09uRXNjYXBlICYmIHkgPT09IGEua2V5cy5Fc2NhcGUgJiYgITAgIT09IGUuYWx0S2V5ID8gKCgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuY2hlY2tWYWwpKG0sICEwLCAhMSwgZC51bmRvVmFsdWUuc3BsaXQoXCJcIikpLCBnLnRyaWdnZXIoXCJjbGlja1wiKSkgOiB5ICE9PSBhLmtleXMuSW5zZXJ0IHx8IGUuc2hpZnRLZXkgfHwgZS5jdHJsS2V5IHx8IHZvaWQgMCAhPT0gZC51c2VyT3B0aW9ucy5pbnNlcnRNb2RlID8gITAgPT09IHAudGFiVGhyb3VnaCAmJiB5ID09PSBhLmtleXMuVGFiID8gITAgPT09IGUuc2hpZnRLZXkgPyAoay5lbmQgPSBuLnNlZWtQcmV2aW91cy5jYWxsKGQsIGsuZW5kLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgITAgPT09IGwuZ2V0VGVzdC5jYWxsKGQsIGsuZW5kIC0gMSkubWF0Y2guc3RhdGljICYmIGsuZW5kLS0sIGsuYmVnaW4gPSBuLnNlZWtQcmV2aW91cy5jYWxsKGQsIGsuZW5kLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgay5iZWdpbiA+PSAwICYmIGsuZW5kID4gMCAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCBuLmNhcmV0LmNhbGwoZCwgbSwgay5iZWdpbiwgay5lbmQpKSkgOiAoay5iZWdpbiA9IG4uc2Vla05leHQuY2FsbChkLCBrLmJlZ2luLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgay5lbmQgPSBuLnNlZWtOZXh0LmNhbGwoZCwgay5iZWdpbiwgITApLCBrLmVuZCA8IHYubWFza0xlbmd0aCAmJiBrLmVuZC0tLCBrLmJlZ2luIDw9IHYubWFza0xlbmd0aCAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY2FyZXQuY2FsbChkLCBtLCBrLmJlZ2luLCBrLmVuZCkpKSA6IGUuc2hpZnRLZXkgfHwgcC5pbnNlcnRNb2RlVmlzdWFsICYmICExID09PSBwLmluc2VydE1vZGUgJiYgKHkgPT09IGEua2V5cy5BcnJvd1JpZ2h0ID8gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBuLmNhcmV0LmNhbGwoZCwgbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5jYXJldC5jYWxsKGQsIG0sIGUuYmVnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApIDogeSA9PT0gYS5rZXlzLkFycm93TGVmdCAmJiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG4udHJhbnNsYXRlUG9zaXRpb24uY2FsbChkLCBtLmlucHV0bWFzay5jYXJldFBvcy5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi50cmFuc2xhdGVQb3NpdGlvbi5jYWxsKGQsIG0uaW5wdXRtYXNrLmNhcmV0UG9zLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5pc1JUTCA/IG4uY2FyZXQuY2FsbChkLCBtLCBlICsgKGUgPT09IHYubWFza0xlbmd0aCA/IDAgOiAxKSkgOiBuLmNhcmV0LmNhbGwoZCwgbSwgZSAtICgwID09PSBlID8gMCA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSkgOiBvLmlzU2VsZWN0aW9uLmNhbGwoZCwgaykgPyBwLmluc2VydE1vZGUgPSAhcC5pbnNlcnRNb2RlIDogKHAuaW5zZXJ0TW9kZSA9ICFwLmluc2VydE1vZGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5jYXJldC5jYWxsKGQsIG0sIGsuYmVnaW4sIGsuYmVnaW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmlzQ29tcG9zaW5nID0geSA9PSBhLmtleXMuUHJvY2VzcyB8fCB5ID09IGEua2V5cy5VbmlkZW50aWZpZWQsIGQuaWdub3JhYmxlID0gcC5pZ25vcmFibGVzLmluY2x1ZGVzKHkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGYua2V5cHJlc3NFdmVudC5jYWxsKHRoaXMsIGUsIHQsIGksIGMsIHUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBrZXlwcmVzc0V2ZW50OiBmdW5jdGlvbihlLCB0LCBpLCByLCBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuaW5wdXRtYXNrIHx8IHRoaXMsIHUgPSBjLm9wdHMsIGYgPSBjLmRlcGVuZGVuY3lMaWIsIGQgPSBjLm1hc2tzZXQsIHAgPSBjLmVsLCBoID0gZihwKSwgdiA9IGUua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSB0IHx8IGUuY3RybEtleSAmJiBlLmFsdEtleSB8fCAhKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgYy5pZ25vcmFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0sIGcgPSB0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IG4uY2FyZXQuY2FsbChjLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHUuc3Vic3RpdHV0ZXNbdl0gfHwgdiwgZC53cml0ZU91dEJ1ZmZlciA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG8uaXNWYWxpZC5jYWxsKGMsIGcsIHYsIHIsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgIT09IHkgJiYgKG4ucmVzZXRNYXNrU2V0LmNhbGwoYywgITApLCBtID0gdm9pZCAwICE9PSB5LmNhcmV0ID8geS5jYXJldCA6IG4uc2Vla05leHQuY2FsbChjLCB5LnBvcy5iZWdpbiA/IHkucG9zLmJlZ2luIDogeS5wb3MpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5wID0gbSksIG0gPSB1Lm51bWVyaWNJbnB1dCAmJiB2b2lkIDAgPT09IHkuY2FyZXQgPyBuLnNlZWtQcmV2aW91cy5jYWxsKGMsIG0pIDogbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICExICE9PSBpICYmIChzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUub25LZXlWYWxpZGF0aW9uLmNhbGwocCwgdiwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSwgZC53cml0ZU91dEJ1ZmZlciAmJiAhMSAhPT0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gbi5nZXRCdWZmZXIuY2FsbChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzLndyaXRlQnVmZmVyKShwLCBrLCBtLCBlLCAhMCAhPT0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQoKSwgdCkgcmV0dXJuICExICE9PSB5ICYmICh5LmZvcndhcmRQb3NpdGlvbiA9IG0pLCB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB2ID09PSBhLmtleXMuRW50ZXIgJiYgYy51bmRvVmFsdWUgIT09IGMuX3ZhbHVlR2V0KCEwKSAmJiAoYy51bmRvVmFsdWUgPSBjLl92YWx1ZUdldCghMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQsIGkgPSB0aGlzLmlucHV0bWFzaywgYSA9IGkub3B0cywgciA9IGkuX3ZhbHVlR2V0KCEwKSwgbyA9IG4uY2FyZXQuY2FsbChpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuaXNSVEwgJiYgKHQgPSBvLmVuZCwgby5lbmQgPSBuLnRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaSwgby5iZWdpbiksIG8uYmVnaW4gPSBuLnRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaSwgdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSByLnN1YnN0cigwLCBvLmJlZ2luKSwgdSA9IHIuc3Vic3RyKG8uZW5kLCByLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobCA9PSAoaS5pc1JUTCA/IG4uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpKS5zbGljZSgpLnJldmVyc2UoKSA6IG4uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpKSkuc2xpY2UoMCwgby5iZWdpbikuam9pbihcIlwiKSAmJiAobCA9IFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPT0gKGkuaXNSVEwgPyBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaSkuc2xpY2UoKS5yZXZlcnNlKCkgOiBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaSkpLnNsaWNlKG8uZW5kKS5qb2luKFwiXCIpICYmICh1ID0gXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsaXBib2FyZERhdGEgJiYgd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YSkgciA9IGwgKyB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKSArIHU7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5jbGlwYm9hcmREYXRhIHx8ICFlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBsICsgZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpICsgdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLmlzUlRMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGYuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQsIHAgPSBjKG4uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwLnMoKTsgIShkID0gcC5uKCkpLmRvbmU7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZlswXSA9PT0gaCAmJiBmLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGYuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEub25CZWZvcmVQYXN0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gKGYgPSBhLm9uQmVmb3JlUGFzdGUuY2FsbChpLCBmLCBhKSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmIHx8IChmID0gcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgcy5jaGVja1ZhbCkodGhpcywgITAsICExLCBmLnRvU3RyaW5nKCkuc3BsaXQoXCJcIiksIGUpLCBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0RmFsbEJhY2tFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgaSA9IHQub3B0cywgbyA9IHQuZGVwZW5kZW5jeUxpYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjLCB1ID0gdGhpcywgZCA9IHUuaW5wdXRtYXNrLl92YWx1ZUdldCghMCksIHAgPSAodC5pc1JUTCA/IG4uZ2V0QnVmZmVyLmNhbGwodCkuc2xpY2UoKS5yZXZlcnNlKCkgOiBuLmdldEJ1ZmZlci5jYWxsKHQpKS5qb2luKFwiXCIpLCBoID0gbi5jYXJldC5jYWxsKHQsIHUsIHZvaWQgMCwgdm9pZCAwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gZnVuY3Rpb24oZSwgYSwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvLCBzLCBjLCB1ID0gZS5zdWJzdHIoMCwgci5iZWdpbikuc3BsaXQoXCJcIiksIGYgPSBlLnN1YnN0cihyLmJlZ2luKS5zcGxpdChcIlwiKSwgZCA9IGEuc3Vic3RyKDAsIHIuYmVnaW4pLnNwbGl0KFwiXCIpLCBwID0gYS5zdWJzdHIoci5iZWdpbikuc3BsaXQoXCJcIiksIGggPSB1Lmxlbmd0aCA+PSBkLmxlbmd0aCA/IHUubGVuZ3RoIDogZC5sZW5ndGgsIHYgPSBmLmxlbmd0aCA+PSBwLmxlbmd0aCA/IGYubGVuZ3RoIDogcC5sZW5ndGgsIG0gPSBcIlwiLCBnID0gW10sIHkgPSBcIn5cIjsgdS5sZW5ndGggPCBoOyApIHUucHVzaCh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7ZC5sZW5ndGggPCBoOyApIGQucHVzaCh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7Zi5sZW5ndGggPCB2OyApIGYudW5zaGlmdCh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7cC5sZW5ndGggPCB2OyApIHAudW5zaGlmdCh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSB1LmNvbmNhdChmKSwgYiA9IGQuY29uY2F0KHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHMgPSAwLCBvID0gay5sZW5ndGg7IHMgPCBvOyBzKyspIHN3aXRjaCAoYyA9IGwuZ2V0UGxhY2Vob2xkZXIuY2FsbCh0LCBuLnRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwodCwgcykpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRUZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiW3MgLSAxXSA9PT0ga1tzXSAmJiByLmJlZ2luID09IGsubGVuZ3RoIC0gMSAmJiBnLnB1c2goa1tzXSksIHMgPSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga1tzXSA9PT0geSA/IHIuZW5kKysgOiBzID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtbc10gIT09IGJbc10gJiYgKGtbcyArIDFdICE9PSB5ICYmIGtbcyArIDFdICE9PSBjICYmIHZvaWQgMCAhPT0ga1tzICsgMV0gfHwgKGJbc10gIT09IGMgfHwgYltzICsgMV0gIT09IHkpICYmIGJbc10gIT09IHkgPyBiW3MgKyAxXSA9PT0geSAmJiBiW3NdID09PSBrW3MgKyAxXSA/IChtID0gXCJpbnNlcnRUZXh0XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5wdXNoKGtbc10pLCByLmJlZ2luLS0sIHIuZW5kLS0pIDoga1tzXSAhPT0gYyAmJiBrW3NdICE9PSB5ICYmIChrW3MgKyAxXSA9PT0geSB8fCBiW3NdICE9PSBrW3NdICYmIGJbcyArIDFdID09PSBrW3MgKyAxXSkgPyAobSA9IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5wdXNoKGtbc10pLCByLmJlZ2luLS0pIDoga1tzXSA9PT0geSA/IChtID0gXCJkZWxldGVDb250ZW50QmFja3dhcmRcIiwgKG4uaXNNYXNrLmNhbGwodCwgbi50cmFuc2xhdGVQb3NpdGlvbi5jYWxsKHQsIHMpLCAhMCkgfHwgYltzXSA9PT0gaS5yYWRpeFBvaW50KSAmJiByLmVuZCsrKSA6IHMgPSBvIDogKG0gPSBcImluc2VydFRleHRcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnLnB1c2goa1tzXSksIHIuYmVnaW4tLSwgci5lbmQtLSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQ6IHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGQsIHAsIGgpLCAodS5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCB1Lm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQgIT09IHUgJiYgdS5mb2N1cygpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgcy53cml0ZUJ1ZmZlcikodSwgbi5nZXRCdWZmZXIuY2FsbCh0KSksIG4uY2FyZXQuY2FsbCh0LCB1LCBoLmJlZ2luLCBoLmVuZCwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhci5tb2JpbGUgJiYgdC5za2lwTmV4dEluc2VydCAmJiBcImluc2VydFRleHRcIiA9PT0gZS5pbnB1dFR5cGUgJiYgXCJpbnNlcnRUZXh0XCIgPT09IGMuYWN0aW9uICYmIHQuaXNDb21wb3NpbmcpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgPT09IGUuaW5wdXRUeXBlICYmIFwiaW5zZXJ0VGV4dFwiID09PSBjLmFjdGlvbiAmJiB0LmlzQ29tcG9zaW5nID8gdC5za2lwTmV4dEluc2VydCA9ICEwIDogdC5za2lwTmV4dEluc2VydCA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRSZXBsYWNlbWVudFRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5kYXRhLmZvckVhY2goKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IG8uRXZlbnQoXCJrZXlwcmVzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4ua2V5ID0gZSwgdC5pZ25vcmFibGUgPSAhMSwgZi5rZXlwcmVzc0V2ZW50LmNhbGwodSwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LiRlbC50cmlnZ2VyKFwia2V5dXBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgby5FdmVudChcImtleWRvd25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYua2V5ID0gYS5rZXlzLkJhY2tzcGFjZSwgZi5rZXlFdmVudC5jYWxsKHUsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHMuYXBwbHlJbnB1dFZhbHVlKSh1LCBkKSwgbi5jYXJldC5jYWxsKHQsIHUsIGguYmVnaW4sIGguZW5kLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgaSA9IHRoaXMsIGEgPSBlICYmIGUuZGV0YWlsID8gZS5kZXRhaWxbMF0gOiBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBpLmlucHV0bWFzay5fdmFsdWVHZXQoITApKSwgKDAsIHMuYXBwbHlJbnB1dFZhbHVlKShpLCBhKSwgKGUuZGV0YWlsICYmIHZvaWQgMCAhPT0gZS5kZXRhaWxbMV0gfHwgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0pICYmIG4uY2FyZXQuY2FsbCh0LCBpLCBlLmRldGFpbCA/IGUuZGV0YWlsWzFdIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgaSA9IHQub3B0cywgYSA9IG51bGwgPT0gdCA/IHZvaWQgMCA6IHQuX3ZhbHVlR2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLnNob3dNYXNrT25Gb2N1cyAmJiBhICE9PSBuLmdldEJ1ZmZlci5jYWxsKHQpLmpvaW4oXCJcIikgJiYgKDAsIHMud3JpdGVCdWZmZXIpKHRoaXMsIG4uZ2V0QnVmZmVyLmNhbGwodCksIG4uc2Vla05leHQuY2FsbCh0LCBuLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwodCkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMCAhPT0gaS5wb3NpdGlvbkNhcmV0T25UYWIgfHwgITEgIT09IHQubW91c2VFbnRlciB8fCBvLmlzQ29tcGxldGUuY2FsbCh0LCBuLmdldEJ1ZmZlci5jYWxsKHQpKSAmJiAtMSAhPT0gbi5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHQpIHx8IGYuY2xpY2tFdmVudC5hcHBseSh0aGlzLCBbIGUsICEwIF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHQudW5kb1ZhbHVlID0gbnVsbCA9PSB0ID8gdm9pZCAwIDogdC5fdmFsdWVHZXQoITApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRtYXNrLnZhbGlkYXRpb25FdmVudCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtb3VzZWxlYXZlRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmlucHV0bWFzaywgdCA9IGUub3B0cywgaSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1vdXNlRW50ZXIgPSAhMSwgdC5jbGVhck1hc2tPbkxvc3RGb2N1cyAmJiAoaS5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBpLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQgIT09IGkgJiYgKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5IYW5kbGVOYXRpdmVQbGFjZWhvbGRlcikoaSwgZS5vcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tFdmVudDogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmlucHV0bWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuY2xpY2tlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhLmlucHV0bWFzay5zaGFkb3dSb290IHx8IGEub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCA9PT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gbi5kZXRlcm1pbmVOZXdDYXJldFBvc2l0aW9uLmNhbGwoaSwgbi5jYXJldC5jYWxsKGksIGEpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHIgJiYgbi5jYXJldC5jYWxsKGksIGEsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjdXRFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgaSA9IHQubWFza3NldCwgciA9IHRoaXMsIGwgPSBuLmNhcmV0LmNhbGwodCwgciksIGMgPSB0LmlzUlRMID8gbi5nZXRCdWZmZXIuY2FsbCh0KS5zbGljZShsLmVuZCwgbC5iZWdpbikgOiBuLmdldEJ1ZmZlci5jYWxsKHQpLnNsaWNlKGwuYmVnaW4sIGwuZW5kKSwgdSA9IHQuaXNSVEwgPyBjLnJldmVyc2UoKS5qb2luKFwiXCIpIDogYy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci5jbGlwYm9hcmQgPyB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodSkgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YSAmJiB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhICYmIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIHUpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaGFuZGxlUmVtb3ZlLmNhbGwodCwgciwgYS5rZXlzLkRlbGV0ZSwgbCksICgwLCBzLndyaXRlQnVmZmVyKShyLCBuLmdldEJ1ZmZlci5jYWxsKHQpLCBpLnAsIGUsIHQudW5kb1ZhbHVlICE9PSB0Ll92YWx1ZUdldCghMCkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIGkgPSB0Lm9wdHMsIGEgPSB0LmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmNsaWNrZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBhKHRoaXMpLCBsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsLmlucHV0bWFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzLkhhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyKShsLCB0Lm9yaWdpbmFsUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbC5pbnB1dG1hc2suX3ZhbHVlR2V0KCksIHUgPSBuLmdldEJ1ZmZlci5jYWxsKHQpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gYyAmJiAoaS5jbGVhck1hc2tPbkxvc3RGb2N1cyAmJiAoLTEgPT09IG4uZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh0KSAmJiBjID09PSBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodCkuam9pbihcIlwiKSA/IHUgPSBbXSA6IHMuY2xlYXJPcHRpb25hbFRhaWwuY2FsbCh0LCB1KSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICExID09PSBvLmlzQ29tcGxldGUuY2FsbCh0LCB1KSAmJiAoc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIudHJpZ2dlcihcImluY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApLCBpLmNsZWFySW5jb21wbGV0ZSAmJiAobi5yZXNldE1hc2tTZXQuY2FsbCh0KSwgdSA9IGkuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgPyBbXSA6IG4uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbCh0KS5zbGljZSgpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzLndyaXRlQnVmZmVyKShsLCB1LCB2b2lkIDAsIGUpKSwgdC51bmRvVmFsdWUgIT09IHQuX3ZhbHVlR2V0KCEwKSAmJiAodC51bmRvVmFsdWUgPSB0Ll92YWx1ZUdldCghMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIudHJpZ2dlcihcImNoYW5nZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZW50ZXJFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuaW5wdXRtYXNrLCB0ID0gZS5vcHRzLnNob3dNYXNrT25Ib3ZlciwgaSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tb3VzZUVudGVyID0gITAsIChpLmlucHV0bWFzay5zaGFkb3dSb290IHx8IGkub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gKGUuaXNSVEwgPyBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkuc2xpY2UoKS5yZXZlcnNlKCkgOiBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAmJiAoMCwgcy5IYW5kbGVOYXRpdmVQbGFjZWhvbGRlcikoaSwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5pbnB1dG1hc2ssIHQgPSBlLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnVuZG9WYWx1ZSAhPT0gZS5fdmFsdWVHZXQoITApICYmIGUuJGVsLnRyaWdnZXIoXCJjaGFuZ2VcIiksIC0xID09PSBuLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZSkgJiYgZS5fdmFsdWVHZXQgJiYgZS5fdmFsdWVHZXQoKSA9PT0gbi5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGUpLmpvaW4oXCJcIikgJiYgZS5fdmFsdWVTZXQoXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdC5jbGVhckluY29tcGxldGUgJiYgITEgPT09IG8uaXNDb21wbGV0ZS5jYWxsKGUsIG4uZ2V0QnVmZmVyLmNhbGwoZSkpICYmIGUuX3ZhbHVlU2V0KFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVtb3ZlTWFza09uU3VibWl0ICYmIChlLl92YWx1ZVNldChlLnVubWFza2VkdmFsdWUoKSwgITApLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgcy53cml0ZUJ1ZmZlcikoZS5lbCwgbi5nZXRCdWZmZXIuY2FsbChlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNldEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5pbnB1dG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlZnJlc2hWYWx1ZSA9ICEwLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgcy5hcHBseUlucHV0VmFsdWUpKGUuZWwsIGUuX3ZhbHVlR2V0KCEwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHQuRXZlbnRIYW5kbGVycyA9IGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgOTcxNjogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5FdmVudFJ1bGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBuLCBhID0gKG4gPSBpKDIzOTQpKSAmJiBuLl9fZXNNb2R1bGUgPyBuIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBuXG4gICAgICAgICAgICAgICAgfSwgciA9IGkoMjgzOSksIG8gPSBpKDg3MTEpLCBzID0gaSg3NzYwKTtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5pbnB1dG1hc2suZGVwZW5kZW5jeUxpYiwgbCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Lm9yaWdpbmFsRXZlbnQgJiYgKHQgPSB0Lm9yaWdpbmFsRXZlbnQgfHwgdCwgYXJndW1lbnRzWzBdID0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwsIGMgPSB0aGlzLCB1ID0gYy5pbnB1dG1hc2ssIGYgPSB1ID8gdS5vcHRzIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHUgJiYgXCJGT1JNXCIgIT09IHRoaXMubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBuLmRhdGEoYywgXCJfaW5wdXRtYXNrX29wdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4oYykub2ZmKCksIGQgJiYgbmV3IGEuZGVmYXVsdChkKS5tYXNrKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbIFwic3VibWl0XCIsIFwicmVzZXRcIiwgXCJzZXR2YWx1ZVwiIF0uaW5jbHVkZXModC50eXBlKSB8fCBcIkZPUk1cIiA9PT0gdGhpcy5ub2RlTmFtZSB8fCAhKGMuZGlzYWJsZWQgfHwgYy5yZWFkT25seSAmJiAhKFwia2V5ZG93blwiID09PSB0LnR5cGUgJiYgdC5jdHJsS2V5ICYmIHQua2V5ID09PSByLmtleXMuYyB8fCAhMSA9PT0gZi50YWJUaHJvdWdoICYmIHQua2V5ID09PSByLmtleXMuVGFiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gdS5za2lwSW5wdXRFdmVudCkgcmV0dXJuIHUuc2tpcElucHV0RXZlbnQgPSAhMSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdS52YWxpZGF0aW9uRXZlbnQgPyAodS52YWxpZGF0aW9uRXZlbnQgPSAhMSwgZS5ibHVyKCksICgwLCBzLkhhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyKShlLCAodS5pc1JUTCA/IG8uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbCh1KS5zbGljZSgpLnJldmVyc2UoKSA6IG8uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbCh1KSkuam9pbihcIlwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGYudmFsaWRhdGlvbkV2ZW50VGltZU91dCksICExKSA6IChsID0gYXJndW1lbnRzLCB2b2lkIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzayAmJiBpLmFwcGx5KGMsIGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGkuYXBwbHkoYywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMSA9PT0gcCAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpKSwgcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJzdWJtaXRcIiwgXCJyZXNldFwiIF0uaW5jbHVkZXModCkgPyAobCA9IGwuYmluZChlKSwgbnVsbCAhPT0gZS5mb3JtICYmIG4oZS5mb3JtKS5vbih0LCBsKSkgOiBuKGUpLm9uKHQsIGwpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrLmV2ZW50c1t0XSA9IGUuaW5wdXRtYXNrLmV2ZW50c1t0XSB8fCBbXSwgZS5pbnB1dG1hc2suZXZlbnRzW3RdLnB1c2gobCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9mZjogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuaW5wdXRtYXNrICYmIGUuaW5wdXRtYXNrLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5pbnB1dG1hc2suZGVwZW5kZW5jeUxpYiwgbiA9IGUuaW5wdXRtYXNrLmV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIHQgJiYgKChuID0gW10pW3RdID0gZS5pbnB1dG1hc2suZXZlbnRzW3RdKSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gblthXTsgci5sZW5ndGggPiAwOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gci5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJzdWJtaXRcIiwgXCJyZXNldFwiIF0uaW5jbHVkZXMoYSkgPyBudWxsICE9PSBlLmZvcm0gJiYgaShlLmZvcm0pLm9mZihhLCBvKSA6IGkoZSkub2ZmKGEsIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmlucHV0bWFzay5ldmVudHNbYV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0LkV2ZW50UnVsZXIgPSBsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDIxOTogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gZChpKDIzOTQpKSwgYSA9IGkoMjgzOSksIHIgPSBkKGkoNzE4NCkpLCBvID0gaSg4NzExKSwgcyA9IGkoNDcxMyk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH0oZSkgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBudWxsID09IGUgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiwgYSwgciwgbywgcyA9IFtdLCBsID0gITAsIGMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IChpID0gaS5jYWxsKGUpKS5uZXh0LCAwID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KGkpICE9PSBpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKDshKGwgPSAobiA9IHIuY2FsbChpKSkuZG9uZSkgJiYgKHMucHVzaChuLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyBsID0gITApIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAhMCwgYSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbCAmJiBudWxsICE9IGkucmV0dXJuICYmIChvID0gaS5yZXR1cm4oKSwgT2JqZWN0KG8pICE9PSBvKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHRocm93IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oZSwgdCkgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIGMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBpICYmIGUuY29uc3RydWN0b3IgJiYgKGkgPSBlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiTWFwXCIgPT09IGkgfHwgXCJTZXRcIiA9PT0gaSkgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJBcmd1bWVudHNcIiA9PT0gaSB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChpKSkgcmV0dXJuIGMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIH0oZSwgdCkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSB0IHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbmV3IEFycmF5KHQpOyBpIDwgdDsgaSsrKSBuW2ldID0gZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9LCB1KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAoYSA9IG4ua2V5LCByID0gdm9pZCAwLCByID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB1KGUpIHx8IG51bGwgPT09IGUpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBpLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB1KG4pKSByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHQgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShhLCBcInN0cmluZ1wiKSwgXCJzeW1ib2xcIiA9PT0gdShyKSA/IHIgOiBTdHJpbmcocikpLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwID0gbi5kZWZhdWx0LmRlcGVuZGVuY3lMaWIsIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZSh0LCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgZSksIHRoaXMubWFzayA9IHQsIHRoaXMuZm9ybWF0ID0gaSwgdGhpcy5vcHRzID0gbiwgdGhpcy5fZGF0ZSA9IG5ldyBEYXRlKDEsIDAsIDEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdERhdGVPYmplY3QodCwgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdCwgaSwgbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPSBlLCAoaSA9IFsge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5fZGF0ZSAmJiAodGhpcy5fZGF0ZSA9IG5ldyBEYXRlKDEsIDAsIDEpLCB0aGlzLmluaXREYXRlT2JqZWN0KHZvaWQgMCwgdGhpcy5vcHRzKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJpbml0RGF0ZU9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFAodCkubGFzdEluZGV4ID0gMDsgaSA9IFAodCkuZXhlYyh0aGlzLmZvcm1hdCk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyBSZWdFeHAoXCJcXFxcZCskXCIpLmV4ZWMoaVswXSksIGEgPSBuID8gaVswXVswXSArIFwieFwiIDogaVswXSwgciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFAodCkubGFzdEluZGV4LCBzID0gRShpLmluZGV4LCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQKHQpLmxhc3RJbmRleCA9IG8sIHIgPSBlLnNsaWNlKDAsIGUuaW5kZXhPZihzLm5leHRNYXRjaFswXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHIgPSBlLnNsaWNlKDAsIGdbYV0gJiYgZ1thXVs0XSB8fCBhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZS5zbGljZShyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGcsIGEpICYmIHRoaXMuc2V0VmFsdWUodGhpcywgciwgYSwgZ1thXVsyXSwgZ1thXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2V0VmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBpLCBuLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdCAmJiAoZVtuXSA9IFwiYW1wbVwiID09PSBuID8gdCA6IHQucmVwbGFjZSgvW14wLTldL2csIFwiMFwiKSwgZVtcInJhd1wiICsgbl0gPSB0LnJlcGxhY2UoL1xccy9nLCBcIl9cIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJkYXlcIiA9PT0gbiAmJiAyOSA9PT0gcGFyc2VJbnQocikgfHwgXCJtb250aFwiID09PSBuICYmIDIgPT09IHBhcnNlSW50KHIpKSAmJiAoMjkgIT09IHBhcnNlSW50KGUuZGF5KSB8fCAyICE9PSBwYXJzZUludChlLm1vbnRoKSB8fCBcIlwiICE9PSBlLnllYXIgJiYgdm9pZCAwICE9PSBlLnllYXIgfHwgZS5fZGF0ZS5zZXRGdWxsWWVhcigyMDEyLCAxLCAyOSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXlcIiA9PT0gbiAmJiAobSA9ICEwLCAwID09PSBwYXJzZUludChyKSAmJiAociA9IDEpKSwgXCJtb250aFwiID09PSBuICYmIChtID0gITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5ZWFyXCIgPT09IG4gJiYgKG0gPSAhMCwgci5sZW5ndGggPCA0ICYmIChyID0gTShyLCA0LCAhMCkpKSwgXCJcIiA9PT0gciB8fCBpc05hTihyKSB8fCBhLmNhbGwoZS5fZGF0ZSwgciksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFtcG1cIiA9PT0gbiAmJiBhLmNhbGwoZS5fZGF0ZSwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwicmVzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlID0gbmV3IERhdGUoMSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJyZUluaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlID0gdm9pZCAwLCB0aGlzLmRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXSkgJiYgZih0LnByb3RvdHlwZSwgaSksIG4gJiYgZih0LCBuKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMVxuICAgICAgICAgICAgICAgICAgICB9KSwgZTtcbiAgICAgICAgICAgICAgICB9KCksIHYgPSAobmV3IERhdGUpLmdldEZ1bGxZZWFyKCksIG0gPSAhMSwgZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZDogWyBcIlsxLTldfFsxMl1bMC05XXwzWzAxXVwiLCBEYXRlLnByb3RvdHlwZS5zZXREYXRlLCBcImRheVwiLCBEYXRlLnByb3RvdHlwZS5nZXREYXRlIF0sXG4gICAgICAgICAgICAgICAgICAgIGRkOiBbIFwiMFsxLTldfFsxMl1bMC05XXwzWzAxXVwiLCBEYXRlLnByb3RvdHlwZS5zZXREYXRlLCBcImRheVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNKERhdGUucHJvdG90eXBlLmdldERhdGUuY2FsbCh0aGlzKSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgZGRkOiBbIFwiXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgZGRkZDogWyBcIlwiIF0sXG4gICAgICAgICAgICAgICAgICAgIG06IFsgXCJbMS05XXwxWzAxMl1cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlID8gcGFyc2VJbnQoZSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPiAwICYmIHQtLSwgRGF0ZS5wcm90b3R5cGUuc2V0TW9udGguY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJtb250aFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS5nZXRNb250aC5jYWxsKHRoaXMpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBtbTogWyBcIjBbMS05XXwxWzAxMl1cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlID8gcGFyc2VJbnQoZSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPiAwICYmIHQtLSwgRGF0ZS5wcm90b3R5cGUuc2V0TW9udGguY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJtb250aFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNKERhdGUucHJvdG90eXBlLmdldE1vbnRoLmNhbGwodGhpcykgKyAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBtbW06IFsgXCJcIiBdLFxuICAgICAgICAgICAgICAgICAgICBtbW1tOiBbIFwiXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgeXk6IFsgXCJbMC05XXsyfVwiLCBEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhciwgXCJ5ZWFyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0oRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFllYXIuY2FsbCh0aGlzKSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgeXl5eTogWyBcIlswLTldezR9XCIsIERhdGUucHJvdG90eXBlLnNldEZ1bGxZZWFyLCBcInllYXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTShEYXRlLnByb3RvdHlwZS5nZXRGdWxsWWVhci5jYWxsKHRoaXMpLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBoOiBbIFwiWzEtOV18MVswLTJdXCIsIERhdGUucHJvdG90eXBlLnNldEhvdXJzLCBcImhvdXJzXCIsIERhdGUucHJvdG90eXBlLmdldEhvdXJzIF0sXG4gICAgICAgICAgICAgICAgICAgIGhoOiBbIFwiMFsxLTldfDFbMC0yXVwiLCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNKERhdGUucHJvdG90eXBlLmdldEhvdXJzLmNhbGwodGhpcyksIDIpO1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIGh4OiBbIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlswLTlde1wiLmNvbmNhdChlLCBcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIERhdGUucHJvdG90eXBlLnNldEhvdXJzLCBcImhvdXJzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS5nZXRIb3VycztcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBIOiBbIFwiMT9bMC05XXwyWzAtM11cIiwgRGF0ZS5wcm90b3R5cGUuc2V0SG91cnMsIFwiaG91cnNcIiwgRGF0ZS5wcm90b3R5cGUuZ2V0SG91cnMgXSxcbiAgICAgICAgICAgICAgICAgICAgSEg6IFsgXCIwWzAtOV18MVswLTldfDJbMC0zXVwiLCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNKERhdGUucHJvdG90eXBlLmdldEhvdXJzLmNhbGwodGhpcyksIDIpO1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIEh4OiBbIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlswLTlde1wiLmNvbmNhdChlLCBcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIERhdGUucHJvdG90eXBlLnNldEhvdXJzLCBcImhvdXJzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTShEYXRlLnByb3RvdHlwZS5nZXRIb3Vycy5jYWxsKHRoaXMpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgTTogWyBcIlsxLTVdP1swLTldXCIsIERhdGUucHJvdG90eXBlLnNldE1pbnV0ZXMsIFwibWludXRlc1wiLCBEYXRlLnByb3RvdHlwZS5nZXRNaW51dGVzIF0sXG4gICAgICAgICAgICAgICAgICAgIE1NOiBbIFwiMFswLTldfDFbMC05XXwyWzAtOV18M1swLTldfDRbMC05XXw1WzAtOV1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0TWludXRlcywgXCJtaW51dGVzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0oRGF0ZS5wcm90b3R5cGUuZ2V0TWludXRlcy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBzOiBbIFwiWzEtNV0/WzAtOV1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0U2Vjb25kcywgXCJzZWNvbmRzXCIsIERhdGUucHJvdG90eXBlLmdldFNlY29uZHMgXSxcbiAgICAgICAgICAgICAgICAgICAgc3M6IFsgXCIwWzAtOV18MVswLTldfDJbMC05XXwzWzAtOV18NFswLTldfDVbMC05XVwiLCBEYXRlLnByb3RvdHlwZS5zZXRTZWNvbmRzLCBcInNlY29uZHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTShEYXRlLnByb3RvdHlwZS5nZXRTZWNvbmRzLmNhbGwodGhpcyksIDIpO1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIGw6IFsgXCJbMC05XXszfVwiLCBEYXRlLnByb3RvdHlwZS5zZXRNaWxsaXNlY29uZHMsIFwibWlsbGlzZWNvbmRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0oRGF0ZS5wcm90b3R5cGUuZ2V0TWlsbGlzZWNvbmRzLmNhbGwodGhpcyksIDMpO1xuICAgICAgICAgICAgICAgICAgICB9LCAzIF0sXG4gICAgICAgICAgICAgICAgICAgIEw6IFsgXCJbMC05XXsyfVwiLCBEYXRlLnByb3RvdHlwZS5zZXRNaWxsaXNlY29uZHMsIFwibWlsbGlzZWNvbmRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0oRGF0ZS5wcm90b3R5cGUuZ2V0TWlsbGlzZWNvbmRzLmNhbGwodGhpcyksIDIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyIF0sXG4gICAgICAgICAgICAgICAgICAgIHQ6IFsgXCJbYXBdXCIsIGssIFwiYW1wbVwiLCBiLCAxIF0sXG4gICAgICAgICAgICAgICAgICAgIHR0OiBbIFwiW2FwXW1cIiwgaywgXCJhbXBtXCIsIGIsIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgVDogWyBcIltBUF1cIiwgaywgXCJhbXBtXCIsIGIsIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgVFQ6IFsgXCJbQVBdTVwiLCBrLCBcImFtcG1cIiwgYiwgMiBdLFxuICAgICAgICAgICAgICAgICAgICBaOiBbIFwiLipcIiwgdm9pZCAwLCBcIlpcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMudG9TdHJpbmcoKS5tYXRjaCgvXFwoKC4rKVxcKS8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbmNsdWRlcyhcIiBcIikgJiYgKGUgPSAoZSA9IGUucmVwbGFjZShcIi1cIiwgXCIgXCIpLnRvVXBwZXJDYXNlKCkpLnNwbGl0KFwiIFwiKS5tYXAoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbChlLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIG86IFsgXCJcIiBdLFxuICAgICAgICAgICAgICAgICAgICBTOiBbIFwiXCIgXVxuICAgICAgICAgICAgICAgIH0sIHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzb0RhdGU6IFwieXl5eS1tbS1kZFwiLFxuICAgICAgICAgICAgICAgICAgICBpc29UaW1lOiBcIkhIOk1NOnNzXCIsXG4gICAgICAgICAgICAgICAgICAgIGlzb0RhdGVUaW1lOiBcInl5eXktbW0tZGQnVCdISDpNTTpzc1wiLFxuICAgICAgICAgICAgICAgICAgICBpc29VdGNEYXRlVGltZTogXCJVVEM6eXl5eS1tbS1kZCdUJ0hIOk1NOnNzJ1onXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGsoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicFwiKSA/IHRoaXMuc2V0SG91cnModCArIDEyKSA6IGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImFcIikgJiYgdCA+PSAxMiAmJiB0aGlzLnNldEhvdXJzKHQgLSAxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUgPSBlIHx8IDEyKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFJlZ0V4cChcIlxcXFxkKyRcIikuZXhlYyhlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgdm9pZCAwICE9PSB0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGdbZVswXVswXSArIFwieFwiXS5zbGljZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpWzBdID0gaVswXSh0WzBdKSwgaVszXSA9IGlbM10odFswXSksIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdbZVswXV0pIHJldHVybiBnW2VbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBbXSwgaSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBnKSBpZiAoL1xcLip4JC8udGVzdChuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gblswXSArIFwiXFxcXGQrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT09IGkuaW5kZXhPZihhKSAmJiBpLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLTEgPT09IHQuaW5kZXhPZihuWzBdKSAmJiB0LnB1c2goblswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRva2VuaXplciA9IFwiKFwiICsgKGkubGVuZ3RoID4gMCA/IGkuam9pbihcInxcIikgKyBcInxcIiA6IFwiXCIpICsgdC5qb2luKFwiK3xcIikgKyBcIikrP3wuXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZS50b2tlbml6ZXIgPSBuZXcgUmVnRXhwKGUudG9rZW5pemVyLCBcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudG9rZW5pemVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3KGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUucmF3ZGF5IHx8ICFpc0Zpbml0ZShlLnJhd2RheSkgJiYgbmV3IERhdGUoZS5kYXRlLmdldEZ1bGxZZWFyKCksIGlzRmluaXRlKGUucmF3bW9udGgpID8gZS5tb250aCA6IGUuZGF0ZS5nZXRNb250aCgpICsgMSwgMCkuZ2V0RGF0ZSgpID49IGUuZGF5IHx8IFwiMjlcIiA9PSBlLmRheSAmJiAoIWlzRmluaXRlKGUucmF3eWVhcikgfHwgdm9pZCAwID09PSBlLnJhd3llYXIgfHwgXCJcIiA9PT0gZS5yYXd5ZWFyKSB8fCBuZXcgRGF0ZShlLmRhdGUuZ2V0RnVsbFllYXIoKSwgaXNGaW5pdGUoZS5yYXdtb250aCkgPyBlLm1vbnRoIDogZS5kYXRlLmdldE1vbnRoKCkgKyAxLCAwKS5nZXREYXRlKCkgPj0gZS5kYXkpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCIyOVwiID09IGUuZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IEUodC5wb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwieXl5eVwiID09PSBuLnRhcmdldE1hdGNoWzBdICYmIHQucG9zIC0gbi50YXJnZXRNYXRjaEluZGV4ID09IDIpIHJldHVybiB0LnJlbW92ZSA9IHQucG9zICsgMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiMDJcIiA9PSBlLm1vbnRoICYmIFwiMzBcIiA9PSBlLmRheSAmJiB2b2lkIDAgIT09IHQuYykgcmV0dXJuIGUuZGF5ID0gXCIwM1wiLCBcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRlLnNldERhdGUoMyksIGUuZGF0ZS5zZXRNb250aCgxKSwgdC5pbnNlcnQgPSBbIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjOiBcIjBcIlxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHQucG9zICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGM6IHQuY1xuICAgICAgICAgICAgICAgICAgICB9IF0sIHQuY2FyZXQgPSBvLnNlZWtOZXh0LmNhbGwodGhpcywgdC5wb3MgKyAxKSwgdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTKGUsIHQsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEsIG8sIHMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFAoaSkubGFzdEluZGV4ID0gMDsgYSA9IFAoaSkuZXhlYyhlKTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSB0KSBpZiAobyA9IHgoYSkpIHMgKz0gXCIoXCIgKyBvWzBdICsgXCIpXCI7IGVsc2Ugc3dpdGNoIChhWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIihcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXCIpP1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSAoMCwgci5kZWZhdWx0KShhWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobyA9IHgoYSkpIGlmICghMCAhPT0gbiAmJiBvWzNdKSBzICs9IG9bM10uY2FsbCh0LmRhdGUpOyBlbHNlIG9bMl0gPyBzICs9IHRbXCJyYXdcIiArIG9bMl1dIDogcyArPSBhWzBdOyBlbHNlIHMgKz0gYVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTShlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IFN0cmluZyhlKSwgdCA9IHQgfHwgMjsgZS5sZW5ndGggPCB0OyApIGUgPSBpID8gZSArIFwiMFwiIDogXCIwXCIgKyBlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gXyhlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gbmV3IGgoZSwgdCwgaSkgOiBlICYmIFwib2JqZWN0XCIgPT09IHUoZSkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiZGF0ZVwiKSA/IGUgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE8oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUyh0LmlucHV0Rm9ybWF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBlXG4gICAgICAgICAgICAgICAgICAgIH0sIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG4sIGEgPSAwLCByID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChQKHQpLmxhc3RJbmRleCA9IDA7IG4gPSBQKHQpLmV4ZWModC5pbnB1dEZvcm1hdCk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuZXcgUmVnRXhwKFwiXFxcXGQrJFwiKS5leGVjKG5bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhICs9IHIgPSBvID8gcGFyc2VJbnQob1swXSkgOiBuWzBdLmxlbmd0aCkgPj0gZSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbiwgbiA9IFAodCkuZXhlYyh0LmlucHV0Rm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWF0Y2hJbmRleDogYSAtIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0TWF0Y2g6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaDogaVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuLmRlZmF1bHQuZXh0ZW5kQWxpYXNlcyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubnVtZXJpY0lucHV0ID0gITEsIGcuUyA9IGUuaTE4bi5vcmRpbmFsU3VmZml4LmpvaW4oXCJ8XCIpLCBlLmlucHV0Rm9ybWF0ID0geVtlLmlucHV0Rm9ybWF0XSB8fCBlLmlucHV0Rm9ybWF0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXlGb3JtYXQgPSB5W2UuZGlzcGxheUZvcm1hdF0gfHwgZS5kaXNwbGF5Rm9ybWF0IHx8IGUuaW5wdXRGb3JtYXQsIGUub3V0cHV0Rm9ybWF0ID0geVtlLm91dHB1dEZvcm1hdF0gfHwgZS5vdXRwdXRGb3JtYXQgfHwgZS5pbnB1dEZvcm1hdCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wbGFjZWhvbGRlciA9IFwiXCIgIT09IGUucGxhY2Vob2xkZXIgPyBlLnBsYWNlaG9sZGVyIDogZS5pbnB1dEZvcm1hdC5yZXBsYWNlKC9bW1xcXV0vLCBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5yZWdleCA9IFMoZS5pbnB1dEZvcm1hdCwgdm9pZCAwLCBlKSwgZS5taW4gPSBfKGUubWluLCBlLmlucHV0Rm9ybWF0LCBlKSwgZS5tYXggPSBfKGUubWF4LCBlLmlucHV0Rm9ybWF0LCBlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBcImlzb0RhdGVUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Rm9ybWF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlOYW1lczogWyBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzOiBbIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCIsIFwiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGluYWxTdWZmaXg6IFsgXCJzdFwiLCBcIm5kXCIsIFwicmRcIiwgXCJ0aFwiIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVWYWxpZGF0aW9uOiBmdW5jdGlvbihlLCB0LCBpLCBuLCBhLCByLCBvLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oaSkgJiYgZVt0XSAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IEUodCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsLm5leHRNYXRjaCAmJiBsLm5leHRNYXRjaFswXSA9PT0gaSAmJiBsLnRhcmdldE1hdGNoWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZ1tsLnRhcmdldE1hdGNoWzBdXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKGMpLnRlc3QoXCIwXCIgKyBlW3QgLSAxXSkpIHJldHVybiBlW3RdID0gZVt0IC0gMV0sIGVbdCAtIDFdID0gXCIwXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1enp5OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEZyb21CdWZmZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHQgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHQgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHQgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0VmFsaWRhdGlvbjogZnVuY3Rpb24oZSwgdCwgaSwgbiwgYSwgciwgbywgbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjLCB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSBuICYmICgoKGMgPSBFKHQgKyAxLCBhKSkudGFyZ2V0TWF0Y2ggJiYgYy50YXJnZXRNYXRjaEluZGV4ID09PSB0ICYmIGMudGFyZ2V0TWF0Y2hbMF0ubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGdbYy50YXJnZXRNYXRjaFswXV0gfHwgKGMgPSBFKHQgKyAyLCBhKSkudGFyZ2V0TWF0Y2ggJiYgYy50YXJnZXRNYXRjaEluZGV4ID09PSB0ICsgMSAmJiBjLnRhcmdldE1hdGNoWzBdLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBnW2MudGFyZ2V0TWF0Y2hbMF1dKSAmJiAodSA9IGdbYy50YXJnZXRNYXRjaFswXV1bMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHUgJiYgKHZvaWQgMCAhPT0gci52YWxpZFBvc2l0aW9uc1t0ICsgMV0gJiYgbmV3IFJlZ0V4cCh1KS50ZXN0KGkgKyBcIjBcIikgPyAoZVt0XSA9IGksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbdCArIDFdID0gXCIwXCIsIG4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdCArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBuZXcgUmVnRXhwKHUpLnRlc3QoXCIwXCIgKyBpKSAmJiAoZVt0XSA9IFwiMFwiLCBlW3QgKyAxXSA9IGksIG4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdCArIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksICExID09PSBuKSkgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uZnV6enkgJiYgKGUgPSBuLmJ1ZmZlciwgdCA9IG4ucG9zKSwgKGMgPSBFKHQsIGEpKS50YXJnZXRNYXRjaCAmJiBjLnRhcmdldE1hdGNoWzBdICYmIHZvaWQgMCAhPT0gZ1tjLnRhcmdldE1hdGNoWzBdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGdbYy50YXJnZXRNYXRjaFswXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBmWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGUuc2xpY2UoYy50YXJnZXRNYXRjaEluZGV4LCBjLnRhcmdldE1hdGNoSW5kZXggKyBjLnRhcmdldE1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gbmV3IFJlZ0V4cCh1KS50ZXN0KGQuam9pbihcIlwiKSkgJiYgMiA9PT0gYy50YXJnZXRNYXRjaFswXS5sZW5ndGggJiYgci52YWxpZFBvc2l0aW9uc1tjLnRhcmdldE1hdGNoSW5kZXhdICYmIHIudmFsaWRQb3NpdGlvbnNbYy50YXJnZXRNYXRjaEluZGV4ICsgMV0gJiYgKHIudmFsaWRQb3NpdGlvbnNbYy50YXJnZXRNYXRjaEluZGV4ICsgMV0uaW5wdXQgPSBcIjBcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInllYXJcIiA9PSBmWzJdKSBmb3IgKHZhciBwID0gcy5nZXRNYXNrVGVtcGxhdGUuY2FsbCh0aGlzLCAhMSwgMSwgdm9pZCAwLCAhMCksIGggPSB0ICsgMTsgaCA8IGUubGVuZ3RoOyBoKyspIGVbaF0gPSBwW2hdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHIudmFsaWRQb3NpdGlvbnNbaF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gbiwgeSA9IF8oZS5qb2luKFwiXCIpLCBhLmlucHV0Rm9ybWF0LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSAmJiAhaXNOYU4oeS5kYXRlLmdldFRpbWUoKSkgJiYgKGEucHJlZmlsbFllYXIgJiYgKG0gPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnllYXIgIT09IGUucmF3eWVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB2LnRvU3RyaW5nKCksIGEgPSBlLnJhd3llYXIucmVwbGFjZSgvW14wLTldL2csIFwiXCIpLCByID0gbi5zbGljZSgwLCBhLmxlbmd0aCksIG8gPSBuLnNsaWNlKGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgyID09PSBhLmxlbmd0aCAmJiBhID09PSByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgRGF0ZSh2LCBlLm1vbnRoIC0gMSwgZS5kYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF5ID09IHMuZ2V0RGF0ZSgpICYmICghaS5tYXggfHwgaS5tYXguZGF0ZS5nZXRUaW1lKCkgPj0gcy5nZXRUaW1lKCkpICYmIChlLmRhdGUuc2V0RnVsbFllYXIodiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUueWVhciA9IG4sIHQuaW5zZXJ0ID0gWyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBvWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHQucG9zICsgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzogb1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh5LCBtLCBhKSksIG0gPSBmdW5jdGlvbihlLCB0LCBpLCBuLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIGkubWluICYmICFpc05hTihpLm1pbi5kYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChlLnJlc2V0KCksIFAoaSkubGFzdEluZGV4ID0gMDsgciA9IFAoaSkuZXhlYyhpLmlucHV0Rm9ybWF0KTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvID0geChyKSkgJiYgb1szXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gb1sxXSwgbCA9IGVbb1syXV0sIGMgPSBpLm1pbltvWzJdXSwgdSA9IGkubWF4ID8gaS5tYXhbb1syXV0gOiBjLCBmID0gW10sIGQgPSAhMSwgcCA9IDA7IHAgPCBjLmxlbmd0aDsgcCsrKSB2b2lkIDAgIT09IG4udmFsaWRQb3NpdGlvbnNbcCArIHIuaW5kZXhdIHx8IGQgPyAoZltwXSA9IGxbcF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gZCB8fCBsW3BdID4gY1twXSkgOiAoZltwXSA9IGNbcF0sIFwieWVhclwiID09PSBvWzJdICYmIGwubGVuZ3RoIC0gMSA9PSBwICYmIGMgIT0gdSAmJiAoZiA9IChwYXJzZUludChmLmpvaW4oXCJcIikpICsgMSkudG9TdHJpbmcoKS5zcGxpdChcIlwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFtcG1cIiA9PT0gb1syXSAmJiBjICE9IHUgJiYgaS5taW4uZGF0ZS5nZXRUaW1lKCkgPiBlLmRhdGUuZ2V0VGltZSgpICYmIChmW3BdID0gdVtwXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmNhbGwoZS5fZGF0ZSwgZi5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gaS5taW4uZGF0ZS5nZXRUaW1lKCkgPD0gZS5kYXRlLmdldFRpbWUoKSwgZS5yZUluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiBpLm1heCAmJiAoaXNOYU4oaS5tYXguZGF0ZS5nZXRUaW1lKCkpIHx8ICh0ID0gaS5tYXguZGF0ZS5nZXRUaW1lKCkgPj0gZS5kYXRlLmdldFRpbWUoKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHksIG0gPSB3LmNhbGwodGhpcywgeSwgbSwgYSksIGEsIHIpKSwgdm9pZCAwICE9PSB0ICYmIG0gJiYgbi5wb3MgIT09IHQgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogUyhhLmlucHV0Rm9ybWF0LCB5LCBhKS5zcGxpdChcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEZyb21CdWZmZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBuLnBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IG4uY2FyZXQgfHwgbi5wb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmN0cmxLZXkgJiYgZS5rZXkgPT09IGEua2V5cy5BcnJvd1JpZ2h0ICYmICh0aGlzLmlucHV0bWFzay5fdmFsdWVTZXQoTyhuZXcgRGF0ZSwgbikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwKHRoaXMpLnRyaWdnZXIoXCJzZXR2YWx1ZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA/IFMoaS5vdXRwdXRGb3JtYXQsIF8oZSwgaS5pbnB1dEZvcm1hdCwgaSksIGksICEwKSA6IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBmdW5jdGlvbihlLCB0LCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPT0gdC5uYXRpdmVEZWYuaW5kZXhPZihcIlthcF1cIikgPyBlLnRvTG93ZXJDYXNlKCkgOiAwID09IHQubmF0aXZlRGVmLmluZGV4T2YoXCJbQVBdXCIpID8gZS50b1VwcGVyQ2FzZSgpIDogZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZU1hc2s6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IERhdGVdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSAmJiAoZSA9IE8oZSwgdCkpLCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE1vZGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TW9kZVZpc3VhbDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFBvc2l0aW9uczogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwU3RhdGljOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bW9kZTogXCJudW1lcmljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaWxsWWVhcjogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDM4NTE6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiwgYSA9IChuID0gaSgyMzk0KSkgJiYgbi5fX2VzTW9kdWxlID8gbiA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogblxuICAgICAgICAgICAgICAgIH0sIHIgPSBpKDg3MTEpLCBvID0gaSg0NzEzKTtcbiAgICAgICAgICAgICAgICBhLmRlZmF1bHQuZXh0ZW5kRGVmaW5pdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICBBOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiW0EtWmEtelxcdTA0MTAtXFx1MDQ0ZlxcdTA0MDFcXHUwNDUxXFx4YzAtXFx4ZmZcXHhiNV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogXCJ1cHBlclwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiJlwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOUEtWmEtelxcdTA0MTAtXFx1MDQ0ZlxcdTA0MDFcXHUwNDUxXFx4YzAtXFx4ZmZcXHhiNV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogXCJ1cHBlclwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiI1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOUEtRmEtZl1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogXCJ1cHBlclwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG5ldyBSZWdFeHAoXCIyNVswLTVdfDJbMC00XVswLTldfFswMV1bMC05XVswLTldXCIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSwgdCwgaSwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAtIDEgPiAtMSAmJiBcIi5cIiAhPT0gdC5idWZmZXJbaSAtIDFdID8gKGUgPSB0LmJ1ZmZlcltpIC0gMV0gKyBlLCBlID0gaSAtIDIgPiAtMSAmJiBcIi5cIiAhPT0gdC5idWZmZXJbaSAtIDJdID8gdC5idWZmZXJbaSAtIDJdICsgZSA6IFwiMFwiICsgZSkgOiBlID0gXCIwMFwiICsgZSwgXG4gICAgICAgICAgICAgICAgICAgIHMudGVzdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5kZWZhdWx0LmV4dGVuZEFsaWFzZXMoe1xuICAgICAgICAgICAgICAgICAgICBjc3N1bml0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogXCJbKy1dP1swLTldK1xcXFwuPyhbMC05XSspPyhweHxlbXxyZW18ZXh8JXxpbnxjbXxtbXxwdHxwYylcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBcIihodHRwcz98ZnRwKTovLy4qXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvVW5tYXNrOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBTdGF0aWM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiVGhyb3VnaDogITBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2s6IFwiaXsxLDN9Lmp7MSwzfS5rezEsM30ubHsxLDN9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVW5NYXNrOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtb2RlOiBcImRlY2ltYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXCI6IFwiLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnNlcGFyYXRvciwgaSA9IGUucXVhbnRpZmllciwgbiA9IFwiKnsxLDY0fVsuKnsxLDY0fV1bLip7MSw2NH1dWy4qezEsNjN9XUAtezEsNjN9Li17MSw2M31bLi17MSw2M31dWy4tezEsNjN9XVwiLCBhID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCkgZm9yICh2YXIgciA9IDA7IHIgPCBpOyByKyspIGEgKz0gXCJbXCIuY29uY2F0KHQpLmNvbmNhdChuLCBcIl1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JlZWR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogXCJsb3dlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpZmllcjogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZVBhc3RlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlID0gZS50b0xvd2VyQ2FzZSgpKS5yZXBsYWNlKFwibWFpbHRvOlwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05XFx1ZmYxMS1cXHVmZjE5QS1aYS16XFx1MDQxMC1cXHUwNDRmXFx1MDQwMVxcdTA0NTFcXHhjMC1cXHhmZlxceGI1ISMkJSYnKisvPT9eX2B7fH1+LV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCItXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlBLVphLXotXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVW5NYXNrOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtb2RlOiBcImVtYWlsXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWFjOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBcIiMjOiMjOiMjOiMjOiMjOiMjXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBcIlZ7MTN9OXs0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbQS1ISi1OUFItWmEtaGotbnByLXpcXFxcZF1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBcInVwcGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbmNvbXBsZXRlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Vbm1hc2s6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNzbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogXCI5OTktOTktOTk5OVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFZhbGlkYXRpb246IGZ1bmN0aW9uKGUsIHQsIGksIG4sIGEsIHMsIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG8uZ2V0TWFza1RlbXBsYXRlLmNhbGwodGhpcywgITAsIHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh0aGlzKSwgITAsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gL14oPyEyMTktMDktOTk5OXwwNzgtMDUtMTEyMCkoPyE2NjZ8MDAwfDkuezJ9KS57M30tKD8hMDApLnsyfS0oPyEwezR9KS57NH0kLy50ZXN0KGMuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyMDc6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHMoaSgyMzk0KSksIGEgPSBzKGkoNzE4NCkpLCByID0gaSg4NzExKSwgbyA9IGkoMjgzOSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsID0gbi5kZWZhdWx0LmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBcIlwiLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIG4uZGVmYXVsdC5wcm90b3R5cGUuZGVmaW5pdGlvbnNbZS5jaGFyQXQoYSldIHx8IHQuZGVmaW5pdGlvbnNbZS5jaGFyQXQoYSldIHx8IHQub3B0aW9uYWxtYXJrZXJbMF0gPT09IGUuY2hhckF0KGEpIHx8IHQub3B0aW9uYWxtYXJrZXJbMV0gPT09IGUuY2hhckF0KGEpIHx8IHQucXVhbnRpZmllcm1hcmtlclswXSA9PT0gZS5jaGFyQXQoYSkgfHwgdC5xdWFudGlmaWVybWFya2VyWzFdID09PSBlLmNoYXJBdChhKSB8fCB0Lmdyb3VwbWFya2VyWzBdID09PSBlLmNoYXJBdChhKSB8fCB0Lmdyb3VwbWFya2VyWzFdID09PSBlLmNoYXJBdChhKSB8fCB0LmFsdGVybmF0b3JtYXJrZXIgPT09IGUuY2hhckF0KGEpID8gaSArPSBcIlxcXFxcIiArIGUuY2hhckF0KGEpIDogaSArPSBlLmNoYXJBdChhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZW5ndGggPiAwICYmIHQgPiAwICYmICghaS5kaWdpdHNPcHRpb25hbCB8fCBuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLmluZGV4T2YoaS5yYWRpeFBvaW50KSwgciA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5uZWdhdGlvblN5bWJvbC5iYWNrID09PSBlW2UubGVuZ3RoIC0gMV0gJiYgKHIgPSAhMCwgZS5sZW5ndGgtLSksIC0xID09PSBhICYmIChlLnB1c2goaS5yYWRpeFBvaW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSAxOyBvIDw9IHQ7IG8rKykgaXNGaW5pdGUoZVthICsgb10pIHx8IChlW2EgKyBvXSA9IFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gciAmJiBlLnB1c2goaS5uZWdhdGlvblN5bWJvbC5iYWNrKSwgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBcIitcIiA9PT0gZSAmJiAoaSA9IHIuc2Vla05leHQuY2FsbCh0aGlzLCB0LnZhbGlkUG9zaXRpb25zLmxlbmd0aCAtIDEpKSwgXG4gICAgICAgICAgICAgICAgICAgIHQudGVzdHMpIGlmICgobiA9IHBhcnNlSW50KG4pKSA+PSBpKSBmb3IgKHZhciBhID0gMCwgbyA9IHQudGVzdHNbbl0ubGVuZ3RoOyBhIDwgbzsgYSsrKSBpZiAoKHZvaWQgMCA9PT0gdC52YWxpZFBvc2l0aW9uc1tuXSB8fCBcIi1cIiA9PT0gZSkgJiYgdC50ZXN0c1tuXVthXS5tYXRjaC5kZWYgPT09IGUpIHJldHVybiBuICsgKHZvaWQgMCAhPT0gdC52YWxpZFBvc2l0aW9uc1tuXSAmJiBcIi1cIiAhPT0gZSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSAwLCBhID0gdC52YWxpZFBvc2l0aW9ucy5sZW5ndGg7IG4gPCBhOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdC52YWxpZFBvc2l0aW9uc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyICYmIHIubWF0Y2guZGVmID09PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHAoZSwgdCwgaSwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHQuYnVmZmVyID8gdC5idWZmZXIuaW5kZXhPZihhLnJhZGl4UG9pbnQpIDogLTEsIG8gPSAoLTEgIT09IHIgfHwgbiAmJiBhLmppdE1hc2tpbmcpICYmIG5ldyBSZWdFeHAoYS5kZWZpbml0aW9uc1s5XS52YWxpZGF0b3IpLnRlc3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9yYWRpeERhbmNlICYmIC0xICE9PSByICYmIG8gJiYgbnVsbCA9PSB0LnZhbGlkUG9zaXRpb25zW3JdID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiByID09PSBpID8gciArIDEgOiByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IGEucmFkaXhQb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaVxuICAgICAgICAgICAgICAgICAgICB9IDogbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbi5kZWZhdWx0LmV4dGVuZEFsaWFzZXMoe1xuICAgICAgICAgICAgICAgICAgICBudW1lcmljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5yZXBlYXQgPSAwLCBlLmdyb3VwU2VwYXJhdG9yID09PSBlLnJhZGl4UG9pbnQgJiYgZS5kaWdpdHMgJiYgXCIwXCIgIT09IGUuZGlnaXRzICYmIChcIi5cIiA9PT0gZS5yYWRpeFBvaW50ID8gZS5ncm91cFNlcGFyYXRvciA9IFwiLFwiIDogXCIsXCIgPT09IGUucmFkaXhQb2ludCA/IGUuZ3JvdXBTZXBhcmF0b3IgPSBcIi5cIiA6IGUuZ3JvdXBTZXBhcmF0b3IgPSBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIgPT09IGUuZ3JvdXBTZXBhcmF0b3IgJiYgKGUuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IHZvaWQgMCksIGUucGxhY2Vob2xkZXIubGVuZ3RoID4gMSAmJiAoZS5wbGFjZWhvbGRlciA9IGUucGxhY2Vob2xkZXIuY2hhckF0KDApKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyYWRpeEZvY3VzXCIgPT09IGUucG9zaXRpb25DYXJldE9uQ2xpY2sgJiYgXCJcIiA9PT0gZS5wbGFjZWhvbGRlciAmJiAoZS5wb3NpdGlvbkNhcmV0T25DbGljayA9IFwibHZwXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXCIwXCIsIGkgPSBlLnJhZGl4UG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgITAgPT09IGUubnVtZXJpY0lucHV0ICYmIHZvaWQgMCA9PT0gZS5fX2ZpbmFuY2VJbnB1dCA/ICh0ID0gXCIxXCIsIGUucG9zaXRpb25DYXJldE9uQ2xpY2sgPSBcInJhZGl4Rm9jdXNcIiA9PT0gZS5wb3NpdGlvbkNhcmV0T25DbGljayA/IFwibHZwXCIgOiBlLnBvc2l0aW9uQ2FyZXRPbkNsaWNrLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRpZ2l0c09wdGlvbmFsID0gITEsIGlzTmFOKGUuZGlnaXRzKSAmJiAoZS5kaWdpdHMgPSAyKSwgZS5fcmFkaXhEYW5jZSA9ICExLCBpID0gXCIsXCIgPT09IGUucmFkaXhQb2ludCA/IFwiP1wiIDogXCIhXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgIT09IGUucmFkaXhQb2ludCAmJiB2b2lkIDAgPT09IGUuZGVmaW5pdGlvbnNbaV0gJiYgKGUuZGVmaW5pdGlvbnNbaV0gPSB7fSwgZS5kZWZpbml0aW9uc1tpXS52YWxpZGF0b3IgPSBcIltcIiArIGUucmFkaXhQb2ludCArIFwiXVwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRlZmluaXRpb25zW2ldLnBsYWNlaG9sZGVyID0gZS5yYWRpeFBvaW50LCBlLmRlZmluaXRpb25zW2ldLnN0YXRpYyA9ICEwLCBlLmRlZmluaXRpb25zW2ldLmdlbmVyYXRlZCA9ICEwKSkgOiAoZS5fX2ZpbmFuY2VJbnB1dCA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm51bWVyaWNJbnB1dCA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiwgciA9IFwiWytdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgKz0gYyhlLnByZWZpeCwgZSksIFwiXCIgIT09IGUuZ3JvdXBTZXBhcmF0b3IgPyAodm9pZCAwID09PSBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdICYmIChlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdID0ge30sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVmaW5pdGlvbnNbZS5ncm91cFNlcGFyYXRvcl0udmFsaWRhdG9yID0gXCJbXCIgKyBlLmdyb3VwU2VwYXJhdG9yICsgXCJdXCIsIGUuZGVmaW5pdGlvbnNbZS5ncm91cFNlcGFyYXRvcl0ucGxhY2Vob2xkZXIgPSBlLmdyb3VwU2VwYXJhdG9yLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdLnN0YXRpYyA9ICEwLCBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdLmdlbmVyYXRlZCA9ICEwKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSBlLl9tYXNrKGUpKSA6IHIgKz0gXCI5eyt9XCIsIHZvaWQgMCAhPT0gZS5kaWdpdHMgJiYgMCAhPT0gZS5kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlLmRpZ2l0cy50b1N0cmluZygpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGaW5pdGUob1swXSkgJiYgb1sxXSAmJiBpc0Zpbml0ZShvWzFdKSA/IHIgKz0gaSArIHQgKyBcIntcIiArIGUuZGlnaXRzICsgXCJ9XCIgOiAoaXNOYU4oZS5kaWdpdHMpIHx8IHBhcnNlSW50KGUuZGlnaXRzKSA+IDApICYmIChlLmRpZ2l0c09wdGlvbmFsIHx8IGUuaml0TWFza2luZyA/IChuID0gciArIGkgKyB0ICsgXCJ7MCxcIiArIGUuZGlnaXRzICsgXCJ9XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmtlZXBTdGF0aWMgPSAhMCkgOiByICs9IGkgKyB0ICsgXCJ7XCIgKyBlLmRpZ2l0cyArIFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZS5pbnB1dG1vZGUgPSBcIm51bWVyaWNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gciArPSBjKGUuc3VmZml4LCBlKSwgciArPSBcIlstXVwiLCBuICYmIChyID0gWyBuICsgYyhlLnN1ZmZpeCwgZSkgKyBcIlstXVwiLCByIF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmdyZWVkeSA9ICExLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZS5wYXJzZU1pbk1heE9wdGlvbnMgJiYgKG51bGwgIT09IGUubWluICYmIChlLm1pbiA9IGUubWluLnRvU3RyaW5nKCkucmVwbGFjZShuZXcgUmVnRXhwKCgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KShlLmdyb3VwU2VwYXJhdG9yKSwgXCJnXCIpLCBcIlwiKSwgXCIsXCIgPT09IGUucmFkaXhQb2ludCAmJiAoZS5taW4gPSBlLm1pbi5yZXBsYWNlKGUucmFkaXhQb2ludCwgXCIuXCIpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubWluID0gaXNGaW5pdGUoZS5taW4pID8gcGFyc2VGbG9hdChlLm1pbikgOiBOYU4sIGlzTmFOKGUubWluKSAmJiAoZS5taW4gPSBOdW1iZXIuTUlOX1ZBTFVFKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBlLm1heCAmJiAoZS5tYXggPSBlLm1heC50b1N0cmluZygpLnJlcGxhY2UobmV3IFJlZ0V4cCgoMCwgYS5kZWZhdWx0KShlLmdyb3VwU2VwYXJhdG9yKSwgXCJnXCIpLCBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiID09PSBlLnJhZGl4UG9pbnQgJiYgKGUubWF4ID0gZS5tYXgucmVwbGFjZShlLnJhZGl4UG9pbnQsIFwiLlwiKSksIGUubWF4ID0gaXNGaW5pdGUoZS5tYXgpID8gcGFyc2VGbG9hdChlLm1heCkgOiBOYU4sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05hTihlLm1heCkgJiYgKGUubWF4ID0gTnVtYmVyLk1BWF9WQUxVRSkpLCBlLnBhcnNlTWluTWF4T3B0aW9ucyA9IFwiZG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGUpLCBcIlwiICE9PSBlLnJhZGl4UG9pbnQgJiYgZS5zdWJzdGl0dXRlUmFkaXhQb2ludCAmJiAoZS5zdWJzdGl0dXRlc1tcIi5cIiA9PSBlLnJhZGl4UG9pbnQgPyBcIixcIiA6IFwiLlwiXSA9IGUucmFkaXhQb2ludCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgX21hc2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBlLmdyb3VwU2VwYXJhdG9yICsgXCI5OTkpeyt8MX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHM6IFwiKlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzT3B0aW9uYWw6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5mb3JjZURpZ2l0c09uQmx1cjogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpeFBvaW50OiBcIi5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FyZXRPbkNsaWNrOiBcInJhZGl4Rm9jdXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yYWRpeERhbmNlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dNaW51czogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWdhdGlvblN5bWJvbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb250OiBcIi1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgU2V0TWF4T25PdmVyZmxvdzogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRUeXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubWFza0FzTnVtYmVyOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kaW5nRk46IE1hdGgucm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwiZGVjaW1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogXCIxMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbTogXCIxMDAwMDAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBncmVlZHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRBbGlnbjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRNb2RlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Vbm1hc2s6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVByb3RvdHlwZURlZmluaXRpb25zOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwTGVhZGluZ1plcm9lczogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlUmFkaXhQb2ludDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvblN5bWJvbDogXCI5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlcXHVmZjEwLVxcdWZmMTlcXHUwNjYwLVxcdTA2NjlcXHUwNmYwLVxcdTA2ZjldXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25TeW1ib2w6IFwiKlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKGUsIHQsIGksIG4sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmFsbG93TWludXMgJiYgKFwiLVwiID09PSBlIHx8IGUgPT09IGEubmVnYXRpb25TeW1ib2wuZnJvbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKGUsIHQsIGksIG4sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmFsbG93TWludXMgJiYgZSA9PT0gYS5uZWdhdGlvblN5bWJvbC5iYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVZhbGlkYXRpb246IGZ1bmN0aW9uKGUsIHQsIGksIG4sIGEsIHIsIG8sIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgIT09IGEuX19maW5hbmNlSW5wdXQgJiYgaSA9PT0gYS5yYWRpeFBvaW50KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBlLmluZGV4T2YoYS5yYWRpeFBvaW50KSwgYyA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPSBmdW5jdGlvbihlLCB0LCBpLCBuLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9yYWRpeERhbmNlICYmIGEubnVtZXJpY0lucHV0ICYmIHQgIT09IGEubmVnYXRpb25TeW1ib2wuYmFjayAmJiBlIDw9IGkgJiYgKGkgPiAwIHx8IHQgPT0gYS5yYWRpeFBvaW50KSAmJiAodm9pZCAwID09PSBuLnZhbGlkUG9zaXRpb25zW2UgLSAxXSB8fCBuLnZhbGlkUG9zaXRpb25zW2UgLSAxXS5pbnB1dCAhPT0gYS5uZWdhdGlvblN5bWJvbC5iYWNrKSAmJiAoZSAtPSAxKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh0LCBpLCBsLCByLCBhKSwgXCItXCIgPT09IGkgfHwgaSA9PT0gYS5uZWdhdGlvblN5bWJvbC5mcm9udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IGEuYWxsb3dNaW51cykgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9ICExLCBwID0gZChcIitcIiwgciksIGggPSBkKFwiLVwiLCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSBwICYmICh1ID0gWyBwLCBoIF0pLCAhMSAhPT0gdSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZTogdSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiBjIC0gYS5uZWdhdGlvblN5bWJvbC5iYWNrLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0OiBbIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGYuY2FsbCh0aGlzLCBcIitcIiwgciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzogYS5uZWdhdGlvblN5bWJvbC5mcm9udCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tSXNWYWxpZDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGYuY2FsbCh0aGlzLCBcIi1cIiwgciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzogYS5uZWdhdGlvblN5bWJvbC5iYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Jc1ZhbGlkOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiBjICsgYS5uZWdhdGlvblN5bWJvbC5iYWNrLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYS5ncm91cFNlcGFyYXRvcikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQ6IGNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBsICYmICEwID09PSBhLl9yYWRpeERhbmNlICYmICExID09PSBuICYmIGkgPT09IGEucmFkaXhQb2ludCAmJiB2b2lkIDAgIT09IGEuZGlnaXRzICYmIChpc05hTihhLmRpZ2l0cykgfHwgcGFyc2VJbnQoYS5kaWdpdHMpID4gMCkgJiYgbCAhPT0gdCkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQ6IGEuX3JhZGl4RGFuY2UgJiYgdCA9PT0gbCAtIDEgPyBsICsgMSA6IGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gYS5fX2ZpbmFuY2VJbnB1dCkgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuZGlnaXRzT3B0aW9uYWwpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IG8uZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYS5kaWdpdHNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uYmVnaW4gPiBsICYmIG8uZW5kIDw9IGwpIHJldHVybiBpID09PSBhLnJhZGl4UG9pbnQgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogbCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tSXNWYWxpZDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVQb3NpdGlvbjogbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IGwgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uYmVnaW4gPCBsKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVQb3NpdGlvbjogby5iZWdpbiAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFhLnNob3dNYXNrT25Ib3ZlciAmJiAhYS5zaG93TWFza09uRm9jdXMgJiYgIWEuZGlnaXRzT3B0aW9uYWwgJiYgYS5kaWdpdHMgPiAwICYmIFwiXCIgPT09IHRoaXMuX192YWx1ZUdldC5jYWxsKHRoaXMuZWwpKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVQb3NpdGlvbjogdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFZhbGlkYXRpb246IGZ1bmN0aW9uKGUsIHQsIGksIG4sIGEsIHIsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IG4pIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGEubWluIHx8IG51bGwgIT09IGEubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYS5vblVuTWFzayhlLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIiksIHZvaWQgMCwgbC5leHRlbmQoe30sIGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWFza0FzTnVtYmVyOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBhLm1pbiAmJiBzIDwgYS5taW4gJiYgKHMudG9TdHJpbmcoKS5sZW5ndGggPiBhLm1pbi50b1N0cmluZygpLmxlbmd0aCB8fCBzIDwgMCkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGEubWF4ICYmIHMgPiBhLm1heCkgcmV0dXJuICEhYS5TZXRNYXhPbk92ZXJmbG93ICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogdShhLm1heC50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEucmFkaXhQb2ludCkuc3BsaXQoXCJcIiksIGEuZGlnaXRzLCBhKS5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiA9PT0gdCAmJiAhMCA9PT0gaS5udWxsYWJsZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLnJlcGxhY2UoaS5wcmVmaXgsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID0gKG4gPSBuLnJlcGxhY2UoaS5zdWZmaXgsIFwiXCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIGEuZGVmYXVsdCkoaS5ncm91cFNlcGFyYXRvciksIFwiZ1wiKSwgXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgIT09IGkucGxhY2Vob2xkZXIuY2hhckF0KDApICYmIChuID0gbi5yZXBsYWNlKG5ldyBSZWdFeHAoaS5wbGFjZWhvbGRlci5jaGFyQXQoMCksIFwiZ1wiKSwgXCIwXCIpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS51bm1hc2tBc051bWJlciA/IChcIlwiICE9PSBpLnJhZGl4UG9pbnQgJiYgLTEgIT09IG4uaW5kZXhPZihpLnJhZGl4UG9pbnQpICYmIChuID0gbi5yZXBsYWNlKGEuZGVmYXVsdC5jYWxsKHRoaXMsIGkucmFkaXhQb2ludCksIFwiLlwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAobiA9IG4ucmVwbGFjZShuZXcgUmVnRXhwKFwiXlwiICsgKDAsIGEuZGVmYXVsdCkoaS5uZWdhdGlvblN5bWJvbC5mcm9udCkpLCBcIi1cIikpLnJlcGxhY2UobmV3IFJlZ0V4cCgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KShpLm5lZ2F0aW9uU3ltYm9sLmJhY2spICsgXCIkXCIpLCBcIlwiKSwgTnVtYmVyKG4pKSA6IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gKHQubnVtZXJpY0lucHV0ID8gZS5zbGljZSgpLnJldmVyc2UoKSA6IGUpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPSAoaSA9IChpID0gKGkgPSAoaSA9IGkucmVwbGFjZShuZXcgUmVnRXhwKFwiXlwiICsgKDAsIGEuZGVmYXVsdCkodC5uZWdhdGlvblN5bWJvbC5mcm9udCkpLCBcIi1cIikpLnJlcGxhY2UobmV3IFJlZ0V4cCgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KSh0Lm5lZ2F0aW9uU3ltYm9sLmJhY2spICsgXCIkXCIpLCBcIlwiKSkucmVwbGFjZSh0LnByZWZpeCwgXCJcIikpLnJlcGxhY2UodC5zdWZmaXgsIFwiXCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVmYXVsdCkodC5ncm91cFNlcGFyYXRvcikgKyBcIihbMC05XXszfSlcIiwgXCJnXCIpLCBcIiQxXCIpLCBcIixcIiA9PT0gdC5yYWRpeFBvaW50ICYmIChpID0gaS5yZXBsYWNlKCgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQpKHQucmFkaXhQb2ludCksIFwiLlwiKSksIGlzRmluaXRlKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlTWFzazogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC5yYWRpeFBvaW50IHx8IFwiLFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmluaXRlKHQuZGlnaXRzKSAmJiAodC5kaWdpdHMgPSBwYXJzZUludCh0LmRpZ2l0cykpLCBcIm51bWJlclwiICE9IHR5cGVvZiBlICYmIFwibnVtYmVyXCIgIT09IHQuaW5wdXRUeXBlIHx8IFwiXCIgPT09IGkgfHwgKGUgPSBlLnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gXCItXCIgPT09IGUuY2hhckF0KDApIHx8IGUuY2hhckF0KDApID09PSB0Lm5lZ2F0aW9uU3ltYm9sLmZyb250LCByID0gZS5zcGxpdChpKSwgbyA9IHJbMF0ucmVwbGFjZSgvW15cXC0wLTldL2csIFwiXCIpLCBzID0gci5sZW5ndGggPiAxID8gclsxXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikgOiBcIlwiLCBsID0gci5sZW5ndGggPiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBvICsgKFwiXCIgIT09IHMgPyBpICsgcyA6IHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gaSAmJiAoYyA9IHQuZGlnaXRzT3B0aW9uYWwgPyB0LmRpZ2l0cyA8IHMubGVuZ3RoID8gdC5kaWdpdHMgOiBzLmxlbmd0aCA6IHQuZGlnaXRzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBzIHx8ICF0LmRpZ2l0c09wdGlvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBjIHx8IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZS5yZXBsYWNlKCgwLCBhLmRlZmF1bHQpKGkpLCBcIi5cIiksIGlzTmFOKHBhcnNlRmxvYXQoZSkpIHx8IChlID0gKHQucm91bmRpbmdGTihwYXJzZUZsb2F0KGUpICogZikgLyBmKS50b0ZpeGVkKGMpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSB0LmRpZ2l0cyAmJiAtMSAhPT0gZS5pbmRleE9mKGkpICYmIChlID0gZS5zdWJzdHJpbmcoMCwgZS5pbmRleE9mKGkpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHQubWluIHx8IG51bGwgIT09IHQubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZS50b1N0cmluZygpLnJlcGxhY2UoaSwgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB0Lm1pbiAmJiBkIDwgdC5taW4gPyBlID0gdC5taW4udG9TdHJpbmcoKS5yZXBsYWNlKFwiLlwiLCBpKSA6IG51bGwgIT09IHQubWF4ICYmIGQgPiB0Lm1heCAmJiAoZSA9IHQubWF4LnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiBcIi1cIiAhPT0gZS5jaGFyQXQoMCkgJiYgKGUgPSBcIi1cIiArIGUpLCB1KGUudG9TdHJpbmcoKS5zcGxpdChcIlwiKSwgYywgdCwgbCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZVdyaXRlOiBmdW5jdGlvbihlLCB0LCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gbi5fX2ZpbmFuY2VJbnB1dCB8fCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuaW5kZXhPZihuLnJhZGl4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IGkgJiYgZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IG4uZ3JvdXBTZXBhcmF0b3IpIGZvciAoOy0xICE9PSAoaSA9IGUuaW5kZXhPZihuLmdyb3VwU2VwYXJhdG9yKSk7ICkgZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbywgcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5zdHJpcExlYWRpbmdaZXJvZXMgJiYgKHMgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbmV3IFJlZ0V4cChcIiheXCIgKyAoXCJcIiAhPT0gdC5uZWdhdGlvblN5bWJvbC5mcm9udCA/ICgwLCBhLmRlZmF1bHQpKHQubmVnYXRpb25TeW1ib2wuZnJvbnQpICsgXCI/XCIgOiBcIlwiKSArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KSh0LnByZWZpeCkgKyBcIikoLiopKFwiICsgKDAsIGEuZGVmYXVsdCkodC5zdWZmaXgpICsgKFwiXCIgIT0gdC5uZWdhdGlvblN5bWJvbC5iYWNrID8gKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQpKHQubmVnYXRpb25TeW1ib2wuYmFjaykgKyBcIj9cIiA6IFwiXCIpICsgXCIkKVwiKS5leGVjKGUuc2xpY2UoKS5yZXZlcnNlKCkuam9pbihcIlwiKSksIG4gPSBpID8gaVsyXSA6IFwiXCIsIHIgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gJiYgKG4gPSBuLnNwbGl0KHQucmFkaXhQb2ludC5jaGFyQXQoMCkpWzBdLCByID0gbmV3IFJlZ0V4cChcIl5bMFwiICsgdC5ncm91cFNlcGFyYXRvciArIFwiXSpcIikuZXhlYyhuKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKCFyIHx8ICEoclswXS5sZW5ndGggPiAxIHx8IHJbMF0ubGVuZ3RoID4gMCAmJiByWzBdLmxlbmd0aCA8IG4ubGVuZ3RoKSkgJiYgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQsIG4pKSkgZm9yICh2YXIgYyA9IHQuam9pbihcIlwiKS5sYXN0SW5kZXhPZihzWzBdLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpKSAtIChzWzBdID09IHMuaW5wdXQgPyAwIDogMSksIGYgPSBzWzBdID09IHMuaW5wdXQgPyAxIDogMCwgZCA9IHNbMF0ubGVuZ3RoIC0gZjsgZCA+IDA7IGQtLSkgZGVsZXRlIHRoaXMubWFza3NldC52YWxpZFBvc2l0aW9uc1tjICsgZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0W2MgKyBkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2t2YWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IG4ubWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG4ub25Vbk1hc2sodC5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpLCB2b2lkIDAsIGwuZXh0ZW5kKHt9LCBuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXNrQXNOdW1iZXI6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gbi5taW4gJiYgcCA8IG4ubWluKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHUobi5taW4udG9TdHJpbmcoKS5yZXBsYWNlKFwiLlwiLCBuLnJhZGl4UG9pbnQpLnNwbGl0KFwiXCIpLCBuLmRpZ2l0cywgbikucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0W3QubGVuZ3RoIC0gMV0gPT09IG4ubmVnYXRpb25TeW1ib2wuZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gbmV3IFJlZ0V4cChcIiheXCIgKyAoXCJcIiAhPSBuLm5lZ2F0aW9uU3ltYm9sLmZyb250ID8gKDAsIGEuZGVmYXVsdCkobi5uZWdhdGlvblN5bWJvbC5mcm9udCkgKyBcIj9cIiA6IFwiXCIpICsgKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KShuLnByZWZpeCkgKyBcIikoLiopKFwiICsgKDAsIGEuZGVmYXVsdCkobi5zdWZmaXgpICsgKFwiXCIgIT0gbi5uZWdhdGlvblN5bWJvbC5iYWNrID8gKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KShuLm5lZ2F0aW9uU3ltYm9sLmJhY2spICsgXCI/XCIgOiBcIlwiKSArIFwiJClcIikuZXhlYyhyKHQuc2xpY2UoKSwgITApLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPT0gKGggPyBoWzJdIDogXCJcIikgJiYgKG8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEZyb21CdWZmZXI6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogWyAwIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiXCIgIT09IG4ucmFkaXhQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5pbmRleE9mKG4ucmFkaXhQb2ludCkgPT09IG4uc3VmZml4Lmxlbmd0aCAmJiAobyAmJiBvLmJ1ZmZlciA/IG8uYnVmZmVyLnNwbGljZSgwLCAxICsgbi5zdWZmaXgubGVuZ3RoKSA6ICh0LnNwbGljZSgwLCAxICsgbi5zdWZmaXgubGVuZ3RoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHIodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5lbmZvcmNlRGlnaXRzT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IChvID0gbyB8fCB7fSkgJiYgby5idWZmZXIgfHwgdC5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucmVmcmVzaEZyb21CdWZmZXIgPSAhMCwgby5idWZmZXIgPSB1KHYsIG4uZGlnaXRzLCBuLCAhMCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24oZSwgdCwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCByID0gbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMyAhPSBlLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzLCBjID0gZS5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocyA9IG4uc2hvcnRjdXRzICYmIG4uc2hvcnRjdXRzW2NdKSAmJiBzLmxlbmd0aCA+IDEpIHJldHVybiB0aGlzLmlucHV0bWFzay5fX3ZhbHVlU2V0LmNhbGwodGhpcywgcGFyc2VGbG9hdCh0aGlzLmlucHV0bWFzay51bm1hc2tlZHZhbHVlKCkpICogcGFyc2VJbnQocykpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci50cmlnZ2VyKFwic2V0dmFsdWVcIiksICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG8ua2V5cy5BcnJvd1VwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dG1hc2suX192YWx1ZVNldC5jYWxsKHRoaXMsIHBhcnNlRmxvYXQodGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpKSArIHBhcnNlSW50KG4uc3RlcCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci50cmlnZ2VyKFwic2V0dmFsdWVcIiksICExO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG8ua2V5cy5BcnJvd0Rvd246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0bWFzay5fX3ZhbHVlU2V0LmNhbGwodGhpcywgcGFyc2VGbG9hdCh0aGlzLmlucHV0bWFzay51bm1hc2tlZHZhbHVlKCkpIC0gcGFyc2VJbnQobi5zdGVwKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnRyaWdnZXIoXCJzZXR2YWx1ZVwiKSwgITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSAmJiAoZS5rZXkgPT09IG8ua2V5cy5EZWxldGUgfHwgZS5rZXkgPT09IG8ua2V5cy5CYWNrc3BhY2UgfHwgZS5rZXkgPT09IG8ua2V5cy5CQUNLU1BBQ0VfU0FGQVJJKSAmJiBpLmJlZ2luICE9PSB0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodFtlLmtleSA9PT0gby5rZXlzLkRlbGV0ZSA/IGkuYmVnaW4gLSAxIDogaS5lbmRdID09PSBuLm5lZ2F0aW9uU3ltYm9sLmZyb250KSByZXR1cm4gYSA9IHQuc2xpY2UoKS5yZXZlcnNlKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBuLm5lZ2F0aW9uU3ltYm9sLmZyb250ICYmIGEuc2hpZnQoKSwgXCJcIiAhPT0gbi5uZWdhdGlvblN5bWJvbC5iYWNrICYmIGEucG9wKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnRyaWdnZXIoXCJzZXR2YWx1ZVwiLCBbIGEuam9pbihcIlwiKSwgaS5iZWdpbiBdKSwgITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gbi5fcmFkaXhEYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0LmluZGV4T2Yobi5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmRpZ2l0c09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGYpIHJldHVybiAoYSA9IHQuc2xpY2UoKS5yZXZlcnNlKCkpLnBvcCgpLCByLnRyaWdnZXIoXCJzZXR2YWx1ZVwiLCBbIGEuam9pbihcIlwiKSwgaS5iZWdpbiA+PSBhLmxlbmd0aCA/IGEubGVuZ3RoIDogaS5iZWdpbiBdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC0xICE9PSBmICYmIChpLmJlZ2luIDwgZiB8fCBpLmVuZCA8IGYgfHwgZS5rZXkgPT09IG8ua2V5cy5EZWxldGUgJiYgKGkuYmVnaW4gPT09IGYgfHwgaS5iZWdpbiAtIDEgPT09IGYpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpLmJlZ2luID09PSBpLmVuZCAmJiAoZS5rZXkgPT09IG8ua2V5cy5CYWNrc3BhY2UgfHwgZS5rZXkgPT09IG8ua2V5cy5CQUNLU1BBQ0VfU0FGQVJJID8gaS5iZWdpbisrIDogZS5rZXkgPT09IG8ua2V5cy5EZWxldGUgJiYgaS5iZWdpbiAtIDEgPT09IGYgJiYgKGQgPSBsLmV4dGVuZCh7fSwgaSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuYmVnaW4tLSwgaS5lbmQtLSkpLCAoYSA9IHQuc2xpY2UoKS5yZXZlcnNlKCkpLnNwbGljZShhLmxlbmd0aCAtIGkuYmVnaW4sIGkuYmVnaW4gLSBpLmVuZCArIDEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdShhLCBuLmRpZ2l0cywgbikuam9pbihcIlwiKSwgZCAmJiAoaSA9IGQpLCByLnRyaWdnZXIoXCJzZXR2YWx1ZVwiLCBbIGEsIGkuYmVnaW4gPj0gYS5sZW5ndGggPyBmICsgMSA6IGkuYmVnaW4gXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IFwiLFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzT3B0aW9uYWw6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcIm51bWVyaWNcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhczogXCJudW1lcmljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4OiBcIiAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd01pbnVzOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbmRpYW5uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgX21hc2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBlLmdyb3VwU2VwYXJhdG9yICsgXCI5OSl7KnwxfShcIiArIGUuZ3JvdXBTZXBhcmF0b3IgKyBcIjk5OSl7MXwxfVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBcIixcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl4UG9pbnQ6IFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzT3B0aW9uYWw6ICExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5MzgwOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAoKG4gPSBpKDg3NDEpKSAmJiBuLl9fZXNNb2R1bGUgPyBuIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBuXG4gICAgICAgICAgICAgICAgfSkuZGVmYXVsdCA/IHdpbmRvdyA6IHt9O1xuICAgICAgICAgICAgICAgIHQuZGVmYXVsdCA9IGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzc2MDogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5IYW5kbGVOYXRpdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlID8gZS5pbnB1dG1hc2sgOiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5pZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpICE9PSB0ICYmIChlLnBsYWNlaG9sZGVyICE9PSB0IHx8IFwiXCIgPT09IGUucGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSByLmdldEJ1ZmZlci5jYWxsKGkpLnNsaWNlKCksIGEgPSBlLmlucHV0bWFzay5fdmFsdWVHZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSAhPT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT09IG8gJiYgYSA9PT0gci5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGkpLmpvaW4oXCJcIikgPyBuID0gW10gOiAtMSAhPT0gbyAmJiB1LmNhbGwoaSwgbiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkKGUsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUucGxhY2Vob2xkZXIgIT09IHQgJiYgKGUucGxhY2Vob2xkZXIgPSB0LCBcIlwiID09PSBlLnBsYWNlaG9sZGVyICYmIGUucmVtb3ZlQXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpO1xuICAgICAgICAgICAgICAgIH0sIHQuYXBwbHlJbnB1dFZhbHVlID0gYywgdC5jaGVja1ZhbCA9IGYsIHQuY2xlYXJPcHRpb25hbFRhaWwgPSB1LCB0LnVubWFza2VkdmFsdWUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZSA/IGUuaW5wdXRtYXNrIDogdGhpcywgaSA9IHQub3B0cywgbiA9IHQubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUuaW5wdXRtYXNrKSByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrICYmIGUuaW5wdXRtYXNrLnJlZnJlc2hWYWx1ZSAmJiBjKGUsIGUuaW5wdXRtYXNrLl92YWx1ZUdldCghMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbyA9IG4udmFsaWRQb3NpdGlvbnMsIHMgPSAwLCBsID0gby5sZW5ndGg7IHMgPCBsOyBzKyspIG9bc10gJiYgb1tzXS5tYXRjaCAmJiAoMSAhPSBvW3NdLm1hdGNoLnN0YXRpYyB8fCBBcnJheS5pc0FycmF5KG4ubWV0YWRhdGEpICYmICEwICE9PSBvW3NdLmdlbmVyYXRlZElucHV0KSAmJiBhLnB1c2gob1tzXS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gMCA9PT0gYS5sZW5ndGggPyBcIlwiIDogKHQuaXNSVEwgPyBhLnJldmVyc2UoKSA6IGEpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkub25Vbk1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gKHQuaXNSVEwgPyByLmdldEJ1ZmZlci5jYWxsKHQpLnNsaWNlKCkucmV2ZXJzZSgpIDogci5nZXRCdWZmZXIuY2FsbCh0KSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBpLm9uVW5NYXNrLmNhbGwodCwgZiwgdSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgICAgfSwgdC53cml0ZUJ1ZmZlciA9IGQ7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBpKDI4MzkpLCBhID0gaSg0NzEzKSwgciA9IGkoODcxMSksIG8gPSBpKDcyMTUpLCBzID0gaSg5ODQ1KSwgbCA9IGkoNjAzMCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZSA/IGUuaW5wdXRtYXNrIDogdGhpcywgbiA9IGkub3B0cztcbiAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sucmVmcmVzaFZhbHVlID0gITEsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygbi5vbkJlZm9yZU1hc2sgJiYgKHQgPSBuLm9uQmVmb3JlTWFzay5jYWxsKGksIHQsIG4pIHx8IHQpLCBcbiAgICAgICAgICAgICAgICAgICAgZihlLCAhMCwgITEsIHQgPSAodCB8fCBcIlwiKS50b1N0cmluZygpLnNwbGl0KFwiXCIpKSwgaS51bmRvVmFsdWUgPSBpLl92YWx1ZUdldCghMCksIFxuICAgICAgICAgICAgICAgICAgICAobi5jbGVhck1hc2tPbkxvc3RGb2N1cyB8fCBuLmNsZWFySW5jb21wbGV0ZSkgJiYgZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkgPT09IHIuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpKS5qb2luKFwiXCIpICYmIC0xID09PSByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoaSkgJiYgZS5pbnB1dG1hc2suX3ZhbHVlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0LCBpID0gYS5nZXRNYXNrVGVtcGxhdGUuY2FsbCh0aGlzLCAhMCwgMCwgITAsIHZvaWQgMCwgITApOyB2b2lkIDAgIT09ICh0ID0gaS5zaGlmdCgpKTsgKSBlLnB1c2godCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQsIGksIG4sIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlID8gZS5pbnB1dG1hc2sgOiB0aGlzLCB1ID0gYy5tYXNrc2V0LCBmID0gYy5vcHRzLCBwID0gYy5kZXBlbmRlbmN5TGliLCBoID0gbi5zbGljZSgpLCB2ID0gXCJcIiwgbSA9IC0xLCBnID0gdm9pZCAwLCB5ID0gZi5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICBmLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSBcIlwiLCByLnJlc2V0TWFza1NldC5jYWxsKGMpLCB1LnRlc3RzID0ge30sIG0gPSBmLnJhZGl4UG9pbnQgPyByLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbChjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogMFxuICAgICAgICAgICAgICAgICAgICB9LCAhMSwgITEgPT09IGYuX19maW5hbmNlSW5wdXQgPyBcInJhZGl4Rm9jdXNcIiA6IHZvaWQgMCkuYmVnaW4gOiAwLCB1LnAgPSBtLCBjLmNhcmV0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IG1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBbXSwgYiA9IGMuY2FyZXRQb3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoLmZvckVhY2goKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyBwLkV2ZW50KFwiX2NoZWNrdmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4ua2V5ID0gZSwgdiArPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGMsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhLmdldE1hc2tUZW1wbGF0ZS5jYWxsKGMsICEwLCAwKS5zbGljZShlLCByLnNlZWtOZXh0LmNhbGwoYywgZSwgITEsICExKSkuam9pbihcIlwiKS5yZXBsYWNlKC8nL2csIFwiXCIpLCBuID0gaS5pbmRleE9mKHQpOyBuID4gMCAmJiBcIiBcIiA9PT0gaVtuIC0gMV07ICkgbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IDAgPT09IG4gJiYgIXIuaXNNYXNrLmNhbGwoYywgZSkgJiYgKGEuZ2V0VGVzdC5jYWxsKGMsIGUpLm1hdGNoLm5hdGl2ZURlZiA9PT0gdC5jaGFyQXQoMCkgfHwgITAgPT09IGEuZ2V0VGVzdC5jYWxsKGMsIGUpLm1hdGNoLnN0YXRpYyAmJiBhLmdldFRlc3QuY2FsbChjLCBlKS5tYXRjaC5uYXRpdmVEZWYgPT09IFwiJ1wiICsgdC5jaGFyQXQoMCkgfHwgXCIgXCIgPT09IGEuZ2V0VGVzdC5jYWxsKGMsIGUpLm1hdGNoLm5hdGl2ZURlZiAmJiAoYS5nZXRUZXN0LmNhbGwoYywgZSArIDEpLm1hdGNoLm5hdGl2ZURlZiA9PT0gdC5jaGFyQXQoMCkgfHwgITAgPT09IGEuZ2V0VGVzdC5jYWxsKGMsIGUgKyAxKS5tYXRjaC5zdGF0aWMgJiYgYS5nZXRUZXN0LmNhbGwoYywgZSArIDEpLm1hdGNoLm5hdGl2ZURlZiA9PT0gXCInXCIgKyB0LmNoYXJBdCgwKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW8gJiYgbiA+IDAgJiYgIXIuaXNNYXNrLmNhbGwoYywgZSwgITEsICEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByLnNlZWtOZXh0LmNhbGwoYywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhcmV0UG9zLmJlZ2luIDwgcyAmJiAoYy5jYXJldFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShtLCB2KSA/IChnID0gbC5FdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbChjLCBuLCAhMCwgITEsIGksIGMuY2FyZXRQb3MuYmVnaW4pKSAmJiAobSA9IGMuY2FyZXRQb3MuYmVnaW4gKyAxLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gXCJcIikgOiBnID0gbC5FdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbChjLCBuLCAhMCwgITEsIGksIG8gKyAxKSwgZyA/ICh2b2lkIDAgIT09IGcucG9zICYmIHUudmFsaWRQb3NpdGlvbnNbZy5wb3NdICYmICEwID09PSB1LnZhbGlkUG9zaXRpb25zW2cucG9zXS5tYXRjaC5zdGF0aWMgJiYgdm9pZCAwID09PSB1LnZhbGlkUG9zaXRpb25zW2cucG9zXS5hbHRlcm5hdGlvbiAmJiAoay5wdXNoKGcucG9zKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pc1JUTCB8fCAoZy5mb3J3YXJkUG9zaXRpb24gPSBnLnBvcyArIDEpKSwgZC5jYWxsKGMsIHZvaWQgMCwgci5nZXRCdWZmZXIuY2FsbChjKSwgZy5mb3J3YXJkUG9zaXRpb24sIG4sICExKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYXJldFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGcuZm9yd2FyZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGcuZm9yd2FyZFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYiA9IGMuY2FyZXRQb3MpIDogdm9pZCAwID09PSB1LnZhbGlkUG9zaXRpb25zW3RdICYmIGhbdF0gPT09IGEuZ2V0UGxhY2Vob2xkZXIuY2FsbChjLCB0KSAmJiByLmlzTWFzay5jYWxsKGMsIHQsICEwKSA/IGMuY2FyZXRQb3MuYmVnaW4rKyA6IGMuY2FyZXRQb3MgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSksIGsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHgsIFAsIHcgPSByLnNlZWtOZXh0LmNhbGwoYywgLTEsIHZvaWQgMCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvLmlzQ29tcGxldGUuY2FsbChjLCByLmdldEJ1ZmZlci5jYWxsKGMpKSAmJiBrLmxlbmd0aCA8PSB3IHx8IG8uaXNDb21wbGV0ZS5jYWxsKGMsIHIuZ2V0QnVmZmVyLmNhbGwoYykpICYmIGsubGVuZ3RoID4gMCAmJiBrLmxlbmd0aCAhPT0gdyAmJiAwID09PSBrWzBdKSBmb3IgKHZhciBTID0gdzsgdm9pZCAwICE9PSAoeCA9IGsuc2hpZnQoKSk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IHAuRXZlbnQoXCJfY2hlY2t2YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChQID0gdS52YWxpZFBvc2l0aW9uc1t4XSkuZ2VuZXJhdGVkSW5wdXQgPSAhMCwgTS5rZXkgPSBQLmlucHV0LCAoZyA9IGwuRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50LmNhbGwoYywgTSwgITAsICExLCBpLCBTKSkgJiYgdm9pZCAwICE9PSBnLnBvcyAmJiBnLnBvcyAhPT0geCAmJiB1LnZhbGlkUG9zaXRpb25zW2cucG9zXSAmJiAhMCA9PT0gdS52YWxpZFBvc2l0aW9uc1tnLnBvc10ubWF0Y2guc3RhdGljKSBrLnB1c2goZy5wb3MpOyBlbHNlIGlmICghZykgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQgJiYgZC5jYWxsKGMsIGUsIHIuZ2V0QnVmZmVyLmNhbGwoYyksIGcgPyBnLmZvcndhcmRQb3NpdGlvbiA6IGMuY2FyZXRQb3MuYmVnaW4sIHMgfHwgbmV3IHAuRXZlbnQoXCJjaGVja3ZhbFwiKSwgcyAmJiAoXCJpbnB1dFwiID09PSBzLnR5cGUgJiYgYy51bmRvVmFsdWUgIT09IHIuZ2V0QnVmZmVyLmNhbGwoYykuam9pbihcIlwiKSB8fCBcInBhc3RlXCIgPT09IHMudHlwZSkpLCBcbiAgICAgICAgICAgICAgICAgICAgZi5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0LCBpLCBhLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gZSA/IGUuaW5wdXRtYXNrIDogdGhpcywgYyA9IGwub3B0cywgdSA9IGwuZGVwZW5kZW5jeUxpYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBjLm9uQmVmb3JlV3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gYy5vbkJlZm9yZVdyaXRlLmNhbGwobCwgYSwgdCwgaSwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLnJlZnJlc2hGcm9tQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZi5yZWZyZXNoRnJvbUJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5yZWZyZXNoRnJvbUJ1ZmZlci5jYWxsKGwsICEwID09PSBkID8gZCA6IGQuc3RhcnQsIGQuZW5kLCBmLmJ1ZmZlciB8fCB0KSwgdCA9IHIuZ2V0QnVmZmVyLmNhbGwobCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGkgJiYgKGkgPSB2b2lkIDAgIT09IGYuY2FyZXQgPyBmLmNhcmV0IDogaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSAmJiAoZS5pbnB1dG1hc2suX3ZhbHVlU2V0KHQuam9pbihcIlwiKSksIHZvaWQgMCA9PT0gaSB8fCB2b2lkIDAgIT09IGEgJiYgXCJibHVyXCIgPT09IGEudHlwZSB8fCByLmNhcmV0LmNhbGwobCwgZSwgaSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCAhPT0gYSAmJiBcImtleWRvd25cIiA9PT0gYS50eXBlICYmIChhLmtleSA9PT0gbi5rZXlzLkRlbGV0ZSB8fCBhLmtleSA9PT0gbi5rZXlzLkJhY2tzcGFjZSkpLCBcbiAgICAgICAgICAgICAgICAgICAgITAgPT09IHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHUoZSksIGggPSBlLmlucHV0bWFzay5fdmFsdWVHZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrLnNraXBJbnB1dEV2ZW50ID0gITAsIHAudHJpZ2dlcihcImlucHV0XCIpLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID09PSByLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwobCkuam9pbihcIlwiKSA/IHAudHJpZ2dlcihcImNsZWFyZWRcIikgOiAhMCA9PT0gby5pc0NvbXBsZXRlLmNhbGwobCwgdCkgJiYgcC50cmlnZ2VyKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjM5NDogZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBuID0gaSgxNTcpLCBhID0gbShpKDQ5NjMpKSwgciA9IG0oaSg5MzgwKSksIG8gPSBpKDIzOTEpLCBzID0gaSg0NzEzKSwgbCA9IGkoODcxMSksIGMgPSBpKDcyMTUpLCB1ID0gaSg3NzYwKSwgZiA9IGkoOTcxNiksIGQgPSBtKGkoNzM5MikpLCBwID0gbShpKDM5NzYpKSwgaCA9IG0oaSg4NzQxKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIHYoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG0oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZyA9IHIuZGVmYXVsdC5kb2N1bWVudCwgeSA9IFwiX2lucHV0bWFza19vcHRzXCI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gayhlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBrKSkgcmV0dXJuIG5ldyBrKGUsIHQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5TGliID0gYS5kZWZhdWx0LCB0aGlzLmVsID0gdm9pZCAwLCB0aGlzLmV2ZW50cyA9IHt9LCB0aGlzLm1hc2tzZXQgPSB2b2lkIDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgITAgIT09IGkgJiYgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSA/IHQgPSBlIDogKHQgPSB0IHx8IHt9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgJiYgKHQuYWxpYXMgPSBlKSksIHRoaXMub3B0cyA9IGEuZGVmYXVsdC5leHRlbmQoITAsIHt9LCB0aGlzLmRlZmF1bHRzLCB0KSwgdGhpcy5ub01hc2tzQ2FjaGUgPSB0ICYmIHZvaWQgMCAhPT0gdC5kZWZpbml0aW9ucywgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJPcHRpb25zID0gdCB8fCB7fSwgYih0aGlzLm9wdHMuYWxpYXMsIHQsIHRoaXMub3B0cykpLCB0aGlzLnJlZnJlc2hWYWx1ZSA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5kb1ZhbHVlID0gdm9pZCAwLCB0aGlzLiRlbCA9IHZvaWQgMCwgdGhpcy5za2lwSW5wdXRFdmVudCA9ICExLCB0aGlzLnZhbGlkYXRpb25FdmVudCA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWdub3JhYmxlID0gITEsIHRoaXMubWF4TGVuZ3RoLCB0aGlzLm1vdXNlRW50ZXIgPSAhMSwgdGhpcy5jbGlja2VkID0gMCwgdGhpcy5vcmlnaW5hbFBsYWNlaG9sZGVyID0gdm9pZCAwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb21wb3NpbmcgPSAhMSwgdGhpcy5oYXNBbHRlcm5hdG9yID0gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gay5wcm90b3R5cGUuYWxpYXNlc1tlXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPyAobi5hbGlhcyAmJiBiKG4uYWxpYXMsIHZvaWQgMCwgaSksIGEuZGVmYXVsdC5leHRlbmQoITAsIGksIG4pLCBhLmRlZmF1bHQuZXh0ZW5kKCEwLCBpLCB0KSwgXG4gICAgICAgICAgICAgICAgICAgICEwKSA6IChudWxsID09PSBpLm1hc2sgJiYgKGkubWFzayA9IGUpLCAhMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlOiBcImRhdGEtaW5wdXRtYXNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBwLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBkLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBtYXNrc0NhY2hlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGlzUlRMKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5pc1JUTCB8fCB0aGlzLm9wdHMubnVtZXJpY0lucHV0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAoZSA9IGcuZ2V0RWxlbWVudEJ5SWQoZSkgfHwgZy5xdWVyeVNlbGVjdG9yQWxsKGUpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAoZSA9IGUubm9kZU5hbWUgPyBbIGUgXSA6IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW10uc2xpY2UuY2FsbChlKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYS5kZWZhdWx0LmV4dGVuZCghMCwge30sIHQub3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyh0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFwiXCIgPT09IG4gPyB0IDogbiArIFwiLVwiICsgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IChhID0gdm9pZCAwICE9PSBhID8gYSA6IGUuZ2V0QXR0cmlidXRlKG8pKSAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYSAmJiAoMCA9PT0gdC5pbmRleE9mKFwib25cIikgPyBhID0gci5kZWZhdWx0W2FdIDogXCJmYWxzZVwiID09PSBhID8gYSA9ICExIDogXCJ0cnVlXCIgPT09IGEgJiYgKGEgPSAhMCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlbdF0gPSBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHQuaW1wb3J0RGF0YUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzLCBsLCBjLCB1LCBmID0gZS5nZXRBdHRyaWJ1dGUobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZiAmJiBcIlwiICE9PSBmICYmIChmID0gZi5yZXBsYWNlKC8nL2csICdcIicpLCBsID0gSlNPTi5wYXJzZShcIntcIiArIGYgKyBcIn1cIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwpIGZvciAodSBpbiBjID0gdm9pZCAwLCBsKSBpZiAoXCJhbGlhc1wiID09PSB1LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbFt1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocyBpbiBvKFwiYWxpYXNcIiwgYyksIGkuYWxpYXMgJiYgYihpLmFsaWFzLCBpLCB0KSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsKSBmb3IgKHUgaW4gYyA9IHZvaWQgMCwgbCkgaWYgKHUudG9Mb3dlckNhc2UoKSA9PT0gcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBsW3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyhzLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQuZXh0ZW5kKCEwLCB0LCBpKSwgKFwicnRsXCIgPT09IGUuZGlyIHx8IHQucmlnaHRBbGlnbikgJiYgKGUuc3R5bGUudGV4dEFsaWduID0gXCJyaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwicnRsXCIgPT09IGUuZGlyIHx8IHQubnVtZXJpY0lucHV0KSAmJiAoZS5kaXIgPSBcImx0clwiLCBlLnJlbW92ZUF0dHJpYnV0ZShcImRpclwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaXNSVEwgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlLCBzLCBhLmRlZmF1bHQuZXh0ZW5kKCEwLCB7fSwgdC51c2VyT3B0aW9ucyksIHQuZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSAoMCwgby5nZW5lcmF0ZU1hc2tTZXQpKHMsIHQubm9NYXNrc0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBsICYmICh2b2lkIDAgIT09IGUuaW5wdXRtYXNrICYmIChlLmlucHV0bWFzay5vcHRzLmF1dG9Vbm1hc2sgPSAhMCwgZS5pbnB1dG1hc2sucmVtb3ZlKCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sgPSBuZXcgayh2b2lkIDAsIHZvaWQgMCwgITApLCBlLmlucHV0bWFzay5vcHRzID0gcywgZS5pbnB1dG1hc2subm9NYXNrc0NhY2hlID0gdC5ub01hc2tzQ2FjaGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzay51c2VyT3B0aW9ucyA9IGEuZGVmYXVsdC5leHRlbmQoITAsIHt9LCB0LnVzZXJPcHRpb25zKSwgZS5pbnB1dG1hc2suZWwgPSBlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2suJGVsID0gKDAsIGEuZGVmYXVsdCkoZSksIGUuaW5wdXRtYXNrLm1hc2tzZXQgPSBsLCBhLmRlZmF1bHQuZGF0YShlLCB5LCB0LnVzZXJPcHRpb25zKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4ubWFzay5jYWxsKGUuaW5wdXRtYXNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlICYmIGVbMF0gJiYgZVswXS5pbnB1dG1hc2sgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IHRoaXMub3B0c1tlXSA6IFwib2JqZWN0XCIgPT09IHYoZSkgPyAoYS5kZWZhdWx0LmV4dGVuZCh0aGlzLnVzZXJPcHRpb25zLCBlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsICYmICEwICE9PSB0ICYmIHRoaXMubWFzayh0aGlzLmVsKSwgdGhpcykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVubWFza2VkdmFsdWU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgKDAsIG8uZ2VuZXJhdGVNYXNrU2V0KSh0aGlzLm9wdHMsIHRoaXMubm9NYXNrc0NhY2hlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHRoaXMuZWwgfHwgdm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLm9wdHMub25CZWZvcmVNYXNrICYmIHRoaXMub3B0cy5vbkJlZm9yZU1hc2suY2FsbCh0aGlzLCBlLCB0aGlzLm9wdHMpIHx8IGUpLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUuY2hlY2tWYWwuY2FsbCh0aGlzLCB2b2lkIDAsICExLCAhMSwgdCksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlV3JpdGUgJiYgdGhpcy5vcHRzLm9uQmVmb3JlV3JpdGUuY2FsbCh0aGlzLCB2b2lkIDAsIGwuZ2V0QnVmZmVyLmNhbGwodGhpcyksIDAsIHRoaXMub3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdS51bm1hc2tlZHZhbHVlLmNhbGwodGhpcywgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVmYXVsdC5kYXRhKHRoaXMuZWwsIHksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcHRzLmF1dG9Vbm1hc2sgPyAoMCwgdS51bm1hc2tlZHZhbHVlKSh0aGlzLmVsKSA6IHRoaXMuX3ZhbHVlR2V0KHRoaXMub3B0cy5hdXRvVW5tYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlICE9PSBsLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodGhpcykuam9pbihcIlwiKSA/IHRoaXMuX3ZhbHVlU2V0KGUsIHRoaXMub3B0cy5hdXRvVW5tYXNrKSA6IHRoaXMuX3ZhbHVlU2V0KFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLkV2ZW50UnVsZXIub2ZmKHRoaXMuZWwpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuZWwpLCBcInZhbHVlXCIpICYmIHRoaXMuX192YWx1ZUdldCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbCwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogdGhpcy5fX3ZhbHVlR2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IHRoaXMuX192YWx1ZVNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogZy5fX2xvb2t1cEdldHRlcl9fICYmIHRoaXMuZWwuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpICYmIHRoaXMuX192YWx1ZUdldCAmJiAodGhpcy5lbC5fX2RlZmluZUdldHRlcl9fKFwidmFsdWVcIiwgdGhpcy5fX3ZhbHVlR2V0KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5fX2RlZmluZVNldHRlcl9fKFwidmFsdWVcIiwgdGhpcy5fX3ZhbHVlU2V0KSksIHRoaXMuZWwuaW5wdXRtYXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldGVtcHR5bWFzazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCBvLmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyBsLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodGhpcykucmV2ZXJzZSgpIDogbC5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHRoaXMpKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoYXNNYXNrZWRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMub3B0cy5hdXRvVW5tYXNrO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgKDAsIG8uZ2VuZXJhdGVNYXNrU2V0KSh0aGlzLm9wdHMsIHRoaXMubm9NYXNrc0NhY2hlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmlzQ29tcGxldGUuY2FsbCh0aGlzLCBsLmdldEJ1ZmZlci5jYWxsKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0bWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCAoMCwgby5nZW5lcmF0ZU1hc2tTZXQpKHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5tYXNrc2V0Lm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gcy5nZXRNYXNrVGVtcGxhdGUuY2FsbCh0aGlzLCAhMCwgMCwgITEpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza3NldC5tZXRhZGF0YS5mb3JFYWNoKChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0Lm1hc2sgIT09IGUgfHwgKGUgPSB0LCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza3NldC5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCAoMCwgby5nZW5lcmF0ZU1hc2tTZXQpKHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMub3B0cy5vbkJlZm9yZU1hc2sgJiYgdGhpcy5vcHRzLm9uQmVmb3JlTWFzay5jYWxsKHRoaXMsIGUsIHRoaXMub3B0cykgfHwgZSkuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdS5jaGVja1ZhbC5jYWxsKHRoaXMsIHZvaWQgMCwgITAsICExLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBlID0gdGhpcy5pc1JUTCA/IGwuZ2V0QnVmZmVyLmNhbGwodGhpcykuc2xpY2UoKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGwuZ2V0QnVmZmVyLmNhbGwodGhpcykuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsLmdldEJ1ZmZlci5jYWxsKHRoaXMpLCBuID0gbC5kZXRlcm1pbmVMYXN0UmVxdWlyZWRQb3NpdGlvbi5jYWxsKHRoaXMpLCBhID0gaS5sZW5ndGggLSAxOyBhID4gbiAmJiAhbC5pc01hc2suY2FsbCh0aGlzLCBhKTsgYS0tKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaS5zcGxpY2UobiwgYSArIDEgLSBuKSwgYy5pc0NvbXBsZXRlLmNhbGwodGhpcywgaSkgJiYgZSA9PT0gKHRoaXMuaXNSVEwgPyBsLmdldEJ1ZmZlci5jYWxsKHRoaXMpLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIikgOiBsLmdldEJ1ZmZlci5jYWxsKHRoaXMpLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCAoMCwgby5nZW5lcmF0ZU1hc2tTZXQpKHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLm9wdHMub25CZWZvcmVNYXNrICYmIHRoaXMub3B0cy5vbkJlZm9yZU1hc2suY2FsbCh0aGlzLCBlLCB0aGlzLm9wdHMpIHx8IGUpLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdS5jaGVja1ZhbC5jYWxsKHRoaXMsIHZvaWQgMCwgITAsICExLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5pc1JUTCA/IGwuZ2V0QnVmZmVyLmNhbGwodGhpcykuc2xpY2UoKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGwuZ2V0QnVmZmVyLmNhbGwodGhpcykuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLmdldG1ldGFkYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBuO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbCAmJiAoMCwgYS5kZWZhdWx0KSh0aGlzLmVsKS50cmlnZ2VyKFwic2V0dmFsdWVcIiwgWyBlIF0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhbmFseXNlTWFzazogby5hbmFseXNlTWFza1xuICAgICAgICAgICAgICAgIH0sIGsuZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGEuZGVmYXVsdC5leHRlbmQoITAsIGsucHJvdG90eXBlLmRlZmF1bHRzLCBlKTtcbiAgICAgICAgICAgICAgICB9LCBrLmV4dGVuZERlZmluaXRpb25zID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQuZXh0ZW5kKCEwLCBrLnByb3RvdHlwZS5kZWZpbml0aW9ucywgZSk7XG4gICAgICAgICAgICAgICAgfSwgay5leHRlbmRBbGlhc2VzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQuZXh0ZW5kKCEwLCBrLnByb3RvdHlwZS5hbGlhc2VzLCBlKTtcbiAgICAgICAgICAgICAgICB9LCBrLmZvcm1hdCA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsodCkuZm9ybWF0KGUsIGkpO1xuICAgICAgICAgICAgICAgIH0sIGsudW5tYXNrID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gayh0KS51bm1hc2tlZHZhbHVlKGUpO1xuICAgICAgICAgICAgICAgIH0sIGsuaXNWYWxpZCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsodCkuaXNWYWxpZChlKTtcbiAgICAgICAgICAgICAgICB9LCBrLnJlbW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAoZSA9IGcuZ2V0RWxlbWVudEJ5SWQoZSkgfHwgZy5xdWVyeVNlbGVjdG9yQWxsKGUpKSwgKGUgPSBlLm5vZGVOYW1lID8gWyBlIF0gOiBlKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzayAmJiBlLmlucHV0bWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIGsuc2V0VmFsdWUgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSBnLmdldEVsZW1lbnRCeUlkKGUpIHx8IGcucXVlcnlTZWxlY3RvckFsbChlKSksIChlID0gZS5ub2RlTmFtZSA/IFsgZSBdIDogZSkuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sgPyBlLmlucHV0bWFzay5zZXRWYWx1ZSh0KSA6ICgwLCBhLmRlZmF1bHQpKGUpLnRyaWdnZXIoXCJzZXR2YWx1ZVwiLCBbIHQgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCBrLmRlcGVuZGVuY3lMaWIgPSBhLmRlZmF1bHQsIHIuZGVmYXVsdC5JbnB1dG1hc2sgPSBrO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gaztcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSB4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDUyOTY6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBoKGkoOTM4MCkpLCByID0gaChpKDIzOTQpKSwgbyA9IGgoaSg4NzQxKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5lbnVtZXJhYmxlID0gYS5lbnVtZXJhYmxlIHx8ICExLCBhLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gYSAmJiAoYS53cml0YWJsZSA9ICEwKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgKHIgPSBhLmtleSwgbyA9IHZvaWQgMCwgbyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gbihlKSB8fCBudWxsID09PSBlKSByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gaS5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gbihhKSkgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcInN0cmluZ1wiID09PSB0ID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0ociwgXCJzdHJpbmdcIiksIFwic3ltYm9sXCIgPT09IG4obykgPyBvIDogU3RyaW5nKG8pKSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHIsIG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGYoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGEgPSBwKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHAodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IFJlZmxlY3QuY29uc3RydWN0KGEsIGFyZ3VtZW50cywgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaSA9IGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgKFwib2JqZWN0XCIgPT09IG4odCkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0KSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgaSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgTWFwID8gbmV3IE1hcCA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gZSB8fCAoaSA9IGUsIC0xID09PSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGkpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKSkgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5oYXMoZSkpIHJldHVybiB0LmdldChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNldChlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHUoZSwgYXJndW1lbnRzLCBwKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBkKG4sIGUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHUgPSBmKCkgPyBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCkgOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFsgbnVsbCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5wdXNoLmFwcGx5KG4sIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoZSwgbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJiYgZChhLCBpLnByb3RvdHlwZSksIGE7XG4gICAgICAgICAgICAgICAgICAgIH0sIHUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCAoZnVuY3Rpb24oKSB7fSkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gPSB0LCBlO1xuICAgICAgICAgICAgICAgICAgICB9LCBkKGUsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2ID0gYS5kZWZhdWx0LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvLmRlZmF1bHQgJiYgdiAmJiB2LmhlYWQgJiYgdi5oZWFkLmF0dGFjaFNoYWRvdyAmJiBhLmRlZmF1bHQuY3VzdG9tRWxlbWVudHMgJiYgdm9pZCAwID09PSBhLmRlZmF1bHQuY3VzdG9tRWxlbWVudHMuZ2V0KFwiaW5wdXQtbWFza1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB0ICYmIGQoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KG8sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQsIGksIG4sIGEgPSBsKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IChlID0gYS5jYWxsKHRoaXMpKS5nZXRBdHRyaWJ1dGVOYW1lcygpLCBpID0gZS5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNsb3NlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIG4gPSB2LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIG4udHlwZSA9IFwidGV4dFwiLCBpLmFwcGVuZENoaWxkKG4pLCB0KSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgcykgJiYgbi5zZXRBdHRyaWJ1dGUodFtzXSwgZS5nZXRBdHRyaWJ1dGUodFtzXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gbmV3IHIuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbC5kYXRhQXR0cmlidXRlID0gXCJcIiwgbC5tYXNrKG4pLCBuLmlucHV0bWFzay5zaGFkb3dSb290ID0gaSwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID0gbywgaSAmJiBzKHQucHJvdG90eXBlLCBpKSwgbiAmJiBzKHQsIG4pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQ7XG4gICAgICAgICAgICAgICAgICAgIH0oYyhIVE1MRWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwiaW5wdXQtbWFza1wiLCBtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjgzOTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9KGUpIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbnVsbCA9PSBlID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sIGEsIHIsIG8sIHMgPSBbXSwgbCA9ICEwLCBjID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSAoaSA9IGkuY2FsbChlKSkubmV4dCwgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdChpKSAhPT0gaSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZm9yICg7IShsID0gKG4gPSByLmNhbGwoaSkpLmRvbmUpICYmIChzLnB1c2gobi52YWx1ZSksIHMubGVuZ3RoICE9PSB0KTsgbCA9ICEwKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gITAsIGEgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWwgJiYgbnVsbCAhPSBpLnJldHVybiAmJiAobyA9IGkucmV0dXJuKCksIE9iamVjdChvKSAhPT0gbykpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjKSB0aHJvdyBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KGUsIHQpIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiBuKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gaSAmJiBlLmNvbnN0cnVjdG9yICYmIChpID0gZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIk1hcFwiID09PSBpIHx8IFwiU2V0XCIgPT09IGkpIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQXJndW1lbnRzXCIgPT09IGkgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QoaSkpIHJldHVybiBuKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9KGUsIHQpIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gdCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5ldyBBcnJheSh0KTsgaSA8IHQ7IGkrKykgbltpXSA9IGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQua2V5cyA9IHQua2V5Q29kZSA9IHZvaWQgMCwgdC50b0tleSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJbZV0gfHwgKHQgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpIDogU3RyaW5nLmZyb21DaGFyQ29kZShlKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9LCB0LnRvS2V5Q29kZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbZV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgICAgICAgICAgQWx0R3JhcGg6IDE4LFxuICAgICAgICAgICAgICAgICAgICBBcnJvd0Rvd246IDQwLFxuICAgICAgICAgICAgICAgICAgICBBcnJvd0xlZnQ6IDM3LFxuICAgICAgICAgICAgICAgICAgICBBcnJvd1JpZ2h0OiAzOSxcbiAgICAgICAgICAgICAgICAgICAgQXJyb3dVcDogMzgsXG4gICAgICAgICAgICAgICAgICAgIEJhY2tzcGFjZTogOCxcbiAgICAgICAgICAgICAgICAgICAgQkFDS1NQQUNFX1NBRkFSSTogMTI3LFxuICAgICAgICAgICAgICAgICAgICBDYXBzTG9jazogMjAsXG4gICAgICAgICAgICAgICAgICAgIERlbGV0ZTogNDYsXG4gICAgICAgICAgICAgICAgICAgIEVuZDogMzUsXG4gICAgICAgICAgICAgICAgICAgIEVudGVyOiAxMyxcbiAgICAgICAgICAgICAgICAgICAgRXNjYXBlOiAyNyxcbiAgICAgICAgICAgICAgICAgICAgSG9tZTogMzYsXG4gICAgICAgICAgICAgICAgICAgIEluc2VydDogNDUsXG4gICAgICAgICAgICAgICAgICAgIFBhZ2VEb3duOiAzNCxcbiAgICAgICAgICAgICAgICAgICAgUGFnZVVwOiAzMyxcbiAgICAgICAgICAgICAgICAgICAgU3BhY2U6IDMyLFxuICAgICAgICAgICAgICAgICAgICBUYWI6IDksXG4gICAgICAgICAgICAgICAgICAgIGM6IDY3LFxuICAgICAgICAgICAgICAgICAgICB4OiA4OCxcbiAgICAgICAgICAgICAgICAgICAgejogOTAsXG4gICAgICAgICAgICAgICAgICAgIFNoaWZ0OiAxNixcbiAgICAgICAgICAgICAgICAgICAgQ29udHJvbDogMTcsXG4gICAgICAgICAgICAgICAgICAgIEFsdDogMTgsXG4gICAgICAgICAgICAgICAgICAgIFBhdXNlOiAxOSxcbiAgICAgICAgICAgICAgICAgICAgTWV0YV9MRUZUOiA5MSxcbiAgICAgICAgICAgICAgICAgICAgTWV0YV9SSUdIVDogOTIsXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNZW51OiA5MyxcbiAgICAgICAgICAgICAgICAgICAgUHJvY2VzczogMjI5LFxuICAgICAgICAgICAgICAgICAgICBVbmlkZW50aWZpZWQ6IDIyOSxcbiAgICAgICAgICAgICAgICAgICAgRjE6IDExMixcbiAgICAgICAgICAgICAgICAgICAgRjI6IDExMyxcbiAgICAgICAgICAgICAgICAgICAgRjM6IDExNCxcbiAgICAgICAgICAgICAgICAgICAgRjQ6IDExNSxcbiAgICAgICAgICAgICAgICAgICAgRjU6IDExNixcbiAgICAgICAgICAgICAgICAgICAgRjY6IDExNyxcbiAgICAgICAgICAgICAgICAgICAgRjc6IDExOCxcbiAgICAgICAgICAgICAgICAgICAgRjg6IDExOSxcbiAgICAgICAgICAgICAgICAgICAgRjk6IDEyMCxcbiAgICAgICAgICAgICAgICAgICAgRjEwOiAxMjEsXG4gICAgICAgICAgICAgICAgICAgIEYxMTogMTIyLFxuICAgICAgICAgICAgICAgICAgICBGMTI6IDEyM1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdC5rZXlDb2RlID0gYTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IE9iamVjdC5lbnRyaWVzKGEpLnJlZHVjZSgoZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGkodCwgMiksIGEgPSBuWzBdLCByID0gblsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVbcl0gPSB2b2lkIDAgPT09IGVbcl0gPyBhIDogZVtyXSwgZTtcbiAgICAgICAgICAgICAgICB9KSwge30pLCBvID0gT2JqZWN0LmVudHJpZXMoYSkucmVkdWNlKChmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gaSh0LCAyKSwgYSA9IG5bMF07XG4gICAgICAgICAgICAgICAgICAgIG5bMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlW2FdID0gXCJTcGFjZVwiID09PSBhID8gXCIgXCIgOiBhLCBlO1xuICAgICAgICAgICAgICAgIH0pLCB7fSk7XG4gICAgICAgICAgICAgICAgdC5rZXlzID0gbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyMzkxOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmFuYWx5c2VNYXNrID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiwgbywgcywgbCwgYywgdSwgZiA9IC8oPzpbPyorXXxcXHtbMC05KypdKyg/OixbMC05KypdKik/KD86XFx8WzAtOSsqXSopP1xcfSl8W14uPyorXiR7W10oKXxcXFxcXSt8Li9nLCBkID0gL1xcW1xcXj9dPyg/OlteXFxcXFxcXV0rfFxcXFxbXFxTXFxzXT8pKl0/fFxcXFwoPzowKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/KT98WzEtOV1bMC05XSp8eFswLTlBLUZhLWZdezJ9fHVbMC05QS1GYS1mXXs0fXxjW0EtWmEtel18W1xcU1xcc10/KXxcXCgoPzpcXD9bOj0hXT8pP3woPzpbPyorXXxcXHtbMC05XSsoPzosWzAtOV0qKT9cXH0pXFw/P3xbXi4/KiteJHtbKCl8XFxcXF0rfC4vZywgcCA9ICExLCBoID0gbmV3IGEuZGVmYXVsdCwgdiA9IFtdLCBtID0gW10sIGcgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24geShlLCBuLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdm9pZCAwICE9PSBhID8gYSA6IGUubWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGUubWF0Y2hlc1thIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBuLmluZGV4T2YoXCJbXCIpIHx8IHAgJiYgL1xcXFxkfFxcXFxzfFxcXFx3fFxcXFxwL2kudGVzdChuKSB8fCBcIi5cIiA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGkuY2FzaW5nID8gXCJpXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXlxcXFxwXFx7Lip9JC9pLnRlc3QobikgJiYgKHMgKz0gXCJ1XCIpLCBlLm1hdGNoZXMuc3BsaWNlKGErKywgMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IG5ldyBSZWdFeHAobiwgcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2tNYXJrZXI6IHZvaWQgMCA9PT0gbyA/IFwibWFzdGVyXCIgOiBvLmRlZiAhPT0gbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHAgJiYgKG4gPSBuW24ubGVuZ3RoIC0gMV0pLCBuLnNwbGl0KFwiXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGUubWF0Y2hlc1thIC0gMV0sIGUubWF0Y2hlcy5zcGxpY2UoYSsrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogL1thLXpdL2kudGVzdChpLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgdCkgPyBuZXcgUmVnRXhwKFwiW1wiICsgKGkuc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCB0KSArIFwiXVwiLCBpLmNhc2luZyA/IFwiaVwiIDogXCJcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiB2b2lkIDAgPT09IG8gPyBcIm1hc3RlclwiIDogby5kZWYgIT09IHQgJiYgITAgIT09IG8uc3RhdGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBpLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB2b2lkIDAgIT09IGkuc3RhdGljRGVmaW5pdGlvblN5bWJvbCA/IHQgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IChwID8gXCInXCIgOiBcIlwiKSArIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBpLmRlZmluaXRpb25zICYmIGkuZGVmaW5pdGlvbnNbbl0gfHwgaS51c2VQcm90b3R5cGVEZWZpbml0aW9ucyAmJiByLmRlZmF1bHQucHJvdG90eXBlLmRlZmluaXRpb25zW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgIXAgPyBlLm1hdGNoZXMuc3BsaWNlKGErKywgMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogbC52YWxpZGF0b3IgPyBcInN0cmluZ1wiID09IHR5cGVvZiBsLnZhbGlkYXRvciA/IG5ldyBSZWdFeHAobC52YWxpZGF0b3IsIGkuY2FzaW5nID8gXCJpXCIgOiBcIlwiKSA6IG5ldyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVzdCA9IGwudmFsaWRhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogbmV3IFJlZ0V4cChcIi5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpYzogbC5zdGF0aWMgfHwgITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiBsLm9wdGlvbmFsIHx8ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZPcHRpb25hbGl0eTogbC5vcHRpb25hbCB8fCAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2tNYXJrZXI6IHZvaWQgMCA9PT0gbyB8fCBsLm9wdGlvbmFsID8gXCJtYXN0ZXJcIiA6IG8uZGVmICE9PSAobC5kZWZpbml0aW9uU3ltYm9sIHx8IG4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IGwuY2FzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGwuZGVmaW5pdGlvblN5bWJvbCB8fCBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbC5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVmOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IGwuZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiAoZS5tYXRjaGVzLnNwbGljZShhKyssIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IC9bYS16XS9pLnRlc3QoaS5zdGF0aWNEZWZpbml0aW9uU3ltYm9sIHx8IG4pID8gbmV3IFJlZ0V4cChcIltcIiArIChpLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgbikgKyBcIl1cIiwgaS5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9ja01hcmtlcjogdm9pZCAwID09PSBvID8gXCJtYXN0ZXJcIiA6IG8uZGVmICE9PSBuICYmICEwICE9PSBvLnN0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGkuc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdm9pZCAwICE9PSBpLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgPyBuIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IChwID8gXCInXCIgOiBcIlwiKSArIG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgcCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5KGwgPSB2W3YubGVuZ3RoIC0gMV0sIG8pLCBsLmlzQWx0ZXJuYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBjLm1hdGNoZXMubGVuZ3RoOyBlKyspIGMubWF0Y2hlc1tlXS5pc0dyb3VwICYmIChjLm1hdGNoZXNbZV0uaXNHcm91cCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5sZW5ndGggPiAwID8gKGwgPSB2W3YubGVuZ3RoIC0gMV0pLm1hdGNoZXMucHVzaChjKSA6IGgubWF0Y2hlcy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB5KGgsIG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGIoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgYS5kZWZhdWx0KCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0Lm9wZW5Hcm91cCA9ICExLCB0Lm1hdGNoZXMgPSBlLCB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHgoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHMgPSB2LnBvcCgpKS5vcGVuR3JvdXAgPSAhMSwgdm9pZCAwICE9PSBzKSBpZiAodi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChsID0gdlt2Lmxlbmd0aCAtIDFdKS5tYXRjaGVzLnB1c2gocyksIGwuaXNBbHRlcm5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAoYyA9IHYucG9wKCkpLm1hdGNoZXNbMF0ubWF0Y2hlcyA/IGMubWF0Y2hlc1swXS5tYXRjaGVzLmxlbmd0aCA6IDEsIHQgPSAwOyB0IDwgYy5tYXRjaGVzLmxlbmd0aDsgdCsrKSBjLm1hdGNoZXNbdF0uaXNHcm91cCA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tYXRjaGVzW3RdLmFsdGVybmF0b3JHcm91cCA9ICExLCBudWxsID09PSBpLmtlZXBTdGF0aWMgJiYgZSA8IChjLm1hdGNoZXNbdF0ubWF0Y2hlcyA/IGMubWF0Y2hlc1t0XS5tYXRjaGVzLmxlbmd0aCA6IDEpICYmIChpLmtlZXBTdGF0aWMgPSAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gYy5tYXRjaGVzW3RdLm1hdGNoZXMgPyBjLm1hdGNoZXNbdF0ubWF0Y2hlcy5sZW5ndGggOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Lmxlbmd0aCA+IDAgPyAobCA9IHZbdi5sZW5ndGggLSAxXSkubWF0Y2hlcy5wdXNoKGMpIDogaC5tYXRjaGVzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGgubWF0Y2hlcy5wdXNoKHMpOyBlbHNlIGsoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlzUXVhbnRpZmllciAmJiAodCA9IGIoWyBlLnBvcCgpLCB0IF0pKSwgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ICYmIChpLm9wdGlvbmFsbWFya2VyWzBdID0gdm9pZCAwLCBpLm9wdGlvbmFsbWFya2VyWzFdID0gdm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7biA9IHQgPyBkLmV4ZWMoZSkgOiBmLmV4ZWMoZSk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPSBuWzBdLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFwiezAsMX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gXCJ7XCIgKyBvICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gYihoLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5vcGVuR3JvdXAgPSAhMCwgdi5wdXNoKHcpLCBoLm1hdGNoZXMgPSBbXSwgZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBcIlswLTldXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXHBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyArPSBkLmV4ZWMoZSlbMF0sIG8gKz0gZC5leGVjKGUpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwKSBrKCk7IGVsc2Ugc3dpdGNoIChvLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgfHwgaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaS5lc2NhcGVDaGFyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAhMCwgdCAmJiBrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBpLm9wdGlvbmFsbWFya2VyWzFdOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGkuZ3JvdXBtYXJrZXJbMV06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaS5vcHRpb25hbG1hcmtlclswXTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LnB1c2gobmV3IGEuZGVmYXVsdCghMSwgITApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGkuZ3JvdXBtYXJrZXJbMF06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5wdXNoKG5ldyBhLmRlZmF1bHQoITApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGkucXVhbnRpZmllcm1hcmtlclswXTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUyA9IG5ldyBhLmRlZmF1bHQoITEsICExLCAhMCksIE0gPSAobyA9IG8ucmVwbGFjZSgvW3t9P10vZywgXCJcIikpLnNwbGl0KFwifFwiKSwgXyA9IE1bMF0uc3BsaXQoXCIsXCIpLCBPID0gaXNOYU4oX1swXSkgPyBfWzBdIDogcGFyc2VJbnQoX1swXSksIEUgPSAxID09PSBfLmxlbmd0aCA/IE8gOiBpc05hTihfWzFdKSA/IF9bMV0gOiBwYXJzZUludChfWzFdKSwgVCA9IGlzTmFOKE1bMV0pID8gTVsxXSA6IHBhcnNlSW50KE1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKlwiICE9PSBPICYmIFwiK1wiICE9PSBPIHx8IChPID0gXCIqXCIgPT09IEUgPyAwIDogMSksIFMucXVhbnRpZmllciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBPLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGppdDogVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSB2Lmxlbmd0aCA+IDAgPyB2W3YubGVuZ3RoIC0gMV0ubWF0Y2hlcyA6IGgubWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobiA9IGoucG9wKCkpLmlzR3JvdXAgfHwgKG4gPSBiKFsgbiBdKSksIGoucHVzaChuKSwgai5wdXNoKFMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaS5hbHRlcm5hdG9ybWFya2VyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSAobCA9IHZbdi5sZW5ndGggLSAxXSkubWF0Y2hlc1tsLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBsLm9wZW5Hcm91cCAmJiAodm9pZCAwID09PSBBLm1hdGNoZXMgfHwgITEgPT09IEEuaXNHcm91cCAmJiAhMSA9PT0gQS5pc0FsdGVybmF0b3IpID8gdi5wb3AoKSA6IFAobC5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdSA9IFAoaC5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodS5pc0FsdGVybmF0b3IpIHYucHVzaCh1KTsgZWxzZSBpZiAodS5hbHRlcm5hdG9yR3JvdXAgPyAoYyA9IHYucG9wKCksIHUuYWx0ZXJuYXRvckdyb3VwID0gITEpIDogYyA9IG5ldyBhLmRlZmF1bHQoITEsICExLCAhMSwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLm1hdGNoZXMucHVzaCh1KSwgdi5wdXNoKGMpLCB1Lm9wZW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1Lm9wZW5Hcm91cCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRCA9IG5ldyBhLmRlZmF1bHQoITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBELmFsdGVybmF0b3JHcm91cCA9ICEwLCB2LnB1c2goRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGcgJiYgeCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDt2Lmxlbmd0aCA+IDA7ICkgcyA9IHYucG9wKCksIGgubWF0Y2hlcy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICBoLm1hdGNoZXMubGVuZ3RoID4gMCAmJiAoIWZ1bmN0aW9uIGUobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiAmJiBuLm1hdGNoZXMgJiYgbi5tYXRjaGVzLmZvckVhY2goKGZ1bmN0aW9uKGEsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG4ubWF0Y2hlc1tyICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZvaWQgMCA9PT0gbyB8fCB2b2lkIDAgPT09IG8ubWF0Y2hlcyB8fCAhMSA9PT0gby5pc1F1YW50aWZpZXIpICYmIGEgJiYgYS5pc0dyb3VwICYmIChhLmlzR3JvdXAgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCB8fCAoeShhLCBpLmdyb3VwbWFya2VyWzBdLCAwKSwgITAgIT09IGEub3Blbkdyb3VwICYmIHkoYSwgaS5ncm91cG1hcmtlclsxXSkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZShhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfShoKSwgbS5wdXNoKGgpKTtcbiAgICAgICAgICAgICAgICAgICAgKGkubnVtZXJpY0lucHV0IHx8IGkuaXNSVEwpICYmIGZ1bmN0aW9uIGUodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiB0Lm1hdGNoZXMgPSB0Lm1hdGNoZXMucmV2ZXJzZSgpLCB0Lm1hdGNoZXMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodC5tYXRjaGVzLCBuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gcGFyc2VJbnQobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubWF0Y2hlc1tuXS5pc1F1YW50aWZpZXIgJiYgdC5tYXRjaGVzW2EgKyAxXSAmJiB0Lm1hdGNoZXNbYSArIDFdLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0Lm1hdGNoZXNbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubWF0Y2hlcy5zcGxpY2UobiwgMSksIHQubWF0Y2hlcy5zcGxpY2UoYSArIDEsIDAsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHQubWF0Y2hlc1tuXS5tYXRjaGVzID8gdC5tYXRjaGVzW25dID0gZSh0Lm1hdGNoZXNbbl0pIDogdC5tYXRjaGVzW25dID0gKChvID0gdC5tYXRjaGVzW25dKSA9PT0gaS5vcHRpb25hbG1hcmtlclswXSA/IG8gPSBpLm9wdGlvbmFsbWFya2VyWzFdIDogbyA9PT0gaS5vcHRpb25hbG1hcmtlclsxXSA/IG8gPSBpLm9wdGlvbmFsbWFya2VyWzBdIDogbyA9PT0gaS5ncm91cG1hcmtlclswXSA/IG8gPSBpLmdyb3VwbWFya2VyWzFdIDogbyA9PT0gaS5ncm91cG1hcmtlclsxXSAmJiAobyA9IGkuZ3JvdXBtYXJrZXJbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIH0obVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgICAgIH0sIHQuZ2VuZXJhdGVNYXNrU2V0ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQucmVwZWF0LCBuID0gdC5ncm91cG1hcmtlciwgYSA9IHQucXVhbnRpZmllcm1hcmtlciwgciA9IHQua2VlcFN0YXRpYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCB8fCBcIipcIiA9PT0gaSB8fCBcIitcIiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gXCIqXCIgPT09IGkgPyAwIDogXCIrXCIgPT09IGkgPyAxIDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gblswXSArIGUgKyBuWzFdICsgYVswXSArIGwgKyBcIixcIiArIGkgKyBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlLm1hdGNoKG5ldyBSZWdFeHAoXCIoLilcXFxcWyhbXlxcXFxdXSopXFxcXF1cIiwgXCJnXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICYmIGMuZm9yRWFjaCgoZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlKSB8fCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBudWxsID09IGUgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuLCBhLCByLCBvLCBzID0gW10sIGwgPSAhMCwgYyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSAoaSA9IGkuY2FsbChlKSkubmV4dCwgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QoaSkgIT09IGkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZm9yICg7IShsID0gKG4gPSByLmNhbGwoaSkpLmRvbmUpICYmIChzLnB1c2gobi52YWx1ZSksIHMubGVuZ3RoICE9PSB0KTsgbCA9ICEwKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAhMCwgYSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbCAmJiBudWxsICE9IGkucmV0dXJuICYmIChvID0gaS5yZXR1cm4oKSwgT2JqZWN0KG8pICE9PSBvKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykgdGhyb3cgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGUsIHQpIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIHMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IGkgJiYgZS5jb25zdHJ1Y3RvciAmJiAoaSA9IGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiTWFwXCIgPT09IGkgfHwgXCJTZXRcIiA9PT0gaSkgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQXJndW1lbnRzXCIgPT09IGkgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QoaSkpIHJldHVybiBzKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlLCB0KSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQuc3BsaXQoXCJbXCIpLCAyKSwgYSA9IG5bMF0sIHIgPSBuWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gci5yZXBsYWNlKFwiXVwiLCBcIlwiKSwgZSA9IGUucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KCgwLCBvLmRlZmF1bHQpKGEpLCBcIlxcXFxbXCIpLmNvbmNhdCgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uZGVmYXVsdCkociksIFwiXFxcXF1cIikpLCBhLmNoYXJBdCgwKSA9PT0gci5jaGFyQXQoMCkgPyBcIihcIi5jb25jYXQoYSwgXCJ8XCIpLmNvbmNhdChhKS5jb25jYXQociwgXCIpXCIpIDogXCJcIi5jb25jYXQoYSwgXCJbXCIpLmNvbmNhdChyLCBcIl1cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSwgaSwgbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMsIGwsIGMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBlICYmIFwiXCIgIT09IGUgfHwgKChjID0gbnVsbCAhPT0gby5yZWdleCkgPyBlID0gKGUgPSBvLnJlZ2V4KS5yZXBsYWNlKC9eKFxcXikoLiopKFxcJCkkLywgXCIkMlwiKSA6IChjID0gITAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiLipcIikpLCAxID09PSBlLmxlbmd0aCAmJiAhMSA9PT0gby5ncmVlZHkgJiYgMCAhPT0gby5yZXBlYXQgJiYgKG8ucGxhY2Vob2xkZXIgPSBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gYShlLCBvKSwgbCA9IGMgPyBcInJlZ2V4X1wiICsgby5yZWdleCA6IG8ubnVtZXJpY0lucHV0ID8gZS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gby5rZWVwU3RhdGljICYmIChsID0gXCJrc19cIiArIG8ua2VlcFN0YXRpYyArIGwpLCB2b2lkIDAgPT09IHIuZGVmYXVsdC5wcm90b3R5cGUubWFza3NDYWNoZVtsXSB8fCAhMCA9PT0gdCA/IChzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2s6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza1Rva2VuOiByLmRlZmF1bHQucHJvdG90eXBlLmFuYWx5c2VNYXNrKGUsIGMsIG8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkUG9zaXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYnVmZmVyOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrTGVuZ3RoOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaml0T2Zmc2V0OiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgITAgIT09IHQgJiYgKHIuZGVmYXVsdC5wcm90b3R5cGUubWFza3NDYWNoZVtsXSA9IHMsIHMgPSBuLmRlZmF1bHQuZXh0ZW5kKCEwLCB7fSwgci5kZWZhdWx0LnByb3RvdHlwZS5tYXNrc0NhY2hlW2xdKSkpIDogcyA9IG4uZGVmYXVsdC5leHRlbmQoITAsIHt9LCByLmRlZmF1bHQucHJvdG90eXBlLm1hc2tzQ2FjaGVbbF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLm1hc2sgJiYgKGUubWFzayA9IGUubWFzayhlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUubWFzaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm1hc2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IGUua2VlcFN0YXRpYyAmJiAoZS5rZWVwU3RhdGljID0gITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZS5ncm91cG1hcmtlclswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuaXNSVEwgPyBlLm1hc2sucmV2ZXJzZSgpIDogZS5tYXNrKS5mb3JFYWNoKChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubGVuZ3RoID4gMSAmJiAoYyArPSBlLmFsdGVybmF0b3JtYXJrZXIpLCB2b2lkIDAgIT09IHQubWFzayAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQubWFzayA/IGMgKz0gdC5tYXNrIDogYyArPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgbChjICs9IGUuZ3JvdXBtYXJrZXJbMV0sIGUubWFzaywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1hc2sgPSBlLm1hc2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSA9IGUubWFzayAmJiB2b2lkIDAgIT09IGUubWFzay5tYXNrICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZS5tYXNrLm1hc2sgPyBsKGUubWFzay5tYXNrLCBlLm1hc2ssIGUpIDogbChlLm1hc2ssIGUubWFzaywgZSk7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IGUua2VlcFN0YXRpYyAmJiAoZS5rZWVwU3RhdGljID0gITEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBuID0gbChpKDQ5NjMpKSwgYSA9IGwoaSg5Njk1KSksIHIgPSBsKGkoMjM5NCkpLCBvID0gbChpKDcxODQpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gdCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5ldyBBcnJheSh0KTsgaSA8IHQ7IGkrKykgbltpXSA9IGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTU3OiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0Lm1hc2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLCB0ID0gdGhpcy5vcHRzLCBpID0gdGhpcy5lbCwgdSA9IHRoaXMuZGVwZW5kZW5jeUxpYjtcbiAgICAgICAgICAgICAgICAgICAgby5FdmVudFJ1bGVyLm9mZihpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRhcmVhXCIgIT09IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICYmIGkuaWdub3JhYmxlcy5wdXNoKG4ua2V5cy5FbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSwgbCA9IFwiaW5wdXRcIiA9PT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgaS5zdXBwb3J0c0lucHV0VHlwZS5pbmNsdWRlcyhzKSB8fCB0LmlzQ29udGVudEVkaXRhYmxlIHx8IFwidGV4dGFyZWFcIiA9PT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWwpIGlmIChcImlucHV0XCIgPT09IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHMpLCBsID0gXCJ0ZXh0XCIgPT09IGMudHlwZSwgYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgbCA9IFwicGFydGlhbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExICE9PSBsID8gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuLCBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0bWFzayA/IHRoaXMuaW5wdXRtYXNrLm9wdHMuYXV0b1VubWFzayA/IHRoaXMuaW5wdXRtYXNrLnVubWFza2VkdmFsdWUoKSA6IC0xICE9PSBhLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZSkgfHwgITAgIT09IGkubnVsbGFibGUgPyAodGhpcy5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCB0aGlzLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMgJiYgaS5jbGVhck1hc2tPbkxvc3RGb2N1cyA/IChlLmlzUlRMID8gci5jbGVhck9wdGlvbmFsVGFpbC5jYWxsKGUsIGEuZ2V0QnVmZmVyLmNhbGwoZSkuc2xpY2UoKSkucmV2ZXJzZSgpIDogci5jbGVhck9wdGlvbmFsVGFpbC5jYWxsKGUsIGEuZ2V0QnVmZmVyLmNhbGwoZSkuc2xpY2UoKSkpLmpvaW4oXCJcIikgOiBuLmNhbGwodGhpcykgOiBcIlwiIDogbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5jYWxsKHRoaXMsIGUpLCB0aGlzLmlucHV0bWFzayAmJiAoMCwgci5hcHBseUlucHV0VmFsdWUpKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQuaW5wdXRtYXNrLl9fdmFsdWVHZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwICE9PSBpLm5vVmFsdWVQYXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpLCBcInZhbHVlXCIpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgJiYgZi5nZXQgJiYgZi5zZXQgPyAobiA9IGYuZ2V0LCBzID0gZi5zZXQsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgOiBcImlucHV0XCIgIT09IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICYmIChuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZG9jdW1lbnQuX19sb29rdXBHZXR0ZXJfXyAmJiB0Ll9fbG9va3VwR2V0dGVyX18oXCJ2YWx1ZVwiKSAmJiAobiA9IHQuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0Ll9fbG9va3VwU2V0dGVyX18oXCJ2YWx1ZVwiKSwgdC5fX2RlZmluZUdldHRlcl9fKFwidmFsdWVcIiwgbCksIHQuX19kZWZpbmVTZXR0ZXJfXyhcInZhbHVlXCIsIGMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaW5wdXRtYXNrLl9fdmFsdWVHZXQgPSBuLCB0LmlucHV0bWFzay5fX3ZhbHVlU2V0ID0gcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmlucHV0bWFzay5fdmFsdWVHZXQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pc1JUTCAmJiAhMCAhPT0gdCA/IG4uY2FsbCh0aGlzLmVsKS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IG4uY2FsbCh0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdC5pbnB1dG1hc2suX3ZhbHVlU2V0ID0gZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5jYWxsKHRoaXMuZWwsIG51bGwgPT0gdCA/IFwiXCIgOiAhMCAhPT0gaSAmJiBlLmlzUlRMID8gdC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB2b2lkIDAgPT09IG4gJiYgKG4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1LnZhbEhvb2tzICYmICh2b2lkIDAgPT09IHUudmFsSG9va3NbdF0gfHwgITAgIT09IHUudmFsSG9va3NbdF0uaW5wdXRtYXNrcGF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB1LnZhbEhvb2tzW3RdICYmIHUudmFsSG9va3NbdF0uZ2V0ID8gdS52YWxIb29rc1t0XS5nZXQgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG8gPSB1LnZhbEhvb2tzW3RdICYmIHUudmFsSG9va3NbdF0uc2V0ID8gdS52YWxIb29rc1t0XS5zZXQgOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlID0gdCwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUudmFsSG9va3NbdF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuaW5wdXRtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuaW5wdXRtYXNrLm9wdHMuYXV0b1VubWFzaykgcmV0dXJuIHQuaW5wdXRtYXNrLnVubWFza2VkdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG4odCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSBhLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZSwgdm9pZCAwLCB2b2lkIDAsIHQuaW5wdXRtYXNrLm1hc2tzZXQudmFsaWRQb3NpdGlvbnMpIHx8ICEwICE9PSBpLm51bGxhYmxlID8gciA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbih0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG8oZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pbnB1dG1hc2sgJiYgKDAsIHIuYXBwbHlJbnB1dFZhbHVlKShlLCB0KSwgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtYXNrcGF0Y2g6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh0LnR5cGUpLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLkV2ZW50UnVsZXIub24oZSwgXCJtb3VzZWVudGVyXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMsIHQgPSBlLmlucHV0bWFzay5fdmFsdWVHZXQoITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgIT0gKGUuaW5wdXRtYXNrLmlzUlRMID8gYS5nZXRCdWZmZXIuY2FsbChlLmlucHV0bWFzaykuc2xpY2UoKS5yZXZlcnNlKCkgOiBhLmdldEJ1ZmZlci5jYWxsKGUuaW5wdXRtYXNrKSkuam9pbihcIlwiKSAmJiAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5hcHBseUlucHV0VmFsdWUpKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHQpIDogdC5pbnB1dG1hc2sgPSB2b2lkIDAsIGw7XG4gICAgICAgICAgICAgICAgICAgIH0oaSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbFBsYWNlaG9sZGVyID0gaS5wbGFjZWhvbGRlciwgZS5tYXhMZW5ndGggPSB2b2lkIDAgIT09IGkgPyBpLm1heExlbmd0aCA6IHZvaWQgMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gZS5tYXhMZW5ndGggJiYgKGUubWF4TGVuZ3RoID0gdm9pZCAwKSwgXCJpbnB1dE1vZGVcIiBpbiBpICYmIG51bGwgPT09IGkuZ2V0QXR0cmlidXRlKFwiaW5wdXRtb2RlXCIpICYmIChpLmlucHV0TW9kZSA9IHQuaW5wdXRtb2RlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuc2V0QXR0cmlidXRlKFwiaW5wdXRtb2RlXCIsIHQuaW5wdXRtb2RlKSksICEwID09PSBmICYmICh0LnNob3dNYXNrT25Gb2N1cyA9IHQuc2hvd01hc2tPbkZvY3VzICYmIC0xID09PSBbIFwiY2MtbnVtYmVyXCIsIFwiY2MtZXhwXCIgXS5pbmRleE9mKGkuYXV0b2NvbXBsZXRlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmlwaG9uZSAmJiAodC5pbnNlcnRNb2RlVmlzdWFsID0gITEsIGkuc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIiwgXCJvZmZcIikpLCBvLkV2ZW50UnVsZXIub24oaSwgXCJzdWJtaXRcIiwgYy5FdmVudEhhbmRsZXJzLnN1Ym1pdEV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvLkV2ZW50UnVsZXIub24oaSwgXCJyZXNldFwiLCBjLkV2ZW50SGFuZGxlcnMucmVzZXRFdmVudCksIG8uRXZlbnRSdWxlci5vbihpLCBcImJsdXJcIiwgYy5FdmVudEhhbmRsZXJzLmJsdXJFdmVudCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgby5FdmVudFJ1bGVyLm9uKGksIFwiZm9jdXNcIiwgYy5FdmVudEhhbmRsZXJzLmZvY3VzRXZlbnQpLCBvLkV2ZW50UnVsZXIub24oaSwgXCJpbnZhbGlkXCIsIGMuRXZlbnRIYW5kbGVycy5pbnZhbGlkRXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uRXZlbnRSdWxlci5vbihpLCBcImNsaWNrXCIsIGMuRXZlbnRIYW5kbGVycy5jbGlja0V2ZW50KSwgby5FdmVudFJ1bGVyLm9uKGksIFwibW91c2VsZWF2ZVwiLCBjLkV2ZW50SGFuZGxlcnMubW91c2VsZWF2ZUV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvLkV2ZW50UnVsZXIub24oaSwgXCJtb3VzZWVudGVyXCIsIGMuRXZlbnRIYW5kbGVycy5tb3VzZWVudGVyRXZlbnQpLCBvLkV2ZW50UnVsZXIub24oaSwgXCJwYXN0ZVwiLCBjLkV2ZW50SGFuZGxlcnMucGFzdGVFdmVudCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgby5FdmVudFJ1bGVyLm9uKGksIFwiY3V0XCIsIGMuRXZlbnRIYW5kbGVycy5jdXRFdmVudCksIG8uRXZlbnRSdWxlci5vbihpLCBcImNvbXBsZXRlXCIsIHQub25jb21wbGV0ZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgby5FdmVudFJ1bGVyLm9uKGksIFwiaW5jb21wbGV0ZVwiLCB0Lm9uaW5jb21wbGV0ZSksIG8uRXZlbnRSdWxlci5vbihpLCBcImNsZWFyZWRcIiwgdC5vbmNsZWFyZWQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSB0LmlucHV0RXZlbnRPbmx5ICYmIG8uRXZlbnRSdWxlci5vbihpLCBcImtleWRvd25cIiwgYy5FdmVudEhhbmRsZXJzLmtleUV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5tb2JpbGUgfHwgdC5pbnB1dEV2ZW50T25seSkgJiYgaS5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiksIG8uRXZlbnRSdWxlci5vbihpLCBcImlucHV0XCIsIGMuRXZlbnRIYW5kbGVycy5pbnB1dEZhbGxCYWNrRXZlbnQpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvLkV2ZW50UnVsZXIub24oaSwgXCJzZXR2YWx1ZVwiLCBjLkV2ZW50SGFuZGxlcnMuc2V0VmFsdWVFdmVudCksIGEuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChlKS5qb2luKFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudW5kb1ZhbHVlID0gZS5fdmFsdWVHZXQoITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAoaS5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBpLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gaS5pbnB1dG1hc2suX3ZhbHVlR2V0KCEwKSB8fCAhMSA9PT0gdC5jbGVhck1hc2tPbkxvc3RGb2N1cyB8fCBkID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHIuYXBwbHlJbnB1dFZhbHVlKShpLCBpLmlucHV0bWFzay5fdmFsdWVHZXQoITApLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGEuZ2V0QnVmZmVyLmNhbGwoZSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMSA9PT0gbC5pc0NvbXBsZXRlLmNhbGwoZSwgcCkgJiYgdC5jbGVhckluY29tcGxldGUgJiYgYS5yZXNldE1hc2tTZXQuY2FsbChlKSwgdC5jbGVhck1hc2tPbkxvc3RGb2N1cyAmJiBkICE9PSBpICYmICgtMSA9PT0gYS5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGUpID8gcCA9IFtdIDogci5jbGVhck9wdGlvbmFsVGFpbC5jYWxsKGUsIHApKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCExID09PSB0LmNsZWFyTWFza09uTG9zdEZvY3VzIHx8IHQuc2hvd01hc2tPbkZvY3VzICYmIGQgPT09IGkgfHwgXCJcIiAhPT0gaS5pbnB1dG1hc2suX3ZhbHVlR2V0KCEwKSkgJiYgKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIud3JpdGVCdWZmZXIpKGksIHApLCBkID09PSBpICYmIGEuY2FyZXQuY2FsbChlLCBpLCBhLnNlZWtOZXh0LmNhbGwoZSwgYS5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBuID0gaSgyODM5KSwgYSA9IGkoODcxMSksIHIgPSBpKDc3NjApLCBvID0gaSg5NzE2KSwgcyA9IGkoOTg0NSksIGwgPSBpKDcyMTUpLCBjID0gaSg2MDMwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5Njk1OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlLCB0LCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdLCB0aGlzLm9wZW5Hcm91cCA9IGUgfHwgITEsIHRoaXMuYWx0ZXJuYXRvckdyb3VwID0gITEsIHRoaXMuaXNHcm91cCA9IGUgfHwgITEsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0IHx8ICExLCB0aGlzLmlzUXVhbnRpZmllciA9IGkgfHwgITEsIHRoaXMuaXNBbHRlcm5hdG9yID0gbiB8fCAhMSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhbnRpZmllciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMzE5NDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsIFwiaW5jbHVkZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gdGhpcykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBPYmplY3QodGhpcyksIG4gPSBpLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBuKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMCB8IHQsIHIgPSBNYXRoLm1heChhID49IDAgPyBhIDogbiAtIE1hdGguYWJzKGEpLCAwKTsgciA8IG47ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpW3JdID09PSBlKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgOTMwMjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBGdW5jdGlvbi5iaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLnJlZHVjZSksIHQgPSBGdW5jdGlvbi5iaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSksIGkgPSBGdW5jdGlvbi5iaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCksIG4gPSBPYmplY3Qua2V5cztcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyB8fCAoT2JqZWN0LmVudHJpZXMgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlKG4oYSksIChmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaShlLCBcInN0cmluZ1wiID09IHR5cGVvZiBuICYmIHQoYSwgbikgPyBbIFsgbiwgYVtuXSBdIF0gOiBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCBbXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzE0OTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIGUodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YgPSBcIm9iamVjdFwiID09PSBlKFwidGVzdFwiLl9fcHJvdG9fXykgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLl9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNDAxMzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyB8fCAoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQgJiYgKHQgPSAwKSwgISh0ICsgZS5sZW5ndGggPiB0aGlzLmxlbmd0aCkgJiYgLTEgIT09IHRoaXMuaW5kZXhPZihlLCB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA4NzExOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmNhcmV0ID0gZnVuY3Rpb24oZSwgdCwgaSwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciwgbyA9IHRoaXMsIHMgPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpIHJldHVybiBcInNlbGVjdGlvblN0YXJ0XCIgaW4gZSAmJiBcInNlbGVjdGlvbkVuZFwiIGluIGUgPyAodCA9IGUuc2VsZWN0aW9uU3RhcnQsIFxuICAgICAgICAgICAgICAgICAgICBpID0gZS5zZWxlY3Rpb25FbmQpIDogd2luZG93LmdldFNlbGVjdGlvbiA/IChyID0gd2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLnBhcmVudE5vZGUgIT09IGUgJiYgci5jb21tb25BbmNlc3RvckNvbnRhaW5lciAhPT0gZSB8fCAodCA9IHIuc3RhcnRPZmZzZXQsIFxuICAgICAgICAgICAgICAgICAgICBpID0gci5lbmRPZmZzZXQpIDogZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSAmJiAoaSA9ICh0ID0gMCAtIChyID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkpLmR1cGxpY2F0ZSgpLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAtZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkubGVuZ3RoKSkgKyByLnRleHQubGVuZ3RoKSwgXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiBuID8gdCA6IGMuY2FsbChvLCB0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbiA/IGkgOiBjLmNhbGwobywgaSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkgJiYgKGkgPSBvLmlzUlRMID8gdFswXSA6IHRbMV0sIHQgPSBvLmlzUlRMID8gdFsxXSA6IHRbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0LmJlZ2luICYmIChpID0gby5pc1JUTCA/IHQuYmVnaW4gOiB0LmVuZCwgdCA9IG8uaXNSVEwgPyB0LmVuZCA6IHQuYmVnaW4pLCBcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG4gPyB0IDogYy5jYWxsKG8sIHQpLCBpID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgKGkgPSBuID8gaSA6IGMuY2FsbChvLCBpKSkgPyBpIDogdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQoKChlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5nZXRDb21wdXRlZFN0eWxlID8gKGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldENvbXB1dGVkU3R5bGUoZSwgbnVsbCkgOiBlLmN1cnJlbnRTdHlsZSkuZm9udFNpemUpICogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNjcm9sbExlZnQgPSBsID4gZS5zY3JvbGxXaWR0aCA/IGwgOiAwLCBlLmlucHV0bWFzay5jYXJldFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHMuaW5zZXJ0TW9kZVZpc3VhbCAmJiAhMSA9PT0gcy5pbnNlcnRNb2RlICYmIHQgPT09IGkgJiYgKGEgfHwgaSsrKSwgZSA9PT0gKGUuaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgZS5vd25lckRvY3VtZW50KS5hY3RpdmVFbGVtZW50KSBpZiAoXCJzZXRTZWxlY3Rpb25SYW5nZVwiIGluIGUpIGUuc2V0U2VsZWN0aW9uUmFuZ2UodCwgaSk7IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIHZvaWQgMCA9PT0gZS5maXJzdENoaWxkIHx8IG51bGwgPT09IGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmFwcGVuZENoaWxkKHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnNldFN0YXJ0KGUuZmlyc3RDaGlsZCwgdCA8IGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCA/IHQgOiBlLmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnNldEVuZChlLmZpcnN0Q2hpbGQsIGkgPCBlLmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGggPyBpIDogZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkubGVuZ3RoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5jb2xsYXBzZSghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5yZW1vdmVBbGxSYW5nZXMoKSwgZi5hZGRSYW5nZShyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBlLmNyZWF0ZVRleHRSYW5nZSAmJiAoKHIgPSBlLmNyZWF0ZVRleHRSYW5nZSgpKS5jb2xsYXBzZSghMCksIHIubW92ZUVuZChcImNoYXJhY3RlclwiLCBpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCB0KSwgci5zZWxlY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0LmRldGVybWluZUxhc3RSZXF1aXJlZFBvc2l0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCwgaSwgciA9IHRoaXMsIHMgPSByLm1hc2tzZXQsIGwgPSByLmRlcGVuZGVuY3lMaWIsIGMgPSBuLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHIsICEwLCBvLmNhbGwociksICEwLCAhMCksIHUgPSBjLmxlbmd0aCwgZiA9IG8uY2FsbChyKSwgZCA9IHt9LCBwID0gcy52YWxpZFBvc2l0aW9uc1tmXSwgaCA9IHZvaWQgMCAhPT0gcCA/IHAubG9jYXRvci5zbGljZSgpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHQgPSBmICsgMTsgdCA8IGMubGVuZ3RoOyB0KyspIGggPSAoaSA9IG4uZ2V0VGVzdFRlbXBsYXRlLmNhbGwociwgdCwgaCwgdCAtIDEpKS5sb2NhdG9yLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICBkW3RdID0gbC5leHRlbmQoITAsIHt9LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBwICYmIHZvaWQgMCAhPT0gcC5hbHRlcm5hdGlvbiA/IHAubG9jYXRvcltwLmFsdGVybmF0aW9uXSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0ID0gdSAtIDE7IHQgPiBmICYmICgoKGkgPSBkW3RdKS5tYXRjaC5vcHRpb25hbGl0eSB8fCBpLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiBpLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8IHYgJiYgKHYgIT09IGRbdF0ubG9jYXRvcltwLmFsdGVybmF0aW9uXSAmJiAxICE9IGkubWF0Y2guc3RhdGljIHx8ICEwID09PSBpLm1hdGNoLnN0YXRpYyAmJiBpLmxvY2F0b3JbcC5hbHRlcm5hdGlvbl0gJiYgYS5jaGVja0FsdGVybmF0aW9uTWF0Y2guY2FsbChyLCBpLmxvY2F0b3JbcC5hbHRlcm5hdGlvbl0udG9TdHJpbmcoKS5zcGxpdChcIixcIiksIHYudG9TdHJpbmcoKS5zcGxpdChcIixcIikpICYmIFwiXCIgIT09IG4uZ2V0VGVzdHMuY2FsbChyLCB0KVswXS5kZWYpKSAmJiBjW3RdID09PSBuLmdldFBsYWNlaG9sZGVyLmNhbGwociwgdCwgaS5tYXRjaCkpOyB0LS0pIHUtLTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsOiB1LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBkW3VdID8gZFt1XS5tYXRjaCA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICB9IDogdTtcbiAgICAgICAgICAgICAgICB9LCB0LmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24gPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcywgYyA9IGEubWFza3NldCwgdSA9IGEub3B0cztcbiAgICAgICAgICAgICAgICAgICAgdCAmJiAoYS5pc1JUTCA/IGUuZW5kID0gZS5iZWdpbiA6IGUuYmVnaW4gPSBlLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmJlZ2luID09PSBlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpID0gaSB8fCB1LnBvc2l0aW9uQ2FyZXRPbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHIuY2FsbChhKS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpZ25vcmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmVuZCA9IGUuYmVnaW4gPSBsLmNhbGwoYSwgby5jYWxsKGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmFkaXhGb2N1c1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmNsaWNrZWQgPiAxICYmIDAgPT0gYy52YWxpZFBvc2l0aW9ucy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSB1LnJhZGl4UG9pbnQgJiYgMCAhPT0gdS5kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYy52YWxpZFBvc2l0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHRbZV0gfHwgdFtlXS5pbnB1dCA9PT0gbi5nZXRQbGFjZWhvbGRlci5jYWxsKGEsIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPCBsLmNhbGwoYSwgLTEpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByLmNhbGwoYSkuaW5kZXhPZih1LnJhZGl4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMCwgcyA9IHQubGVuZ3RoOyBvIDwgczsgbysrKSBpZiAodFtvXSAmJiBpIDwgbyAmJiB0W29dLmlucHV0ICE9PSBuLmdldFBsYWNlaG9sZGVyLmNhbGwoYSwgbykpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlLmJlZ2luKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHIuY2FsbChhKS5qb2luKFwiXCIpLmluZGV4T2YodS5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5lbmQgPSBlLmJlZ2luID0gdS5udW1lcmljSW5wdXQgPyBsLmNhbGwoYSwgZikgOiBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGUuYmVnaW4sIHAgPSBvLmNhbGwoYSwgZCwgITApLCBoID0gbC5jYWxsKGEsIC0xICE9PSBwIHx8IHMuY2FsbChhLCAwKSA/IHAgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPD0gaCkgZS5lbmQgPSBlLmJlZ2luID0gcy5jYWxsKGEsIGQsICExLCAhMCkgPyBkIDogbC5jYWxsKGEsIGQpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBjLnZhbGlkUG9zaXRpb25zW3BdLCBtID0gbi5nZXRUZXN0VGVtcGxhdGUuY2FsbChhLCBoLCB2ID8gdi5tYXRjaC5sb2NhdG9yIDogdm9pZCAwLCB2KSwgZyA9IG4uZ2V0UGxhY2Vob2xkZXIuY2FsbChhLCBoLCBtLm1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IGcgJiYgci5jYWxsKGEpW2hdICE9PSBnICYmICEwICE9PSBtLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiAhMCAhPT0gbS5tYXRjaC5uZXdCbG9ja01hcmtlciB8fCAhcy5jYWxsKGEsIGgsIHUua2VlcFN0YXRpYywgITApICYmIG0ubWF0Y2guZGVmID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGwuY2FsbChhLCBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkID49IHkgfHwgZCA9PT0gaCkgJiYgKGggPSB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmVuZCA9IGUuYmVnaW4gPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdC5nZXRCdWZmZXIgPSByLCB0LmdldEJ1ZmZlclRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUuX2J1ZmZlciAmJiAoZS5fYnVmZmVyID0gbi5nZXRNYXNrVGVtcGxhdGUuY2FsbCh0aGlzLCAhMSwgMSksIHZvaWQgMCA9PT0gZS5idWZmZXIgJiYgKGUuYnVmZmVyID0gZS5fYnVmZmVyLnNsaWNlKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICB9LCB0LmdldExhc3RWYWxpZFBvc2l0aW9uID0gbywgdC5pc01hc2sgPSBzLCB0LnJlc2V0TWFza1NldCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHQuYnVmZmVyID0gdm9pZCAwLCAhMCAhPT0gZSAmJiAodC52YWxpZFBvc2l0aW9ucyA9IFtdLCB0LnAgPSAwKTtcbiAgICAgICAgICAgICAgICB9LCB0LnNlZWtOZXh0ID0gbCwgdC5zZWVrUHJldmlvdXMgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcywgYSA9IGUgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSA8PSAwKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7YSA+IDAgJiYgKCEwID09PSB0ICYmICghMCAhPT0gbi5nZXRUZXN0LmNhbGwoaSwgYSkubWF0Y2gubmV3QmxvY2tNYXJrZXIgfHwgIXMuY2FsbChpLCBhLCB2b2lkIDAsICEwKSkgfHwgITAgIT09IHQgJiYgIXMuY2FsbChpLCBhLCB2b2lkIDAsICEwKSk7ICkgYS0tO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9LCB0LnRyYW5zbGF0ZVBvc2l0aW9uID0gYztcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGkoNDcxMyksIGEgPSBpKDcyMTUpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsIGkgPSB0Lm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGkuYnVmZmVyICYmICEwICE9PSBlIHx8IChpLmJ1ZmZlciA9IG4uZ2V0TWFza1RlbXBsYXRlLmNhbGwodCwgITAsIG8uY2FsbCh0KSwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBpLl9idWZmZXIgJiYgKGkuX2J1ZmZlciA9IGkuYnVmZmVyLnNsaWNlKCkpKSwgaS5idWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMubWFza3NldCwgYSA9IC0xLCByID0gLTEsIG8gPSBpIHx8IG4udmFsaWRQb3NpdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIGwgPSBvLmxlbmd0aDsgcyA8IGw7IHMrKykgb1tzXSAmJiAodCB8fCAhMCAhPT0gb1tzXS5nZW5lcmF0ZWRJbnB1dCkgJiYgKHMgPD0gZSAmJiAoYSA9IHMpLCBcbiAgICAgICAgICAgICAgICAgICAgcyA+PSBlICYmIChyID0gcykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgPT09IGEgfHwgYSA9PSBlID8gciA6IC0xID09IHIgfHwgZSAtIGEgPCByIC0gZSA/IGEgOiByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLCByID0gdGhpcy5tYXNrc2V0LCBvID0gbi5nZXRUZXN0VGVtcGxhdGUuY2FsbChhLCBlKS5tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IG8uZGVmICYmIChvID0gbi5nZXRUZXN0LmNhbGwoYSwgZSkubWF0Y2gpLCAhMCAhPT0gby5zdGF0aWMpIHJldHVybiBvLmZuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IGkgJiYgdm9pZCAwICE9PSByLnZhbGlkUG9zaXRpb25zW2VdICYmICEwICE9PSByLnZhbGlkUG9zaXRpb25zW2VdLmdlbmVyYXRlZElucHV0KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMCAhPT0gdCAmJiBlID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBuLmdldFRlc3RzLmNhbGwoYSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoID4gMSArIChcIlwiID09PSBzW3MubGVuZ3RoIC0gMV0ubWF0Y2guZGVmID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBuLmRldGVybWluZVRlc3RUZW1wbGF0ZS5jYWxsKGEsIGUsIG4uZ2V0VGVzdHMuY2FsbChhLCBlKSksIGMgPSBuLmdldFBsYWNlaG9sZGVyLmNhbGwoYSwgZSwgbC5tYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbC5tYXRjaC5kZWYgIT09IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBlICsgMTsgXCJcIiAhPT0gbi5nZXRUZXN0LmNhbGwoYSwgcikubWF0Y2guZGVmICYmICghMCA9PT0gdCAmJiAoITAgIT09IG4uZ2V0VGVzdC5jYWxsKGEsIHIpLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8ICFzLmNhbGwoYSwgciwgdm9pZCAwLCAhMCkpIHx8ICEwICE9PSB0ICYmICFzLmNhbGwoYSwgciwgdm9pZCAwLCBpKSk7ICkgcisrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5vcHRzLCBpID0gdGhpcy5lbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzUlRMIHx8IFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgfHwgdC5ncmVlZHkgJiYgXCJcIiA9PT0gdC5wbGFjZWhvbGRlciB8fCAhaSB8fCAoZSA9IHRoaXMuX3ZhbHVlR2V0KCkubGVuZ3RoIC0gZSkgPCAwICYmIChlID0gMCksIFxuICAgICAgICAgICAgICAgICAgICBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0NzEzOiBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRldGVybWluZVRlc3RUZW1wbGF0ZSA9IGMsIHQuZ2V0RGVjaXNpb25UYWtlciA9IG8sIHQuZ2V0TWFza1RlbXBsYXRlID0gZnVuY3Rpb24oZSwgdCwgaSwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMsIG8gPSB0aGlzLm9wdHMsIHUgPSB0aGlzLm1hc2tzZXQsIGYgPSBvLmdyZWVkeTtcbiAgICAgICAgICAgICAgICAgICAgYSAmJiBvLmdyZWVkeSAmJiAoby5ncmVlZHkgPSAhMSwgci5tYXNrc2V0LnRlc3RzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICB0ID0gdCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCwgaCwgdiwgbSwgZyA9IFtdLCB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBlICYmIHUudmFsaWRQb3NpdGlvbnNbeV0pIGggPSAodiA9IGEgJiYgdS52YWxpZFBvc2l0aW9uc1t5XS5tYXRjaC5vcHRpb25hbGl0eSAmJiB2b2lkIDAgPT09IHUudmFsaWRQb3NpdGlvbnNbeSArIDFdICYmICghMCA9PT0gdS52YWxpZFBvc2l0aW9uc1t5XS5nZW5lcmF0ZWRJbnB1dCB8fCB1LnZhbGlkUG9zaXRpb25zW3ldLmlucHV0ID09IG8uc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciAmJiB5ID4gMCkgPyBjLmNhbGwociwgeSwgZC5jYWxsKHIsIHksIHAsIHkgLSAxKSkgOiB1LnZhbGlkUG9zaXRpb25zW3ldKS5tYXRjaCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gdi5sb2NhdG9yLnNsaWNlKCksIGcucHVzaCghMCA9PT0gaSA/IHYuaW5wdXQgOiAhMSA9PT0gaSA/IGgubmF0aXZlRGVmIDogcy5jYWxsKHIsIHksIGgpKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9ICh2ID0gbC5jYWxsKHIsIHksIHAsIHkgLSAxKSkubWF0Y2gsIHAgPSB2LmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9ICEwICE9PSBuICYmICghMSAhPT0gby5qaXRNYXNraW5nID8gby5qaXRNYXNraW5nIDogaC5qaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtID0gKG0gJiYgaC5zdGF0aWMgJiYgaC5kZWYgIT09IG8uZ3JvdXBTZXBhcmF0b3IgJiYgbnVsbCA9PT0gaC5mbiB8fCB1LnZhbGlkUG9zaXRpb25zW3kgLSAxXSAmJiBoLnN0YXRpYyAmJiBoLmRlZiAhPT0gby5ncm91cFNlcGFyYXRvciAmJiBudWxsID09PSBoLmZuKSAmJiB1LnRlc3RzW3ldKSB8fCAhMSA9PT0gayB8fCB2b2lkIDAgPT09IGsgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgayAmJiBpc0Zpbml0ZShrKSAmJiBrID4geSA/IGcucHVzaCghMSA9PT0gaSA/IGgubmF0aXZlRGVmIDogcy5jYWxsKHIsIGcubGVuZ3RoLCBoKSkgOiBtID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCEwICE9PSBoLnN0YXRpYyB8fCBcIlwiICE9PSBoLmRlZiB8fCB0ID4geSk7XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IGdbZy5sZW5ndGggLSAxXSAmJiBnLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAhMSA9PT0gaSAmJiB2b2lkIDAgIT09IHUubWFza0xlbmd0aCB8fCAodS5tYXNrTGVuZ3RoID0geSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5ncmVlZHkgPSBmLCBnO1xuICAgICAgICAgICAgICAgIH0sIHQuZ2V0UGxhY2Vob2xkZXIgPSBzLCB0LmdldFRlc3QgPSB1LCB0LmdldFRlc3RUZW1wbGF0ZSA9IGwsIHQuZ2V0VGVzdHMgPSBkLCB0LmlzU3Vic2V0T2YgPSBmO1xuICAgICAgICAgICAgICAgIHZhciBuLCBhID0gKG4gPSBpKDIzOTQpKSAmJiBuLl9fZXNNb2R1bGUgPyBuIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAobnVsbCAhPSBlLmFsdGVybmF0aW9uID8gZS5tbG9jW28oZSldIDogZS5sb2NhdG9yKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gaSkgZm9yICg7aS5sZW5ndGggPCB0OyApIGkgKz0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmxvY2F0b3JbZS5hbHRlcm5hdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIHQubGVuZ3RoID4gMCAmJiAodCA9IHQuc3BsaXQoXCIsXCIpWzBdKSwgdm9pZCAwICE9PSB0ID8gdC50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5vcHRzLCBhID0gdGhpcy5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSAodCA9IHQgfHwgdS5jYWxsKHRoaXMsIGUpLm1hdGNoKS5wbGFjZWhvbGRlciB8fCAhMCA9PT0gaSkgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdC5wbGFjZWhvbGRlciA/IHQucGxhY2Vob2xkZXIobikgOiB0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHQuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA+IC0xICYmIHZvaWQgMCA9PT0gYS52YWxpZFBvc2l0aW9uc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByLCBvID0gZC5jYWxsKHRoaXMsIGUpLCBzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ubGVuZ3RoID4gMSArIChcIlwiID09PSBvW28ubGVuZ3RoIC0gMV0ubWF0Y2guZGVmID8gMSA6IDApKSBmb3IgKHZhciBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspIGlmIChcIlwiICE9PSBvW2xdLm1hdGNoLmRlZiAmJiAhMCAhPT0gb1tsXS5tYXRjaC5vcHRpb25hbGl0eSAmJiAhMCAhPT0gb1tsXS5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIgJiYgKCEwID09PSBvW2xdLm1hdGNoLnN0YXRpYyB8fCB2b2lkIDAgPT09IHIgfHwgITEgIT09IG9bbF0ubWF0Y2guZm4udGVzdChyLm1hdGNoLmRlZiwgYSwgZSwgITAsIG4pKSAmJiAocy5wdXNoKG9bbF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMCA9PT0gb1tsXS5tYXRjaC5zdGF0aWMgJiYgKHIgPSBvW2xdKSwgcy5sZW5ndGggPiAxICYmIC9bMC05YS1iQS1aXS8udGVzdChzWzBdLm1hdGNoLmRlZikpKSByZXR1cm4gbi5wbGFjZWhvbGRlci5jaGFyQXQoZSAlIG4ucGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmRlZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5wbGFjZWhvbGRlci5jaGFyQXQoZSAlIG4ucGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hc2tzZXQudmFsaWRQb3NpdGlvbnNbZV0gfHwgYy5jYWxsKHRoaXMsIGUsIGQuY2FsbCh0aGlzLCBlLCB0ID8gdC5zbGljZSgpIDogdCwgaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm9wdHMsIG4gPSAwLCBhID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBuID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1hdGNoLm9wdGlvbmFsaXR5ICYmICgwICE9PSBpICYmIGkgIT09IGUubWF0Y2gub3B0aW9uYWxpdHkgJiYgKG4gPSAhMCksICgwID09PSBpIHx8IGkgPiBlLm1hdGNoLm9wdGlvbmFsaXR5KSAmJiAoaSA9IGUubWF0Y2gub3B0aW9uYWxpdHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgaSAmJiAoMCA9PSBlIHx8IDEgPT0gdC5sZW5ndGggPyBpID0gMCA6IG4gfHwgKGkgPSAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfShlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUgPiAwID8gZSAtIDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbywgcywgbCwgYyA9IHIodS5jYWxsKHRoaXMsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaS5ncmVlZHkgJiYgdC5sZW5ndGggPiAxICYmIFwiXCIgPT09IHRbdC5sZW5ndGggLSAxXS5tYXRjaC5kZWYgJiYgKG4gPSAxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCB0Lmxlbmd0aCAtIG47IGYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0W2ZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHIoZCwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBNYXRoLmFicyhvIC0gYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAodm9pZCAwID09PSBzIHx8IFwiXCIgIT09IG8gJiYgcCA8IHMgfHwgbCAmJiAhaS5ncmVlZHkgJiYgbC5tYXRjaC5vcHRpb25hbGl0eSAmJiBsLm1hdGNoLm9wdGlvbmFsaXR5IC0gYSA+IDAgJiYgXCJtYXN0ZXJcIiA9PT0gbC5tYXRjaC5uZXdCbG9ja01hcmtlciAmJiAoIWQubWF0Y2gub3B0aW9uYWxpdHkgfHwgZC5tYXRjaC5vcHRpb25hbGl0eSAtIGEgPCAxIHx8ICFkLm1hdGNoLm5ld0Jsb2NrTWFya2VyKSB8fCBsICYmICFpLmdyZWVkeSAmJiBsLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiAhZC5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIpICYmIChzID0gcCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkudmFsaWRQb3NpdGlvbnNbZV0gPyBpLnZhbGlkUG9zaXRpb25zW2VdIDogKHQgfHwgZC5jYWxsKHRoaXMsIGUpKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgaSA9IFtdLCBuID0gLTEsIGEgPSAwLCByID0gZS5sZW5ndGg7IGEgPCByOyBhKyspIGlmIChcIi1cIiA9PT0gZS5jaGFyQXQoYSkpIGZvciAodCA9IGUuY2hhckNvZGVBdChhICsgMSk7ICsrbiA8IHQ7ICkgaS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobikpOyBlbHNlIG4gPSBlLmNoYXJDb2RlQXQoYSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgaS5wdXNoKGUuY2hhckF0KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubWF0Y2guZGVmID09PSB0Lm1hdGNoLm5hdGl2ZURlZiB8fCAhKCEoaS5yZWdleCB8fCBlLm1hdGNoLmZuIGluc3RhbmNlb2YgUmVnRXhwICYmIHQubWF0Y2guZm4gaW5zdGFuY2VvZiBSZWdFeHApIHx8ICEwID09PSBlLm1hdGNoLnN0YXRpYyB8fCAhMCA9PT0gdC5tYXRjaC5zdGF0aWMpICYmIC0xICE9PSBuKHQubWF0Y2guZm4udG9TdHJpbmcoKS5yZXBsYWNlKC9bW1xcXS9dL2csIFwiXCIpKS5pbmRleE9mKG4oZS5tYXRjaC5mbi50b1N0cmluZygpLnJlcGxhY2UoL1tbXFxdL10vZywgXCJcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByLCBvID0gdGhpcywgcyA9IHRoaXMuZGVwZW5kZW5jeUxpYiwgbCA9IHRoaXMubWFza3NldCwgdSA9IHRoaXMub3B0cywgZCA9IHRoaXMuZWwsIHAgPSBsLm1hc2tUb2tlbiwgaCA9IHQgPyBpIDogMCwgdiA9IHQgPyB0LnNsaWNlKCkgOiBbIDAgXSwgbSA9IFtdLCBnID0gITEsIHkgPSB0ID8gdC5qb2luKFwiXCIpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gayh0LCBpLCByLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKHIsIHMsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwID09PSB0Lm1hdGNoZXMuaW5kZXhPZihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgfHwgdC5tYXRjaGVzLmV2ZXJ5KChmdW5jdGlvbihuLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITAgPT09IG4uaXNRdWFudGlmaWVyID8gaSA9IHYoZSwgdC5tYXRjaGVzW2EgLSAxXSkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgXCJtYXRjaGVzXCIpICYmIChpID0gdihlLCBuKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24geChlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuLCBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGwudGVzdHNbZV0gfHwgbC52YWxpZFBvc2l0aW9uc1tlXSkgJiYgKGwudGVzdHNbZV0gfHwgWyBsLnZhbGlkUG9zaXRpb25zW2VdIF0pLmV2ZXJ5KChmdW5jdGlvbihlLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tbG9jW3RdKSByZXR1cm4gbiA9IGUsICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB2b2lkIDAgIT09IGkgPyBpIDogZS5hbHRlcm5hdGlvbiwgcyA9IHZvaWQgMCAhPT0gZS5sb2NhdG9yW29dID8gZS5sb2NhdG9yW29dLnRvU3RyaW5nKCkuaW5kZXhPZih0KSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2b2lkIDAgPT09IGEgfHwgcyA8IGEpICYmIC0xICE9PSBzICYmIChuID0gZSwgYSA9IHMpLCAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG4ubG9jYXRvcltuLmFsdGVybmF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobi5tbG9jW3RdIHx8IG4ubWxvY1tyXSB8fCBuLmxvY2F0b3IpLnNsaWNlKCh2b2lkIDAgIT09IGkgPyBpIDogbi5hbHRlcm5hdGlvbikgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBpID8geChlLCB0KSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5hbHRlcm5hdGlvbiwgbiA9IHZvaWQgMCA9PT0gdCB8fCBpID09PSB0LmFsdGVybmF0aW9uICYmIC0xID09PSBlLmxvY2F0b3JbaV0udG9TdHJpbmcoKS5pbmRleE9mKHQubG9jYXRvcltpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbiAmJiBpID4gdC5hbHRlcm5hdGlvbikgZm9yICh2YXIgYSA9IHQuYWx0ZXJuYXRpb247IGEgPCBpOyBhKyspIGlmIChlLmxvY2F0b3JbYV0gIT09IHQubG9jYXRvclthXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGEsIG4gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1sb2MgPSBlLm1sb2MgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUubG9jYXRvcltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgciAmJiAociA9IHIuc3BsaXQoXCIsXCIpWzBdKSwgdm9pZCAwID09PSBlLm1sb2Nbcl0gJiYgKGUubWxvY1tyXSA9IGUubG9jYXRvci5zbGljZSgpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gaW4gdC5tbG9jKSBcInN0cmluZ1wiID09IHR5cGVvZiBvICYmIChvID0gby5zcGxpdChcIixcIilbMF0pLCB2b2lkIDAgPT09IGUubWxvY1tvXSAmJiAoZS5tbG9jW29dID0gdC5tbG9jW29dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5sb2NhdG9yW2ldID0gT2JqZWN0LmtleXMoZS5tbG9jKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5hbHRlcm5hdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHcoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5sb2NhdG9yLmxlbmd0aCAhPT0gdC5sb2NhdG9yLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZS5hbHRlcm5hdGlvbiArIDE7IGkgPCBlLmxvY2F0b3IubGVuZ3RoOyBpKyspIGlmIChlLmxvY2F0b3JbaV0gIT09IHQubG9jYXRvcltpXSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoID4gZSArIHUuX21heFRlc3RQb3MpIHRocm93IFwiSW5wdXRtYXNrOiBUaGVyZSBpcyBwcm9iYWJseSBhbiBlcnJvciBpbiB5b3VyIG1hc2sgZGVmaW5pdGlvbiBvciBpbiB0aGUgY29kZS4gQ3JlYXRlIGFuIGlzc3VlIG9uIGdpdGh1YiB3aXRoIGFuIGV4YW1wbGUgb2YgdGhlIG1hc2sgeW91IGFyZSB1c2luZy4gXCIgKyBsLm1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPT09IGUgJiYgdm9pZCAwID09PSByLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0b3I6IHMucmV2ZXJzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Q6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbG9jOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgIXIub3B0aW9uYWxpdHkgfHwgdm9pZCAwICE9PSBwIHx8ICEodS5kZWZpbml0aW9ucyAmJiB1LmRlZmluaXRpb25zW3IubmF0aXZlRGVmXSAmJiB1LmRlZmluaXRpb25zW3IubmF0aXZlRGVmXS5vcHRpb25hbCB8fCBhLmRlZmF1bHQucHJvdG90eXBlLmRlZmluaXRpb25zW3IubmF0aXZlRGVmXSAmJiBhLmRlZmF1bHQucHJvdG90eXBlLmRlZmluaXRpb25zW3IubmF0aXZlRGVmXS5vcHRpb25hbCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9ICEwLCBoID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gci5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzR3JvdXAgJiYgcCAhPT0gcikgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSBjKHQubWF0Y2hlc1t0Lm1hdGNoZXMuaW5kZXhPZihyKSArIDFdLCBzLCBwKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzT3B0aW9uYWwpIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gciwgYSA9IG0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSBrKHIsIGksIHMsIHApLCBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5mb3JFYWNoKChmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPj0gYSAmJiAoZS5tYXRjaC5vcHRpb25hbGl0eSA9IGUubWF0Y2gub3B0aW9uYWxpdHkgPyBlLm1hdGNoLm9wdGlvbmFsaXR5ICsgMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgbiA9IG1bbS5sZW5ndGggLSAxXS5tYXRjaCwgdm9pZCAwICE9PSBwIHx8ICF2KG4sIHQpKSByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gITAsIGggPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzQWx0ZXJuYXRvcikgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5oYXNBbHRlcm5hdG9yID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiwgYSwgdiwgeSA9IHIsIGsgPSBbXSwgYiA9IG0uc2xpY2UoKSwgUyA9IHMubGVuZ3RoLCBNID0gITEsIF8gPSBpLmxlbmd0aCA+IDAgPyBpLnNoaWZ0KCkgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gXyB8fCBcInN0cmluZ1wiID09IHR5cGVvZiBfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE8sIEUgPSBoLCBUID0gaS5zbGljZSgpLCBqID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIF8pIGogPSBfLnNwbGl0KFwiLFwiKTsgZWxzZSBmb3IgKE8gPSAwOyBPIDwgeS5tYXRjaGVzLmxlbmd0aDsgTysrKSBqLnB1c2goTy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBsLmV4Y2x1ZGVzW2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIEEgPSBqLnNsaWNlKCksIEQgPSAwLCBCID0gbC5leGNsdWRlc1tlXS5sZW5ndGg7IEQgPCBCOyBEKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDID0gbC5leGNsdWRlc1tlXVtEXS50b1N0cmluZygpLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMubGVuZ3RoID09IENbMV0gJiYgai5zcGxpY2Uoai5pbmRleE9mKENbMF0pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09PSBqLmxlbmd0aCAmJiAoZGVsZXRlIGwuZXhjbHVkZXNbZV0sIGogPSBBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEwID09PSB1LmtlZXBTdGF0aWMgfHwgaXNGaW5pdGUocGFyc2VJbnQodS5rZWVwU3RhdGljKSkgJiYgRSA+PSB1LmtlZXBTdGF0aWMpICYmIChqID0gai5zbGljZSgwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgUiA9IDA7IFIgPCBqLmxlbmd0aDsgUisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8gPSBwYXJzZUludChqW1JdKSwgbSA9IFtdLCBpID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgXyAmJiB4KGgsIE8sIFMpIHx8IFQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEwgPSB5Lm1hdGNoZXNbT107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMICYmIGMoTCwgWyBPIF0uY29uY2F0KHMpLCBwKSkgciA9ICEwOyBlbHNlIGlmICgwID09PSBSICYmIChNID0gITApLCBMICYmIEwubWF0Y2hlcyAmJiBMLm1hdGNoZXMubGVuZ3RoID4geS5tYXRjaGVzWzBdLm1hdGNoZXMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG0uc2xpY2UoKSwgaCA9IEUsIG0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgRiA9IDA7IEYgPCBuLmxlbmd0aDsgRisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgSSA9IG5bRl0sIE4gPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEkubWF0Y2guaml0ID0gSS5tYXRjaC5qaXQgfHwgTSwgSS5hbHRlcm5hdGlvbiA9IEkuYWx0ZXJuYXRpb24gfHwgUywgUChJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIFYgPSAwOyBWIDwgay5sZW5ndGg7IFYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBHID0ga1tWXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgXyB8fCB2b2lkIDAgIT09IEkuYWx0ZXJuYXRpb24gJiYgai5pbmNsdWRlcyhJLmxvY2F0b3JbSS5hbHRlcm5hdGlvbl0udG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEkubWF0Y2gubmF0aXZlRGVmID09PSBHLm1hdGNoLm5hdGl2ZURlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTiA9ICEwLCBQKEcsIEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYoSSwgRywgdSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAoSSwgRykgJiYgKE4gPSAhMCwgay5zcGxpY2Uoay5pbmRleE9mKEcpLCAwLCBJKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZihHLCBJLCB1KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUChHLCBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID0gRywgITAgPT09IChhID0gSSkubWF0Y2guc3RhdGljICYmICEwICE9PSB2Lm1hdGNoLnN0YXRpYyAmJiB2Lm1hdGNoLmZuLnRlc3QoYS5tYXRjaC5kZWYsIGwsIGUsICExLCB1LCAhMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcoSSwgRykgfHwgdm9pZCAwICE9PSBkLmlucHV0bWFzay51c2VyT3B0aW9ucy5rZWVwU3RhdGljID8gUChJLCBHKSAmJiAoTiA9ICEwLCBrLnNwbGljZShrLmluZGV4T2YoRyksIDAsIEkpKSA6IHUua2VlcFN0YXRpYyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOIHx8IGsucHVzaChJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gYi5jb25jYXQoayksIGggPSBlLCBnID0gbS5sZW5ndGggPiAwLCByID0gay5sZW5ndGggPiAwLCBpID0gVC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHIgPSBjKHkubWF0Y2hlc1tfXSB8fCB0Lm1hdGNoZXNbX10sIFsgXyBdLmNvbmNhdChzKSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzUXVhbnRpZmllciAmJiBwICE9PSB0Lm1hdGNoZXNbdC5tYXRjaGVzLmluZGV4T2YocikgLSAxXSkgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHIsIG8gPSAhMSwgZiA9IGkubGVuZ3RoID4gMCA/IGkuc2hpZnQoKSA6IDA7IGYgPCAoaXNOYU4oYS5xdWFudGlmaWVyLm1heCkgPyBmICsgMSA6IGEucXVhbnRpZmllci5tYXgpICYmIGggPD0gZTsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0Lm1hdGNoZXNbdC5tYXRjaGVzLmluZGV4T2YoYSkgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IGMoZCwgWyBmIF0uY29uY2F0KHMpLCBkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5mb3JFYWNoKChmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobiA9IGIoZCwgdC5tYXRjaCkgPyB0Lm1hdGNoIDogbVttLmxlbmd0aCAtIDFdLm1hdGNoKS5vcHRpb25hbFF1YW50aWZpZXIgPSBmID49IGEucXVhbnRpZmllci5taW4sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5qaXQgPSAoZiArIDEpICogKGQubWF0Y2hlcy5pbmRleE9mKG4pICsgMSkgPiBhLnF1YW50aWZpZXIuaml0LCBuLm9wdGlvbmFsUXVhbnRpZmllciAmJiB2KG4sIGQpICYmIChnID0gITAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGUsIHUuZ3JlZWR5ICYmIG51bGwgPT0gbC52YWxpZFBvc2l0aW9uc1tlIC0gMV0gJiYgZiA+IGEucXVhbnRpZmllci5taW4gJiYgLTEgIT0gWyBcIipcIiwgXCIrXCIgXS5pbmRleE9mKGEucXVhbnRpZmllci5tYXgpICYmIChtLnBvcCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB2b2lkIDApLCBvID0gITAsIHIgPSAhMSksICFvICYmIG4uaml0ICYmIChsLmppdE9mZnNldFtlXSA9IGQubWF0Y2hlcy5sZW5ndGggLSBkLm1hdGNoZXMuaW5kZXhPZihuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgbykgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSBrKHIsIGksIHMsIHApKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSBpLmxlbmd0aCA+IDAgPyBpLnNoaWZ0KCkgOiAwOyBwIDwgdC5tYXRjaGVzLmxlbmd0aDsgcCsrKSBpZiAoITAgIT09IHQubWF0Y2hlc1twXS5pc1F1YW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGModC5tYXRjaGVzW3BdLCBbIHAgXS5jb25jYXQociksIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICYmIGggPT09IGUpIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoID4gZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IC0xICE9IGUubWF0Y2hlcy5pbmRleE9mKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgfHwgZS5tYXRjaGVzLmZvckVhY2goKGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUubWF0Y2hlcyB8fCBpIHx8IChpID0gYihlLCB0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHgsIFAgPSBlIC0gMTsgdm9pZCAwID09PSAoeCA9IGwudmFsaWRQb3NpdGlvbnNbUF0gfHwgbC50ZXN0c1tQXSkgJiYgUCA+IC0xOyApIFAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHggJiYgUCA+IC0xICYmICh2ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSB8fCAodCA9IFsgdCBdKSwgdC5sZW5ndGggPiAwICYmICh2b2lkIDAgPT09IHRbMF0uYWx0ZXJuYXRpb24gfHwgITAgPT09IHUua2VlcFN0YXRpYyA/IDAgPT09IChuID0gYy5jYWxsKG8sIGUsIHQuc2xpY2UoKSkubG9jYXRvci5zbGljZSgpKS5sZW5ndGggJiYgKG4gPSB0WzBdLmxvY2F0b3Iuc2xpY2UoKSkgOiB0LmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgIT09IGUuZGVmICYmICgwID09PSBuLmxlbmd0aCA/IChpID0gZS5hbHRlcm5hdGlvbiwgbiA9IGUubG9jYXRvci5zbGljZSgpKSA6IGUubG9jYXRvcltpXSAmJiAtMSA9PT0gbltpXS50b1N0cmluZygpLmluZGV4T2YoZS5sb2NhdG9yW2ldKSAmJiAobltpXSArPSBcIixcIiArIGUubG9jYXRvcltpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpLCBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oUCwgeCksIHkgPSB2LmpvaW4oXCJcIiksIGggPSBQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsLnRlc3RzW2VdICYmIGwudGVzdHNbZV1bMF0uY2QgPT09IHkpIHJldHVybiBsLnRlc3RzW2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IHYuc2hpZnQoKTsgdyA8IHAubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayhwW3ddLCB2LCBbIHcgXSkgJiYgaCA9PT0gZSB8fCBoID4gZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwID09PSBtLmxlbmd0aCB8fCBnKSAmJiBtLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRvcjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtbG9jOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNkOiB5XG4gICAgICAgICAgICAgICAgICAgIH0pLCB2b2lkIDAgIT09IHQgJiYgbC50ZXN0c1tlXSA/IHIgPSBzLmV4dGVuZCghMCwgW10sIG0pIDogKGwudGVzdHNbZV0gPSBzLmV4dGVuZCghMCwgW10sIG0pLCBcbiAgICAgICAgICAgICAgICAgICAgciA9IGwudGVzdHNbZV0pLCBtLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWF0Y2gub3B0aW9uYWxpdHkgPSBlLm1hdGNoLmRlZk9wdGlvbmFsaXR5IHx8ICExO1xuICAgICAgICAgICAgICAgICAgICB9KSksIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDcyMTU6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuYWx0ZXJuYXRlID0gcywgdC5jaGVja0FsdGVybmF0aW9uTWF0Y2ggPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4sIGEgPSB0aGlzLm9wdHMuZ3JlZWR5ID8gdCA6IHQuc2xpY2UoMCwgMSksIHIgPSAhMSwgbyA9IHZvaWQgMCAhPT0gaSA/IGkuc3BsaXQoXCIsXCIpIDogW10sIHMgPSAwOyBzIDwgby5sZW5ndGg7IHMrKykgLTEgIT09IChuID0gZS5pbmRleE9mKG9bc10pKSAmJiBlLnNwbGljZShuLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCsrKSBpZiAoYS5pbmNsdWRlcyhlW2xdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfSwgdC5oYW5kbGVSZW1vdmUgPSBmdW5jdGlvbihlLCB0LCBpLCBvLCBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcywgdSA9IHRoaXMubWFza3NldCwgZiA9IHRoaXMub3B0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmLm51bWVyaWNJbnB1dCB8fCBjLmlzUlRMKSAmJiAodCA9PT0gYS5rZXlzLkJhY2tzcGFjZSA/IHQgPSBhLmtleXMuRGVsZXRlIDogdCA9PT0gYS5rZXlzLkRlbGV0ZSAmJiAodCA9IGEua2V5cy5CYWNrc3BhY2UpLCBcbiAgICAgICAgICAgICAgICAgICAgYy5pc1JUTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gaS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmVuZCA9IGkuYmVnaW4sIGkuYmVnaW4gPSBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwLCBoID0gci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGMsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICBpLmVuZCA+PSByLmdldEJ1ZmZlci5jYWxsKGMpLmxlbmd0aCAmJiBoID49IGkuZW5kICYmIChpLmVuZCA9IGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdCA9PT0gYS5rZXlzLkJhY2tzcGFjZSA/IGkuZW5kIC0gaS5iZWdpbiA8IDEgJiYgKGkuYmVnaW4gPSByLnNlZWtQcmV2aW91cy5jYWxsKGMsIGkuYmVnaW4pKSA6IHQgPT09IGEua2V5cy5EZWxldGUgJiYgaS5iZWdpbiA9PT0gaS5lbmQgJiYgKGkuZW5kID0gci5pc01hc2suY2FsbChjLCBpLmVuZCwgITAsICEwKSA/IGkuZW5kICsgMSA6IHIuc2Vla05leHQuY2FsbChjLCBpLmVuZCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSAocCA9IHYuY2FsbChjLCBpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCAhPT0gbyAmJiAhMSAhPT0gZi5rZWVwU3RhdGljIHx8IG51bGwgIT09IGYucmVnZXggJiYgLTEgIT09IG4uZ2V0VGVzdC5jYWxsKGMsIGkuYmVnaW4pLm1hdGNoLmRlZi5pbmRleE9mKFwifFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gcy5jYWxsKGMsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHZvaWQgMCAhPT0gbS5jYXJldCA/IG0uY2FyZXQgOiBtLnBvcyA/IHIuc2Vla05leHQuY2FsbChjLCBtLnBvcy5iZWdpbiA/IG0ucG9zLmJlZ2luIDogbS5wb3MpIDogci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGMsIC0xLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ICE9PSBhLmtleXMuRGVsZXRlIHx8IGkuYmVnaW4gPiBnKSAmJiBpLmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSBvICYmICh1LnAgPSB0ID09PSBhLmtleXMuRGVsZXRlID8gaS5iZWdpbiArIHAgOiBpLmJlZ2luLCB1LnAgPSByLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbChjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IHUucCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHUucFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgITEsICExID09PSBmLmluc2VydE1vZGUgJiYgdCA9PT0gYS5rZXlzLkJhY2tzcGFjZSA/IFwibm9uZVwiIDogdm9pZCAwKS5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0LmlzQ29tcGxldGUgPSBjLCB0LmlzU2VsZWN0aW9uID0gdSwgdC5pc1ZhbGlkID0gZiwgdC5yZWZyZXNoRnJvbUJ1ZmZlciA9IHAsIFxuICAgICAgICAgICAgICAgIHQucmV2YWxpZGF0ZU1hc2sgPSB2O1xuICAgICAgICAgICAgICAgIHZhciBuID0gaSg0NzEzKSwgYSA9IGkoMjgzOSksIHIgPSBpKDg3MTEpLCBvID0gaSg2MDMwKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUsIHQsIGksIGEsIG8sIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMsIHUsIGQsIHAsIGgsIHYsIG0sIGcsIHksIGssIGIsIHggPSB0aGlzLCBQID0gdGhpcy5kZXBlbmRlbmN5TGliLCB3ID0gdGhpcy5vcHRzLCBTID0geC5tYXNrc2V0LCBNID0gUC5leHRlbmQoITAsIFtdLCBTLnZhbGlkUG9zaXRpb25zKSwgXyA9IFAuZXh0ZW5kKCEwLCB7fSwgUy50ZXN0cyksIE8gPSAhMSwgRSA9ICExLCBUID0gdm9pZCAwICE9PSBvID8gbyA6IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgJiYgKGsgPSBsLmJlZ2luLCBiID0gbC5lbmQsIGwuYmVnaW4gPiBsLmVuZCAmJiAoayA9IGwuZW5kLCBiID0gbC5iZWdpbikpLCBcbiAgICAgICAgICAgICAgICAgICAgLTEgPT09IFQgJiYgdm9pZCAwID09PSBvKSBjID0gMCwgdSA9IChwID0gbi5nZXRUZXN0LmNhbGwoeCwgYykpLmFsdGVybmF0aW9uOyBlbHNlIGZvciAoO1QgPj0gMDsgVC0tKSBpZiAoKGQgPSBTLnZhbGlkUG9zaXRpb25zW1RdKSAmJiB2b2lkIDAgIT09IGQuYWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUIDw9IChlIHx8IDApICYmIHAgJiYgcC5sb2NhdG9yW2QuYWx0ZXJuYXRpb25dICE9PSBkLmxvY2F0b3JbZC5hbHRlcm5hdGlvbl0pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IFQsIHUgPSBTLnZhbGlkUG9zaXRpb25zW2NdLmFsdGVybmF0aW9uLCBwID0gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gcGFyc2VJbnQoYyksIFMuZXhjbHVkZXNbbV0gPSBTLmV4Y2x1ZGVzW21dIHx8IFtdLCAhMCAhPT0gZSAmJiBTLmV4Y2x1ZGVzW21dLnB1c2goKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5nZXREZWNpc2lvblRha2VyKShwKSArIFwiOlwiICsgcC5hbHRlcm5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IFtdLCBBID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGggPSBtOyBoIDwgci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHgsIHZvaWQgMCwgITApICsgMTsgaCsrKSAtMSA9PT0gQSAmJiBlIDw9IGggJiYgdm9pZCAwICE9PSB0ICYmIChqLnB1c2godCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgQSA9IGoubGVuZ3RoIC0gMSksICh2ID0gUy52YWxpZFBvc2l0aW9uc1toXSkgJiYgITAgIT09IHYuZ2VuZXJhdGVkSW5wdXQgJiYgKHZvaWQgMCA9PT0gbCB8fCBoIDwgayB8fCBoID49IGIpICYmIGoucHVzaCh2LmlucHV0KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgUy52YWxpZFBvc2l0aW9uc1toXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoLTEgPT09IEEgJiYgdm9pZCAwICE9PSB0ICYmIChqLnB1c2godCksIEEgPSBqLmxlbmd0aCAtIDEpOyB2b2lkIDAgIT09IFMuZXhjbHVkZXNbbV0gJiYgUy5leGNsdWRlc1ttXS5sZW5ndGggPCAxMDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChTLnRlc3RzID0ge30sIHIucmVzZXRNYXNrU2V0LmNhbGwoeCwgITApLCBPID0gITAsIGggPSAwOyBoIDwgai5sZW5ndGggJiYgKGcgPSBPLmNhcmV0IHx8IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh4LCB2b2lkIDAsICEwKSArIDEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBqW2hdLCBPID0gZi5jYWxsKHgsIGcsIHksICExLCBhLCAhMCkpOyBoKyspIGggPT09IEEgJiYgKEUgPSBPKSwgMSA9PSBlICYmIE8gJiYgKEUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zOiBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE8pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnJlc2V0TWFza1NldC5jYWxsKHgpLCBwID0gbi5nZXRUZXN0LmNhbGwoeCwgbSksIFMudmFsaWRQb3NpdGlvbnMgPSBQLmV4dGVuZCghMCwgW10sIE0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLnRlc3RzID0gUC5leHRlbmQoITAsIHt9LCBfKSwgIVMuZXhjbHVkZXNbbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRSA9IHMuY2FsbCh4LCBlLCB0LCBpLCBhLCBtIC0gMSwgbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRCA9ICgwLCBuLmdldERlY2lzaW9uVGFrZXIpKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gUy5leGNsdWRlc1ttXS5pbmRleE9mKEQgKyBcIjpcIiArIHAuYWx0ZXJuYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUgPSBzLmNhbGwoeCwgZSwgdCwgaSwgYSwgbSAtIDEsIGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChTLmV4Y2x1ZGVzW21dLnB1c2goRCArIFwiOlwiICsgcC5hbHRlcm5hdGlvbiksIGggPSBtOyBoIDwgci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHgsIHZvaWQgMCwgITApICsgMTsgaCsrKSBkZWxldGUgUy52YWxpZFBvc2l0aW9uc1toXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRSAmJiAhMSA9PT0gdy5rZWVwU3RhdGljIHx8IGRlbGV0ZSBTLmV4Y2x1ZGVzW21dLCBFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm9wdHMsIHIgPSB0aGlzLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobi5jYXNpbmcgfHwgdC5jYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidXBwZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb3dlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHIudmFsaWRQb3NpdGlvbnNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IDAgPT09IGkgfHwgbyAmJiBvLmlucHV0ID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKGEua2V5Q29kZS5TcGFjZSkgPyBlLnRvVXBwZXJDYXNlKCkgOiBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBuLmNhc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnB1c2goci52YWxpZFBvc2l0aW9ucyksIGUgPSBuLmNhc2luZy5hcHBseSh0aGlzLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcywgaSA9IHRoaXMub3B0cywgYSA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaS5pc0NvbXBsZXRlKSByZXR1cm4gaS5pc0NvbXBsZXRlKGUsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCIqXCIgIT09IGkucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9ICExLCBzID0gci5kZXRlcm1pbmVMYXN0UmVxdWlyZWRQb3NpdGlvbi5jYWxsKHQsICEwKSwgbCA9IHIuc2Vla1ByZXZpb3VzLmNhbGwodCwgcy5sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHMuZGVmIHx8IHMuZGVmLm5ld0Jsb2NrTWFya2VyIHx8IHMuZGVmLm9wdGlvbmFsaXR5IHx8IHMuZGVmLm9wdGlvbmFsUXVhbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8PSBsOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBuLmdldFRlc3RUZW1wbGF0ZS5jYWxsKHQsIGMpLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IHUuc3RhdGljICYmIHZvaWQgMCA9PT0gYS52YWxpZFBvc2l0aW9uc1tjXSAmJiAhMCAhPT0gdS5vcHRpb25hbGl0eSAmJiAhMCAhPT0gdS5vcHRpb25hbFF1YW50aWZpZXIgfHwgITAgPT09IHUuc3RhdGljICYmIGVbY10gIT09IG4uZ2V0UGxhY2Vob2xkZXIuY2FsbCh0LCBjLCB1KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLm9wdHMuaW5zZXJ0TW9kZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1JUTCA/IGUuYmVnaW4gLSBlLmVuZCA+IHQgOiBlLmVuZCAtIGUuYmVnaW4gPiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQsIGksIGEsIG8sIGQsIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSB0aGlzLCB5ID0gdGhpcy5kZXBlbmRlbmN5TGliLCBrID0gdGhpcy5vcHRzLCBiID0gZy5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICBpID0gITAgPT09IGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZS5yZW1vdmUgJiYgKEFycmF5LmlzQXJyYXkoZS5yZW1vdmUpIHx8IChlLnJlbW92ZSA9IFsgZS5yZW1vdmUgXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlLnNvcnQoKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGcuaXNSVEwgPyBlLnBvcyAtIHQucG9zIDogdC5wb3MgLSBlLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmNhbGwoZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGUgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgZS5yZW1vdmUgPSB2b2lkIDApLCB2b2lkIDAgIT09IGUuaW5zZXJ0ICYmIChBcnJheS5pc0FycmF5KGUuaW5zZXJ0KSB8fCAoZS5pbnNlcnQgPSBbIGUuaW5zZXJ0IF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmluc2VydC5zb3J0KChmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnLmlzUlRMID8gdC5wb3MgLSBlLnBvcyA6IGUucG9zIC0gdC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gZS5jICYmIGYuY2FsbChnLCBlLnBvcywgZS5jLCB2b2lkIDAgPT09IGUuc3RyaWN0IHx8IGUuc3RyaWN0LCB2b2lkIDAgIT09IGUuZnJvbUlzVmFsaWQgPyBlLmZyb21Jc1ZhbGlkIDogYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlLmluc2VydCA9IHZvaWQgMCksIGUucmVmcmVzaEZyb21CdWZmZXIgJiYgZS5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnJlZnJlc2hGcm9tQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmNhbGwoZywgITAgPT09IHQgPyB0IDogdC5zdGFydCwgdC5lbmQsIGUuYnVmZmVyKSwgZS5yZWZyZXNoRnJvbUJ1ZmZlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBlLnJld3JpdGVQb3NpdGlvbiAmJiAoeCA9IGUucmV3cml0ZVBvc2l0aW9uLCBlID0gITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdyh0LCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZ2V0VGVzdHMuY2FsbChnLCB0KS5ldmVyeSgoZnVuY3Rpb24oYywgZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gYy5tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5nZXRCdWZmZXIuY2FsbChnLCAhMCksICExICE9PSAocyA9ICghZC5qaXQgfHwgdm9pZCAwICE9PSBiLnZhbGlkUG9zaXRpb25zW3Iuc2Vla1ByZXZpb3VzLmNhbGwoZywgdCldKSAmJiAobnVsbCAhPSBkLmZuID8gZC5mbi50ZXN0KGksIGIsIHQsIG8sIGssIHUuY2FsbChnLCBlKSkgOiAoaSA9PT0gZC5kZWYgfHwgaSA9PT0gay5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyKSAmJiBcIlwiICE9PSBkLmRlZiAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IG4uZ2V0UGxhY2Vob2xkZXIuY2FsbChnLCB0LCBkLCAhMCkgfHwgZC5kZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHZvaWQgMCAhPT0gcy5jID8gcy5jIDogaSwgaCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwID0gcCA9PT0gay5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyICYmICEwID09PSBkLnN0YXRpYyA/IG4uZ2V0UGxhY2Vob2xkZXIuY2FsbChnLCB0LCBkLCAhMCkgfHwgZC5kZWYgOiBwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgITAgIT09IChzID0gUChzKSkgJiYgdm9pZCAwICE9PSBzLnBvcyAmJiBzLnBvcyAhPT0gdCAmJiAoaCA9IHMucG9zKSwgITAgIT09IHMgJiYgdm9pZCAwID09PSBzLnBvcyAmJiB2b2lkIDAgPT09IHMuYyA/ICExIDogKCExID09PSB2LmNhbGwoZywgZSwgeS5leHRlbmQoe30sIGMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBsLmNhbGwoZywgcCwgZCwgaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGEsIGgpICYmIChzID0gITEpLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGUuYmVnaW4gJiYgKHggPSBnLmlzUlRMID8gZS5lbmQgOiBlLmJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFMgPSAhMCwgTSA9IHkuZXh0ZW5kKCEwLCB7fSwgYi52YWxpZFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gay5rZWVwU3RhdGljICYmIHZvaWQgMCAhPT0gYi5leGNsdWRlc1t4XSAmJiAhMCAhPT0gbyAmJiAhMCAhPT0gYSkgZm9yICh2YXIgXyA9IHg7IF8gPCAoZy5pc1JUTCA/IGUuYmVnaW4gOiBlLmVuZCk7IF8rKykgdm9pZCAwICE9PSBiLmV4Y2x1ZGVzW19dICYmIChiLmV4Y2x1ZGVzW19dID0gdm9pZCAwLCBcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGIudGVzdHNbX10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBrLnByZVZhbGlkYXRpb24gJiYgITAgIT09IGEgJiYgITAgIT09IGQgJiYgKFMgPSBQKFMgPSBrLnByZVZhbGlkYXRpb24uY2FsbChnLCByLmdldEJ1ZmZlci5jYWxsKGcpLCB4LCB0LCB1LmNhbGwoZywgZSksIGssIGIsIGUsIGkgfHwgbykpKSwgXG4gICAgICAgICAgICAgICAgICAgICEwID09PSBTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUyA9IHcoeCwgdCwgaSksICghaSB8fCAhMCA9PT0gYSkgJiYgITEgPT09IFMgJiYgITAgIT09IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTyA9IGIudmFsaWRQb3NpdGlvbnNbeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFPIHx8ICEwICE9PSBPLm1hdGNoLnN0YXRpYyB8fCBPLm1hdGNoLmRlZiAhPT0gdCAmJiB0ICE9PSBrLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsuaW5zZXJ0TW9kZSB8fCB2b2lkIDAgPT09IGIudmFsaWRQb3NpdGlvbnNbci5zZWVrTmV4dC5jYWxsKGcsIHgpXSB8fCBlLmVuZCA+IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBFID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5qaXRPZmZzZXRbeF0gJiYgdm9pZCAwID09PSBiLnZhbGlkUG9zaXRpb25zW3Iuc2Vla05leHQuY2FsbChnLCB4KV0gJiYgITEgIT09IChTID0gZi5jYWxsKGcsIHggKyBiLmppdE9mZnNldFt4XSwgdCwgITAsICEwKSkgJiYgKCEwICE9PSBvICYmIChTLmNhcmV0ID0geCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRSA9ICEwKSwgZS5lbmQgPiB4ICYmIChiLnZhbGlkUG9zaXRpb25zW3hdID0gdm9pZCAwKSwgIUUgJiYgIXIuaXNNYXNrLmNhbGwoZywgeCwgay5rZWVwU3RhdGljICYmIDAgPT09IHgpKSBmb3IgKHZhciBUID0geCArIDEsIGogPSByLnNlZWtOZXh0LmNhbGwoZywgeCwgITEsIDAgIT09IHgpOyBUIDw9IGo7IFQrKykgaWYgKCExICE9PSAoUyA9IHcoVCwgdCwgaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUyA9IGguY2FsbChnLCB4LCB2b2lkIDAgIT09IFMucG9zID8gUy5wb3MgOiBUKSB8fCBTLCB4ID0gVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBTID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldDogci5zZWVrTmV4dC5jYWxsKGcsIHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGcuaGFzQWx0ZXJuYXRvciAmJiAhMCAhPT0gbyAmJiAhaSAmJiAoITEgPT09IFMgJiYgay5rZWVwU3RhdGljICYmIChjLmNhbGwoZywgci5nZXRCdWZmZXIuY2FsbChnKSkgfHwgMCA9PT0geCkgPyBTID0gcy5jYWxsKGcsIHgsIHQsIGksIGEsIHZvaWQgMCwgZSkgOiAodS5jYWxsKGcsIGUpICYmIGIudGVzdHNbeF0gJiYgYi50ZXN0c1t4XS5sZW5ndGggPiAxICYmIGsua2VlcFN0YXRpYyB8fCAxID09IFMgJiYgITAgIT09IGsubnVtZXJpY0lucHV0ICYmIGIudGVzdHNbeF0gJiYgYi50ZXN0c1t4XS5sZW5ndGggPiAxICYmIHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChnLCB2b2lkIDAsICEwKSA+IHgpICYmIChTID0gcy5jYWxsKGcsICEwKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSBTICYmIChTID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogeFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygay5wb3N0VmFsaWRhdGlvbiAmJiAhMCAhPT0gYSAmJiAhMCAhPT0gZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSBrLnBvc3RWYWxpZGF0aW9uLmNhbGwoZywgci5nZXRCdWZmZXIuY2FsbChnLCAhMCksIHZvaWQgMCAhPT0gZS5iZWdpbiA/IGcuaXNSVEwgPyBlLmVuZCA6IGUuYmVnaW4gOiBlLCB0LCBTLCBrLCBiLCBpLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gQSAmJiAoUyA9ICEwID09PSBBID8gUyA6IEEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFMgJiYgdm9pZCAwID09PSBTLnBvcyAmJiAoUy5wb3MgPSB4KSwgITEgPT09IFMgfHwgITAgPT09IGQgPyAoci5yZXNldE1hc2tTZXQuY2FsbChnLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICBiLnZhbGlkUG9zaXRpb25zID0geS5leHRlbmQoITAsIFtdLCBNKSkgOiBoLmNhbGwoZywgdm9pZCAwLCB4LCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBEID0gUChTKTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBnLm1heExlbmd0aCAmJiAoci5nZXRCdWZmZXIuY2FsbChnKS5sZW5ndGggPiBnLm1heExlbmd0aCAmJiAhYSAmJiAoci5yZXNldE1hc2tTZXQuY2FsbChnLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICBiLnZhbGlkUG9zaXRpb25zID0geS5leHRlbmQoITAsIFtdLCBNKSwgRCA9ICExKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHRoaXMubWFza3NldCwgciA9ICExLCBvID0gbi5nZXRUZXN0cy5jYWxsKHRoaXMsIGUpLCBzID0gMDsgcyA8IG8ubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvW3NdLm1hdGNoICYmIChvW3NdLm1hdGNoLm5hdGl2ZURlZiA9PT0gdC5tYXRjaFtpLnNoaWZ0UG9zaXRpb25zID8gXCJkZWZcIiA6IFwibmF0aXZlRGVmXCJdICYmICghaS5zaGlmdFBvc2l0aW9ucyB8fCAhdC5tYXRjaC5zdGF0aWMpIHx8IG9bc10ubWF0Y2gubmF0aXZlRGVmID09PSB0Lm1hdGNoLm5hdGl2ZURlZiB8fCBpLnJlZ2V4ICYmICFvW3NdLm1hdGNoLnN0YXRpYyAmJiBvW3NdLm1hdGNoLmZuLnRlc3QodC5pbnB1dCwgYSwgZSwgITEsIGkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvW3NdLm1hdGNoICYmIG9bc10ubWF0Y2guZGVmID09PSB0Lm1hdGNoLm5hdGl2ZURlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExID09PSByICYmIHZvaWQgMCAhPT0gYS5qaXRPZmZzZXRbZV0gJiYgKHIgPSBkLmNhbGwodGhpcywgZSArIGEuaml0T2Zmc2V0W2VdLCB0LCBpKSksIFxuICAgICAgICAgICAgICAgICAgICByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4sIGEsIHMgPSB0aGlzLCBsID0gdGhpcy5tYXNrc2V0LCBjID0gdGhpcy5vcHRzLCB1ID0gdGhpcy5kZXBlbmRlbmN5TGliLCBmID0gYy5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyLCBkID0gcy5pc1JUTCA/IGkuc2xpY2UoKS5yZXZlcnNlKCkgOiBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyID0gXCJcIiwgITAgPT09IGUpIHIucmVzZXRNYXNrU2V0LmNhbGwocyksIGwudGVzdHMgPSB7fSwgXG4gICAgICAgICAgICAgICAgICAgIGUgPSAwLCB0ID0gaS5sZW5ndGgsIGEgPSByLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbChzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogMFxuICAgICAgICAgICAgICAgICAgICB9LCAhMSkuYmVnaW47IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gZTsgbiA8IHQ7IG4rKykgZGVsZXRlIGwudmFsaWRQb3NpdGlvbnNbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyB1LkV2ZW50KFwia2V5cHJlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IGU7IG4gPCB0OyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAua2V5ID0gZFtuXS50b1N0cmluZygpLCBzLmlnbm9yYWJsZSA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBvLkV2ZW50SGFuZGxlcnMua2V5cHJlc3NFdmVudC5jYWxsKHMsIHAsICEwLCAhMSwgITEsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IGggJiYgdm9pZCAwICE9PSBoICYmIChhID0gaC5mb3J3YXJkUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGgoZSwgdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMsIG8gPSB0aGlzLm1hc2tzZXQsIHMgPSB0aGlzLmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIGZvciAoZSA9IHQgLSAxOyBlID4gMCAmJiAhby52YWxpZFBvc2l0aW9uc1tlXTsgZS0tKSA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBlOyBsIDwgdDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBvLnZhbGlkUG9zaXRpb25zW2xdICYmICFyLmlzTWFzay5jYWxsKGEsIGwsICExKSkgaWYgKDAgPT0gbCA/IG4uZ2V0VGVzdC5jYWxsKGEsIGwpIDogby52YWxpZFBvc2l0aW9uc1tsIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG4uZ2V0VGVzdHMuY2FsbChhLCBsKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IGNbYy5sZW5ndGggLSAxXS5tYXRjaC5kZWYgJiYgYy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSwgZCA9IG4uZGV0ZXJtaW5lVGVzdFRlbXBsYXRlLmNhbGwoYSwgbCwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgJiYgKCEwICE9PSBkLm1hdGNoLmppdCB8fCBcIm1hc3RlclwiID09PSBkLm1hdGNoLm5ld0Jsb2NrTWFya2VyICYmICh1ID0gby52YWxpZFBvc2l0aW9uc1tsICsgMV0pICYmICEwID09PSB1Lm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllcikgJiYgKChkID0gcy5leHRlbmQoe30sIGQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG4uZ2V0UGxhY2Vob2xkZXIuY2FsbChhLCBsLCBkLm1hdGNoLCAhMCkgfHwgZC5tYXRjaC5kZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuZ2VuZXJhdGVkSW5wdXQgPSAhMCwgdi5jYWxsKGEsIGwsIGQsICEwKSwgITAgIT09IGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gby52YWxpZFBvc2l0aW9uc1t0XS5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8udmFsaWRQb3NpdGlvbnNbdF0gPSB2b2lkIDAsIGYuY2FsbChhLCB0LCBwLCAhMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUsIHQsIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLCBzID0gdGhpcy5tYXNrc2V0LCBsID0gdGhpcy5vcHRzLCBjID0gdGhpcy5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdFtlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IG4gJiYgITAgPT09IG4ubWF0Y2guc3RhdGljICYmICEwICE9PSBuLm1hdGNoLm9wdGlvbmFsaXR5ICYmICh2b2lkIDAgPT09IHRbMF0gfHwgdm9pZCAwID09PSB0WzBdLmFsdGVybmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gaS5iZWdpbiA8PSBlIC0gMSA/IHRbZSAtIDFdICYmICEwID09PSB0W2UgLSAxXS5tYXRjaC5zdGF0aWMgJiYgdFtlIC0gMV0gOiB0W2UgLSAxXSwgciA9IGkuZW5kID4gZSArIDEgPyB0W2UgKyAxXSAmJiAhMCA9PT0gdFtlICsgMV0ubWF0Y2guc3RhdGljICYmIHRbZSArIDFdIDogdFtlICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgJiYgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IDAsIGggPSB2b2lkIDAgIT09IGUuYmVnaW4gPyBlLmJlZ2luIDogZSwgdiA9IHZvaWQgMCAhPT0gZS5lbmQgPyBlLmVuZCA6IGUsIG0gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYmVnaW4gPiBlLmVuZCAmJiAoaCA9IGUuZW5kLCB2ID0gZS5iZWdpbiksIGEgPSB2b2lkIDAgIT09IGEgPyBhIDogaCwgdm9pZCAwID09PSBpICYmIChoICE9PSB2IHx8IGwuaW5zZXJ0TW9kZSAmJiB2b2lkIDAgIT09IHMudmFsaWRQb3NpdGlvbnNbYV0gfHwgdm9pZCAwID09PSB0IHx8IHQubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyIHx8IHQubWF0Y2gub3B0aW9uYWxpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZywgeSA9IGMuZXh0ZW5kKCEwLCB7fSwgcy52YWxpZFBvc2l0aW9ucyksIGsgPSByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwobywgdm9pZCAwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHMucCA9IGgsIGcgPSBrOyBnID49IGg7IGctLSkgZGVsZXRlIHMudmFsaWRQb3NpdGlvbnNbZ10sIHZvaWQgMCA9PT0gdCAmJiBkZWxldGUgcy50ZXN0c1tnICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiwgeCwgUCA9IGEsIHcgPSBQO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh0ICYmIChzLnZhbGlkUG9zaXRpb25zW2FdID0gYy5leHRlbmQoITAsIHt9LCB0KSwgdysrLCBQKyspLCBnID0gdCA/IHYgOiB2IC0gMTsgZyA8PSBrOyBnKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSAoYiA9IHlbZ10pICYmICEwICE9PSBiLmdlbmVyYXRlZElucHV0ICYmIChnID49IHYgfHwgZyA+PSBoICYmIHUoZywgeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO1wiXCIgIT09IG4uZ2V0VGVzdC5jYWxsKG8sIHcpLm1hdGNoLmRlZjsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgIT09ICh4ID0gZC5jYWxsKG8sIHcsIGIsIGwpKSB8fCBcIitcIiA9PT0gYi5tYXRjaC5kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitcIiA9PT0gYi5tYXRjaC5kZWYgJiYgci5nZXRCdWZmZXIuY2FsbChvLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFMgPSBmLmNhbGwobywgdywgYi5pbnB1dCwgXCIrXCIgIT09IGIubWF0Y2guZGVmLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPSAhMSAhPT0gUywgUCA9IChTLnBvcyB8fCB3KSArIDEsICFtICYmIHgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIG0gPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmIGIubWF0Y2guc3RhdGljICYmIGcgPT09IGUuYmVnaW4gJiYgcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtICYmIHIuZ2V0QnVmZmVyLmNhbGwobyksIHcgPiBzLm1hc2tMZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgPT0gbi5nZXRUZXN0LmNhbGwobywgdykubWF0Y2guZGVmICYmIChtID0gITEpLCB3ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbSkgcmV0dXJuIHMudmFsaWRQb3NpdGlvbnMgPSBjLmV4dGVuZCghMCwgW10sIHkpLCByLnJlc2V0TWFza1NldC5jYWxsKG8sICEwKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHQgJiYgbi5nZXRUZXN0LmNhbGwobywgYSkubWF0Y2guY2QgPT09IHQubWF0Y2guY2QgJiYgKHMudmFsaWRQb3NpdGlvbnNbYV0gPSBjLmV4dGVuZCghMCwge30sIHQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIucmVzZXRNYXNrU2V0LmNhbGwobywgITApLCBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdCA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBpKG4pIHtcbiAgICAgICAgICAgIHZhciBhID0gdFtuXTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEpIHJldHVybiBhLmV4cG9ydHM7XG4gICAgICAgICAgICB2YXIgciA9IHRbbl0gPSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZVtuXShyLCByLmV4cG9ydHMsIGkpLCByLmV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUsIHQgPSBuO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gdm9pZCAwLCBpKDcxNDkpLCBpKDMxOTQpLCBpKDkzMDIpLCBpKDQwMTMpLCBpKDM4NTEpLCBpKDIxOSksIGkoMjA3KSwgXG4gICAgICAgICAgICBpKDUyOTYpO1xuICAgICAgICAgICAgdmFyIGEgPSAoKGUgPSBpKDIzOTQpKSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgIH0pLmRlZmF1bHQ7XG4gICAgICAgICAgICB0LmRlZmF1bHQgPSBhO1xuICAgICAgICB9KCksIG47XG4gICAgfSgpO1xufSkpOyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYmlnaW50OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYmlnaW50JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YToge307XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJyksXG4gICAgICAgICAge2V4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICB2YXIgY2hlY2tlclJlc3VsdCA9IGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdC5kYXRhICYmIGhhcyhjaGVja2VyUmVzdWx0LmRhdGEsICdleHBlY3RlZFR5cGUnKSkge1xuICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChjaGVja2VyUmVzdWx0LmRhdGEuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4cGVjdGVkVHlwZXNNZXNzYWdlID0gKGV4cGVjdGVkVHlwZXMubGVuZ3RoID4gMCkgPyAnLCBleHBlY3RlZCBvbmUgb2YgdHlwZSBbJyArIGV4cGVjdGVkVHlwZXMuam9pbignLCAnKSArICddJzogJyc7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgJyArIGV4cGVjdGVkVHlwZXNNZXNzYWdlICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGUgKyAnYC4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKGhhcyhzaGFwZVR5cGVzLCBrZXkpICYmIHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBCYXNlZCBvbiBLZW5kbyBVSSBDb3JlIGV4cHJlc3Npb24gY29kZSA8aHR0cHM6Ly9naXRodWIuY29tL3RlbGVyaWsva2VuZG8tdWktY29yZSNsaWNlbnNlLWluZm9ybWF0aW9uPlxuICovXG4ndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gQ2FjaGUobWF4U2l6ZSkge1xuICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZVxuICB0aGlzLmNsZWFyKClcbn1cbkNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fc2l6ZSA9IDBcbiAgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxufVxuQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trZXldXG59XG5DYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fc2l6ZSA+PSB0aGlzLl9tYXhTaXplICYmIHRoaXMuY2xlYXIoKVxuICBpZiAoIShrZXkgaW4gdGhpcy5fdmFsdWVzKSkgdGhpcy5fc2l6ZSsrXG5cbiAgcmV0dXJuICh0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlKVxufVxuXG52YXIgU1BMSVRfUkVHRVggPSAvW14uXlxcXV5bXSt8KD89XFxbXFxdfFxcLlxcLikvZyxcbiAgRElHSVRfUkVHRVggPSAvXlxcZCskLyxcbiAgTEVBRF9ESUdJVF9SRUdFWCA9IC9eXFxkLyxcbiAgU1BFQ19DSEFSX1JFR0VYID0gL1t+YCEjJCVcXF4mKis9XFwtXFxbXFxdXFxcXCc7LC97fXxcXFxcXCI6PD5cXD9dL2csXG4gIENMRUFOX1FVT1RFU19SRUdFWCA9IC9eXFxzKihbJ1wiXT8pKC4qPykoXFwxKVxccyokLyxcbiAgTUFYX0NBQ0hFX1NJWkUgPSA1MTJcblxudmFyIHBhdGhDYWNoZSA9IG5ldyBDYWNoZShNQVhfQ0FDSEVfU0laRSksXG4gIHNldENhY2hlID0gbmV3IENhY2hlKE1BWF9DQUNIRV9TSVpFKSxcbiAgZ2V0Q2FjaGUgPSBuZXcgQ2FjaGUoTUFYX0NBQ0hFX1NJWkUpXG5cbnZhciBjb25maWdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlOiBDYWNoZSxcblxuICBzcGxpdDogc3BsaXQsXG5cbiAgbm9ybWFsaXplUGF0aDogbm9ybWFsaXplUGF0aCxcblxuICBzZXR0ZXI6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIHBhcnRzID0gbm9ybWFsaXplUGF0aChwYXRoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNldENhY2hlLmdldChwYXRoKSB8fFxuICAgICAgc2V0Q2FjaGUuc2V0KHBhdGgsIGZ1bmN0aW9uIHNldHRlcihvYmosIHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDBcbiAgICAgICAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICB2YXIgZGF0YSA9IG9ialxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2luZGV4XVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcnQgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICBwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgICAgICBwYXJ0ID09PSAncHJvdG90eXBlJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBkYXRhW3BhcnRzW2luZGV4KytdXVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbcGFydHNbaW5kZXhdXSA9IHZhbHVlXG4gICAgICB9KVxuICAgIClcbiAgfSxcblxuICBnZXR0ZXI6IGZ1bmN0aW9uIChwYXRoLCBzYWZlKSB7XG4gICAgdmFyIHBhcnRzID0gbm9ybWFsaXplUGF0aChwYXRoKVxuICAgIHJldHVybiAoXG4gICAgICBnZXRDYWNoZS5nZXQocGF0aCkgfHxcbiAgICAgIGdldENhY2hlLnNldChwYXRoLCBmdW5jdGlvbiBnZXR0ZXIoZGF0YSkge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsIHx8ICFzYWZlKSBkYXRhID0gZGF0YVtwYXJ0c1tpbmRleCsrXV1cbiAgICAgICAgICBlbHNlIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9KVxuICAgIClcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChwYXRoLCBwYXJ0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwYXRoICtcbiAgICAgICAgKGlzUXVvdGVkKHBhcnQpIHx8IERJR0lUX1JFR0VYLnRlc3QocGFydClcbiAgICAgICAgICA/ICdbJyArIHBhcnQgKyAnXSdcbiAgICAgICAgICA6IChwYXRoID8gJy4nIDogJycpICsgcGFydClcbiAgICAgIClcbiAgICB9LCAnJylcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbiAocGF0aCwgY2IsIHRoaXNBcmcpIHtcbiAgICBmb3JFYWNoKEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogc3BsaXQocGF0aCksIGNiLCB0aGlzQXJnKVxuICB9LFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIChcbiAgICBwYXRoQ2FjaGUuZ2V0KHBhdGgpIHx8XG4gICAgcGF0aENhY2hlLnNldChcbiAgICAgIHBhdGgsXG4gICAgICBzcGxpdChwYXRoKS5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQucmVwbGFjZShDTEVBTl9RVU9URVNfUkVHRVgsICckMicpXG4gICAgICB9KVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzcGxpdChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hdGNoKFNQTElUX1JFR0VYKSB8fCBbJyddXG59XG5cbmZ1bmN0aW9uIGZvckVhY2gocGFydHMsIGl0ZXIsIHRoaXNBcmcpIHtcbiAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgICBwYXJ0LFxuICAgIGlkeCxcbiAgICBpc0FycmF5LFxuICAgIGlzQnJhY2tldFxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIHBhcnQgPSBwYXJ0c1tpZHhdXG5cbiAgICBpZiAocGFydCkge1xuICAgICAgaWYgKHNob3VsZEJlUXVvdGVkKHBhcnQpKSB7XG4gICAgICAgIHBhcnQgPSAnXCInICsgcGFydCArICdcIidcbiAgICAgIH1cblxuICAgICAgaXNCcmFja2V0ID0gaXNRdW90ZWQocGFydClcbiAgICAgIGlzQXJyYXkgPSAhaXNCcmFja2V0ICYmIC9eXFxkKyQvLnRlc3QocGFydClcblxuICAgICAgaXRlci5jYWxsKHRoaXNBcmcsIHBhcnQsIGlzQnJhY2tldCwgaXNBcnJheSwgaWR4LCBwYXJ0cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNRdW90ZWQoc3RyKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyICYmIFtcIidcIiwgJ1wiJ10uaW5kZXhPZihzdHIuY2hhckF0KDApKSAhPT0gLTFcbiAgKVxufVxuXG5mdW5jdGlvbiBoYXNMZWFkaW5nTnVtYmVyKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQubWF0Y2goTEVBRF9ESUdJVF9SRUdFWCkgJiYgIXBhcnQubWF0Y2goRElHSVRfUkVHRVgpXG59XG5cbmZ1bmN0aW9uIGhhc1NwZWNpYWxDaGFycyhwYXJ0KSB7XG4gIHJldHVybiBTUEVDX0NIQVJfUkVHRVgudGVzdChwYXJ0KVxufVxuXG5mdW5jdGlvbiBzaG91bGRCZVF1b3RlZChwYXJ0KSB7XG4gIHJldHVybiAhaXNRdW90ZWQocGFydCkgJiYgKGhhc0xlYWRpbmdOdW1iZXIocGFydCkgfHwgaGFzU3BlY2lhbENoYXJzKHBhcnQpKVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcblxudmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4ID0ganN4O1xuZXhwb3J0cy5qc3hzID0ganN4cztcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiY29uc3QgcmVXb3JkcyA9IC9bQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0/W2EtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdKyg/Olsn4oCZXSg/OmR8bGx8bXxyZXxzfHR8dmUpKT8oPz1bXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMF18W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdfCQpfCg/OltBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXXxbXlxcdWQ4MDAtXFx1ZGZmZlxceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXGQrXFx1MjcwMC1cXHUyN2JmYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKSsoPzpbJ+KAmV0oPzpEfExMfE18UkV8U3xUfFZFKSk/KD89W1xceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBdfFtBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXSg/OlthLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmXXxbXlxcdWQ4MDAtXFx1ZGZmZlxceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXGQrXFx1MjcwMC1cXHUyN2JmYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKXwkKXxbQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0/KD86W2EtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdfFteXFx1ZDgwMC1cXHVkZmZmXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcZCtcXHUyNzAwLVxcdTI3YmZhLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0pKyg/Olsn4oCZXSg/OmR8bGx8bXxyZXxzfHR8dmUpKT98W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKyg/Olsn4oCZXSg/OkR8TEx8TXxSRXxTfFR8VkUpKT98XFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcZFRIKSg/PVxcYnxbYS16X10pfFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXGR0aCkoPz1cXGJ8W0EtWl9dKXxcXGQrfCg/OltcXHUyNzAwLVxcdTI3YmZdfCg/OlxcdWQ4M2NbXFx1ZGRlNi1cXHVkZGZmXSl7Mn18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSlbXFx1ZmUwZVxcdWZlMGZdPyg/OltcXHUwMzAwLVxcdTAzNmZcXHVmZTIwLVxcdWZlMmZcXHUyMGQwLVxcdTIwZmZdfFxcdWQ4M2NbXFx1ZGZmYi1cXHVkZmZmXSk/KD86XFx1MjAwZCg/OlteXFx1ZDgwMC1cXHVkZmZmXXwoPzpcXHVkODNjW1xcdWRkZTYtXFx1ZGRmZl0pezJ9fFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pW1xcdWZlMGVcXHVmZTBmXT8oPzpbXFx1MDMwMC1cXHUwMzZmXFx1ZmUyMC1cXHVmZTJmXFx1MjBkMC1cXHUyMGZmXXxcXHVkODNjW1xcdWRmZmItXFx1ZGZmZl0pPykqL2dcblxuY29uc3Qgd29yZHMgPSAoc3RyKSA9PiBzdHIubWF0Y2gocmVXb3JkcykgfHwgW11cblxuY29uc3QgdXBwZXJGaXJzdCA9IChzdHIpID0+IHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG5cbmNvbnN0IGpvaW4gPSAoc3RyLCBkKSA9PiB3b3JkcyhzdHIpLmpvaW4oZCkudG9Mb3dlckNhc2UoKVxuXG5jb25zdCBjYW1lbENhc2UgPSAoc3RyKSA9PlxuICB3b3JkcyhzdHIpLnJlZHVjZShcbiAgICAoYWNjLCBuZXh0KSA9PlxuICAgICAgYCR7YWNjfSR7XG4gICAgICAgICFhY2NcbiAgICAgICAgICA/IG5leHQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgIDogbmV4dFswXS50b1VwcGVyQ2FzZSgpICsgbmV4dC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpXG4gICAgICB9YCxcbiAgICAnJyxcbiAgKVxuXG5jb25zdCBwYXNjYWxDYXNlID0gKHN0cikgPT4gdXBwZXJGaXJzdChjYW1lbENhc2Uoc3RyKSlcblxuY29uc3Qgc25ha2VDYXNlID0gKHN0cikgPT4gam9pbihzdHIsICdfJylcblxuY29uc3Qga2ViYWJDYXNlID0gKHN0cikgPT4gam9pbihzdHIsICctJylcblxuY29uc3Qgc2VudGVuY2VDYXNlID0gKHN0cikgPT4gdXBwZXJGaXJzdChqb2luKHN0ciwgJyAnKSlcblxuY29uc3QgdGl0bGVDYXNlID0gKHN0cikgPT4gd29yZHMoc3RyKS5tYXAodXBwZXJGaXJzdCkuam9pbignICcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3b3JkcyxcbiAgdXBwZXJGaXJzdCxcbiAgY2FtZWxDYXNlLFxuICBwYXNjYWxDYXNlLFxuICBzbmFrZUNhc2UsXG4gIGtlYmFiQ2FzZSxcbiAgc2VudGVuY2VDYXNlLFxuICB0aXRsZUNhc2UsXG59XG4iLCJcbi8qKlxuICogVG9wb2xvZ2ljYWwgc29ydGluZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGVkZ2VzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlZGdlcykge1xuICByZXR1cm4gdG9wb3NvcnQodW5pcXVlTm9kZXMoZWRnZXMpLCBlZGdlcylcbn1cblxubW9kdWxlLmV4cG9ydHMuYXJyYXkgPSB0b3Bvc29ydFxuXG5mdW5jdGlvbiB0b3Bvc29ydChub2RlcywgZWRnZXMpIHtcbiAgdmFyIGN1cnNvciA9IG5vZGVzLmxlbmd0aFxuICAgICwgc29ydGVkID0gbmV3IEFycmF5KGN1cnNvcilcbiAgICAsIHZpc2l0ZWQgPSB7fVxuICAgICwgaSA9IGN1cnNvclxuICAgIC8vIEJldHRlciBkYXRhIHN0cnVjdHVyZXMgbWFrZSBhbGdvcml0aG0gbXVjaCBmYXN0ZXIuXG4gICAgLCBvdXRnb2luZ0VkZ2VzID0gbWFrZU91dGdvaW5nRWRnZXMoZWRnZXMpXG4gICAgLCBub2Rlc0hhc2ggPSBtYWtlTm9kZXNIYXNoKG5vZGVzKVxuXG4gIC8vIGNoZWNrIGZvciB1bmtub3duIG5vZGVzXG4gIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgIGlmICghbm9kZXNIYXNoLmhhcyhlZGdlWzBdKSB8fCAhbm9kZXNIYXNoLmhhcyhlZGdlWzFdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUuIFRoZXJlIGlzIGFuIHVua25vd24gbm9kZSBpbiB0aGUgc3VwcGxpZWQgZWRnZXMuJylcbiAgICB9XG4gIH0pXG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICghdmlzaXRlZFtpXSkgdmlzaXQobm9kZXNbaV0sIGksIG5ldyBTZXQoKSlcbiAgfVxuXG4gIHJldHVybiBzb3J0ZWRcblxuICBmdW5jdGlvbiB2aXNpdChub2RlLCBpLCBwcmVkZWNlc3NvcnMpIHtcbiAgICBpZihwcmVkZWNlc3NvcnMuaGFzKG5vZGUpKSB7XG4gICAgICB2YXIgbm9kZVJlcFxuICAgICAgdHJ5IHtcbiAgICAgICAgbm9kZVJlcCA9IFwiLCBub2RlIHdhczpcIiArIEpTT04uc3RyaW5naWZ5KG5vZGUpXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbm9kZVJlcCA9IFwiXCJcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGljIGRlcGVuZGVuY3knICsgbm9kZVJlcClcbiAgICB9XG5cbiAgICBpZiAoIW5vZGVzSGFzaC5oYXMobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdW5rbm93biBub2RlLiBNYWtlIHN1cmUgdG8gcHJvdmlkZWQgYWxsIGludm9sdmVkIG5vZGVzLiBVbmtub3duIG5vZGU6ICcrSlNPTi5zdHJpbmdpZnkobm9kZSkpXG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWRbaV0pIHJldHVybjtcbiAgICB2aXNpdGVkW2ldID0gdHJ1ZVxuXG4gICAgdmFyIG91dGdvaW5nID0gb3V0Z29pbmdFZGdlcy5nZXQobm9kZSkgfHwgbmV3IFNldCgpXG4gICAgb3V0Z29pbmcgPSBBcnJheS5mcm9tKG91dGdvaW5nKVxuXG4gICAgaWYgKGkgPSBvdXRnb2luZy5sZW5ndGgpIHtcbiAgICAgIHByZWRlY2Vzc29ycy5hZGQobm9kZSlcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGNoaWxkID0gb3V0Z29pbmdbLS1pXVxuICAgICAgICB2aXNpdChjaGlsZCwgbm9kZXNIYXNoLmdldChjaGlsZCksIHByZWRlY2Vzc29ycylcbiAgICAgIH0gd2hpbGUgKGkpXG4gICAgICBwcmVkZWNlc3NvcnMuZGVsZXRlKG5vZGUpXG4gICAgfVxuXG4gICAgc29ydGVkWy0tY3Vyc29yXSA9IG5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmlxdWVOb2RlcyhhcnIpe1xuICB2YXIgcmVzID0gbmV3IFNldCgpXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGFycltpXVxuICAgIHJlcy5hZGQoZWRnZVswXSlcbiAgICByZXMuYWRkKGVkZ2VbMV0pXG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzKVxufVxuXG5mdW5jdGlvbiBtYWtlT3V0Z29pbmdFZGdlcyhhcnIpe1xuICB2YXIgZWRnZXMgPSBuZXcgTWFwKClcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlZGdlID0gYXJyW2ldXG4gICAgaWYgKCFlZGdlcy5oYXMoZWRnZVswXSkpIGVkZ2VzLnNldChlZGdlWzBdLCBuZXcgU2V0KCkpXG4gICAgaWYgKCFlZGdlcy5oYXMoZWRnZVsxXSkpIGVkZ2VzLnNldChlZGdlWzFdLCBuZXcgU2V0KCkpXG4gICAgZWRnZXMuZ2V0KGVkZ2VbMF0pLmFkZChlZGdlWzFdKVxuICB9XG4gIHJldHVybiBlZGdlc1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZXNIYXNoKGFycil7XG4gIHZhciByZXMgPSBuZXcgTWFwKClcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlcy5zZXQoYXJyW2ldLCBpKVxuICB9XG4gIHJldHVybiByZXNcbn1cbiIsImltcG9ydCB7IGdldHRlciwgZm9yRWFjaCwgc3BsaXQsIG5vcm1hbGl6ZVBhdGgsIGpvaW4gfSBmcm9tICdwcm9wZXJ0eS1leHByJztcbmltcG9ydCB7IGNhbWVsQ2FzZSwgc25ha2VDYXNlIH0gZnJvbSAndGlueS1jYXNlJztcbmltcG9ydCB0b3Bvc29ydCBmcm9tICd0b3Bvc29ydCc7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IGVycm9yVG9TdHJpbmcgPSBFcnJvci5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCByZWdFeHBUb1N0cmluZyA9IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBzeW1ib2xUb1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyA6ICgpID0+ICcnO1xuY29uc3QgU1lNQk9MX1JFR0VYUCA9IC9eU3ltYm9sXFwoKC4qKVxcKSguKikkLztcbmZ1bmN0aW9uIHByaW50TnVtYmVyKHZhbCkge1xuICBpZiAodmFsICE9ICt2YWwpIHJldHVybiAnTmFOJztcbiAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSB2YWwgPT09IDAgJiYgMSAvIHZhbCA8IDA7XG4gIHJldHVybiBpc05lZ2F0aXZlWmVybyA/ICctMCcgOiAnJyArIHZhbDtcbn1cbmZ1bmN0aW9uIHByaW50U2ltcGxlVmFsdWUodmFsLCBxdW90ZVN0cmluZ3MgPSBmYWxzZSkge1xuICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UpIHJldHVybiAnJyArIHZhbDtcbiAgY29uc3QgdHlwZU9mID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGVPZiA9PT0gJ251bWJlcicpIHJldHVybiBwcmludE51bWJlcih2YWwpO1xuICBpZiAodHlwZU9mID09PSAnc3RyaW5nJykgcmV0dXJuIHF1b3RlU3RyaW5ncyA/IGBcIiR7dmFsfVwiYCA6IHZhbDtcbiAgaWYgKHR5cGVPZiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuICdbRnVuY3Rpb24gJyArICh2YWwubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnXSc7XG4gIGlmICh0eXBlT2YgPT09ICdzeW1ib2wnKSByZXR1cm4gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWwpLnJlcGxhY2UoU1lNQk9MX1JFR0VYUCwgJ1N5bWJvbCgkMSknKTtcbiAgY29uc3QgdGFnID0gdG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbiAgaWYgKHRhZyA9PT0gJ0RhdGUnKSByZXR1cm4gaXNOYU4odmFsLmdldFRpbWUoKSkgPyAnJyArIHZhbCA6IHZhbC50b0lTT1N0cmluZyh2YWwpO1xuICBpZiAodGFnID09PSAnRXJyb3InIHx8IHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gJ1snICsgZXJyb3JUb1N0cmluZy5jYWxsKHZhbCkgKyAnXSc7XG4gIGlmICh0YWcgPT09ICdSZWdFeHAnKSByZXR1cm4gcmVnRXhwVG9TdHJpbmcuY2FsbCh2YWwpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHByaW50VmFsdWUodmFsdWUsIHF1b3RlU3RyaW5ncykge1xuICBsZXQgcmVzdWx0ID0gcHJpbnRTaW1wbGVWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKTtcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBwcmludFNpbXBsZVZhbHVlKHRoaXNba2V5XSwgcXVvdGVTdHJpbmdzKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSwgMik7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBbXSA6IFtdLmNvbmNhdCh2YWx1ZSk7XG59XG5cbmxldCBfU3ltYm9sJHRvU3RyaW5nVGFnO1xubGV0IHN0clJlZyA9IC9cXCRcXHtcXHMqKFxcdyspXFxzKlxcfS9nO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdGljIGZvcm1hdEVycm9yKG1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGNvbnN0IHBhdGggPSBwYXJhbXMubGFiZWwgfHwgcGFyYW1zLnBhdGggfHwgJ3RoaXMnO1xuICAgIGlmIChwYXRoICE9PSBwYXJhbXMucGF0aCkgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCB7XG4gICAgICBwYXRoXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZShzdHJSZWcsIChfLCBrZXkpID0+IHByaW50VmFsdWUocGFyYW1zW2tleV0pKTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBtZXNzYWdlKHBhcmFtcyk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgc3RhdGljIGlzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiBlcnIubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcic7XG4gIH1cbiAgY29uc3RydWN0b3IoZXJyb3JPckVycm9ycywgdmFsdWUsIGZpZWxkLCB0eXBlLCBkaXNhYmxlU3RhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyID0gdm9pZCAwO1xuICAgIHRoaXNbX1N5bWJvbCR0b1N0cmluZ1RhZ10gPSAnRXJyb3InO1xuICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBmaWVsZDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pbm5lciA9IFtdO1xuICAgIHRvQXJyYXkoZXJyb3JPckVycm9ycykuZm9yRWFjaChlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCguLi5lcnIuZXJyb3JzKTtcbiAgICAgICAgY29uc3QgaW5uZXJFcnJvcnMgPSBlcnIuaW5uZXIubGVuZ3RoID8gZXJyLmlubmVyIDogW2Vycl07XG4gICAgICAgIHRoaXMuaW5uZXIucHVzaCguLi5pbm5lckVycm9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5lcnJvcnMubGVuZ3RoID4gMSA/IGAke3RoaXMuZXJyb3JzLmxlbmd0aH0gZXJyb3JzIG9jY3VycmVkYCA6IHRoaXMuZXJyb3JzWzBdO1xuICAgIGlmICghZGlzYWJsZVN0YWNrICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBWYWxpZGF0aW9uRXJyb3IpO1xuICB9XG59XG5cbmxldCBtaXhlZCA9IHtcbiAgZGVmYXVsdDogJyR7cGF0aH0gaXMgaW52YWxpZCcsXG4gIHJlcXVpcmVkOiAnJHtwYXRofSBpcyBhIHJlcXVpcmVkIGZpZWxkJyxcbiAgZGVmaW5lZDogJyR7cGF0aH0gbXVzdCBiZSBkZWZpbmVkJyxcbiAgbm90TnVsbDogJyR7cGF0aH0gY2Fubm90IGJlIG51bGwnLFxuICBvbmVPZjogJyR7cGF0aH0gbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICR7dmFsdWVzfScsXG4gIG5vdE9uZU9mOiAnJHtwYXRofSBtdXN0IG5vdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICR7dmFsdWVzfScsXG4gIG5vdFR5cGU6ICh7XG4gICAgcGF0aCxcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIG9yaWdpbmFsVmFsdWVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNhc3RNc2cgPSBvcmlnaW5hbFZhbHVlICE9IG51bGwgJiYgb3JpZ2luYWxWYWx1ZSAhPT0gdmFsdWUgPyBgIChjYXN0IGZyb20gdGhlIHZhbHVlIFxcYCR7cHJpbnRWYWx1ZShvcmlnaW5hbFZhbHVlLCB0cnVlKX1cXGApLmAgOiAnLic7XG4gICAgcmV0dXJuIHR5cGUgIT09ICdtaXhlZCcgPyBgJHtwYXRofSBtdXN0IGJlIGEgXFxgJHt0eXBlfVxcYCB0eXBlLCBgICsgYGJ1dCB0aGUgZmluYWwgdmFsdWUgd2FzOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGAgKyBjYXN0TXNnIDogYCR7cGF0aH0gbXVzdCBtYXRjaCB0aGUgY29uZmlndXJlZCB0eXBlLiBgICsgYFRoZSB2YWxpZGF0ZWQgdmFsdWUgd2FzOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGAgKyBjYXN0TXNnO1xuICB9XG59O1xubGV0IHN0cmluZyA9IHtcbiAgbGVuZ3RoOiAnJHtwYXRofSBtdXN0IGJlIGV4YWN0bHkgJHtsZW5ndGh9IGNoYXJhY3RlcnMnLFxuICBtaW46ICcke3BhdGh9IG11c3QgYmUgYXQgbGVhc3QgJHttaW59IGNoYXJhY3RlcnMnLFxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgYXQgbW9zdCAke21heH0gY2hhcmFjdGVycycsXG4gIG1hdGNoZXM6ICcke3BhdGh9IG11c3QgbWF0Y2ggdGhlIGZvbGxvd2luZzogXCIke3JlZ2V4fVwiJyxcbiAgZW1haWw6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBlbWFpbCcsXG4gIHVybDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIFVSTCcsXG4gIHV1aWQ6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBVVUlEJyxcbiAgdHJpbTogJyR7cGF0aH0gbXVzdCBiZSBhIHRyaW1tZWQgc3RyaW5nJyxcbiAgbG93ZXJjYXNlOiAnJHtwYXRofSBtdXN0IGJlIGEgbG93ZXJjYXNlIHN0cmluZycsXG4gIHVwcGVyY2FzZTogJyR7cGF0aH0gbXVzdCBiZSBhIHVwcGVyIGNhc2Ugc3RyaW5nJ1xufTtcbmxldCBudW1iZXIgPSB7XG4gIG1pbjogJyR7cGF0aH0gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59JyxcbiAgbWF4OiAnJHtwYXRofSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH0nLFxuICBsZXNzVGhhbjogJyR7cGF0aH0gbXVzdCBiZSBsZXNzIHRoYW4gJHtsZXNzfScsXG4gIG1vcmVUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAke21vcmV9JyxcbiAgcG9zaXRpdmU6ICcke3BhdGh9IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICBuZWdhdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gIGludGVnZXI6ICcke3BhdGh9IG11c3QgYmUgYW4gaW50ZWdlcidcbn07XG5sZXQgZGF0ZSA9IHtcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGJlIGxhdGVyIHRoYW4gJHttaW59JyxcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGJlIGF0IGVhcmxpZXIgdGhhbiAke21heH0nXG59O1xubGV0IGJvb2xlYW4gPSB7XG4gIGlzVmFsdWU6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgJHt2YWx1ZX0nXG59O1xubGV0IG9iamVjdCA9IHtcbiAgbm9Vbmtub3duOiAnJHtwYXRofSBmaWVsZCBoYXMgdW5zcGVjaWZpZWQga2V5czogJHt1bmtub3dufSdcbn07XG5sZXQgYXJyYXkgPSB7XG4gIG1pbjogJyR7cGF0aH0gZmllbGQgbXVzdCBoYXZlIGF0IGxlYXN0ICR7bWlufSBpdGVtcycsXG4gIG1heDogJyR7cGF0aH0gZmllbGQgbXVzdCBoYXZlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH0gaXRlbXMnLFxuICBsZW5ndGg6ICcke3BhdGh9IG11c3QgaGF2ZSAke2xlbmd0aH0gaXRlbXMnXG59O1xubGV0IHR1cGxlID0ge1xuICBub3RUeXBlOiBwYXJhbXMgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZSxcbiAgICAgIHNwZWNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGVMZW4gPSBzcGVjLnR5cGVzLmxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCB0eXBlTGVuKSByZXR1cm4gYCR7cGF0aH0gdHVwbGUgdmFsdWUgaGFzIHRvbyBmZXcgaXRlbXMsIGV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7dHlwZUxlbn0gYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gZm9yIHZhbHVlOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGA7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gdHlwZUxlbikgcmV0dXJuIGAke3BhdGh9IHR1cGxlIHZhbHVlIGhhcyB0b28gbWFueSBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvci5mb3JtYXRFcnJvcihtaXhlZC5ub3RUeXBlLCBwYXJhbXMpO1xuICB9XG59O1xudmFyIGxvY2FsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBtaXhlZCxcbiAgc3RyaW5nLFxuICBudW1iZXIsXG4gIGRhdGUsXG4gIG9iamVjdCxcbiAgYXJyYXksXG4gIGJvb2xlYW4sXG4gIHR1cGxlXG59KTtcblxuY29uc3QgaXNTY2hlbWEgPSBvYmogPT4gb2JqICYmIG9iai5fX2lzWXVwU2NoZW1hX187XG5cbmNsYXNzIENvbmRpdGlvbiB7XG4gIHN0YXRpYyBmcm9tT3B0aW9ucyhyZWZzLCBjb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZy50aGVuICYmICFjb25maWcub3RoZXJ3aXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlaXRoZXIgYHRoZW46YCBvciBgb3RoZXJ3aXNlOmAgaXMgcmVxdWlyZWQgZm9yIGB3aGVuKClgIGNvbmRpdGlvbnMnKTtcbiAgICBsZXQge1xuICAgICAgaXMsXG4gICAgICB0aGVuLFxuICAgICAgb3RoZXJ3aXNlXG4gICAgfSA9IGNvbmZpZztcbiAgICBsZXQgY2hlY2sgPSB0eXBlb2YgaXMgPT09ICdmdW5jdGlvbicgPyBpcyA6ICguLi52YWx1ZXMpID0+IHZhbHVlcy5ldmVyeSh2YWx1ZSA9PiB2YWx1ZSA9PT0gaXMpO1xuICAgIHJldHVybiBuZXcgQ29uZGl0aW9uKHJlZnMsICh2YWx1ZXMsIHNjaGVtYSkgPT4ge1xuICAgICAgdmFyIF9icmFuY2g7XG4gICAgICBsZXQgYnJhbmNoID0gY2hlY2soLi4udmFsdWVzKSA/IHRoZW4gOiBvdGhlcndpc2U7XG4gICAgICByZXR1cm4gKF9icmFuY2ggPSBicmFuY2ggPT0gbnVsbCA/IHZvaWQgMCA6IGJyYW5jaChzY2hlbWEpKSAhPSBudWxsID8gX2JyYW5jaCA6IHNjaGVtYTtcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihyZWZzLCBidWlsZGVyKSB7XG4gICAgdGhpcy5mbiA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZnMgPSByZWZzO1xuICAgIHRoaXMucmVmcyA9IHJlZnM7XG4gICAgdGhpcy5mbiA9IGJ1aWxkZXI7XG4gIH1cbiAgcmVzb2x2ZShiYXNlLCBvcHRpb25zKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMucmVmcy5tYXAocmVmID0+XG4gICAgLy8gVE9ETzogPyBvcGVyYXRvciBoZXJlP1xuICAgIHJlZi5nZXRWYWx1ZShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnZhbHVlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmVudCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0KSk7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMuZm4odmFsdWVzLCBiYXNlLCBvcHRpb25zKTtcbiAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQgfHxcbiAgICAvLyBAdHMtaWdub3JlIHRoaXMgY2FuIGJlIGJhc2VcbiAgICBzY2hlbWEgPT09IGJhc2UpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmRpdGlvbnMgbXVzdCByZXR1cm4gYSBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICB9XG59XG5cbmNvbnN0IHByZWZpeGVzID0ge1xuICBjb250ZXh0OiAnJCcsXG4gIHZhbHVlOiAnLidcbn07XG5mdW5jdGlvbiBjcmVhdGUkOShrZXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoa2V5LCBvcHRpb25zKTtcbn1cbmNsYXNzIFJlZmVyZW5jZSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1ZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNTaWJsaW5nID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmdldHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZiBtdXN0IGJlIGEgc3RyaW5nLCBnb3Q6ICcgKyBrZXkpO1xuICAgIHRoaXMua2V5ID0ga2V5LnRyaW0oKTtcbiAgICBpZiAoa2V5ID09PSAnJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVmIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgdGhpcy5pc0NvbnRleHQgPSB0aGlzLmtleVswXSA9PT0gcHJlZml4ZXMuY29udGV4dDtcbiAgICB0aGlzLmlzVmFsdWUgPSB0aGlzLmtleVswXSA9PT0gcHJlZml4ZXMudmFsdWU7XG4gICAgdGhpcy5pc1NpYmxpbmcgPSAhdGhpcy5pc0NvbnRleHQgJiYgIXRoaXMuaXNWYWx1ZTtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5pc0NvbnRleHQgPyBwcmVmaXhlcy5jb250ZXh0IDogdGhpcy5pc1ZhbHVlID8gcHJlZml4ZXMudmFsdWUgOiAnJztcbiAgICB0aGlzLnBhdGggPSB0aGlzLmtleS5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLmdldHRlciA9IHRoaXMucGF0aCAmJiBnZXR0ZXIodGhpcy5wYXRoLCB0cnVlKTtcbiAgICB0aGlzLm1hcCA9IG9wdGlvbnMubWFwO1xuICB9XG4gIGdldFZhbHVlKHZhbHVlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pc0NvbnRleHQgPyBjb250ZXh0IDogdGhpcy5pc1ZhbHVlID8gdmFsdWUgOiBwYXJlbnQ7XG4gICAgaWYgKHRoaXMuZ2V0dGVyKSByZXN1bHQgPSB0aGlzLmdldHRlcihyZXN1bHQgfHwge30pO1xuICAgIGlmICh0aGlzLm1hcCkgcmVzdWx0ID0gdGhpcy5tYXAocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmNvbnRleHRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLnBhcmVudFxuICAgKi9cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKHZhbHVlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmVudCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0KTtcbiAgfVxuICByZXNvbHZlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2NyaWJlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAncmVmJyxcbiAgICAgIGtleTogdGhpcy5rZXlcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgUmVmKCR7dGhpcy5rZXl9KWA7XG4gIH1cbiAgc3RhdGljIGlzUmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLl9faXNZdXBSZWY7XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZVxuUmVmZXJlbmNlLnByb3RvdHlwZS5fX2lzWXVwUmVmID0gdHJ1ZTtcblxuY29uc3QgaXNBYnNlbnQgPSB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0aW9uKGNvbmZpZykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh7XG4gICAgdmFsdWUsXG4gICAgcGF0aCA9ICcnLFxuICAgIG9wdGlvbnMsXG4gICAgb3JpZ2luYWxWYWx1ZSxcbiAgICBzY2hlbWFcbiAgfSwgcGFuaWMsIG5leHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgdGVzdCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBza2lwQWJzZW50XG4gICAgfSA9IGNvbmZpZztcbiAgICBsZXQge1xuICAgICAgcGFyZW50LFxuICAgICAgY29udGV4dCxcbiAgICAgIGFib3J0RWFybHkgPSBzY2hlbWEuc3BlYy5hYm9ydEVhcmx5LFxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2UgPSBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIHJlc29sdmUoaXRlbSkge1xuICAgICAgcmV0dXJuIFJlZmVyZW5jZS5pc1JlZihpdGVtKSA/IGl0ZW0uZ2V0VmFsdWUodmFsdWUsIHBhcmVudCwgY29udGV4dCkgOiBpdGVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihvdmVycmlkZXMgPSB7fSkge1xuICAgICAgdmFyIF9vdmVycmlkZXMkZGlzYWJsZVN0YTtcbiAgICAgIGNvbnN0IG5leHRQYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIGxhYmVsOiBzY2hlbWEuc3BlYy5sYWJlbCxcbiAgICAgICAgcGF0aDogb3ZlcnJpZGVzLnBhdGggfHwgcGF0aCxcbiAgICAgICAgc3BlYzogc2NoZW1hLnNwZWNcbiAgICAgIH0sIHBhcmFtcywgb3ZlcnJpZGVzLnBhcmFtcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuZXh0UGFyYW1zKSkgbmV4dFBhcmFtc1trZXldID0gcmVzb2x2ZShuZXh0UGFyYW1zW2tleV0pO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKFZhbGlkYXRpb25FcnJvci5mb3JtYXRFcnJvcihvdmVycmlkZXMubWVzc2FnZSB8fCBtZXNzYWdlLCBuZXh0UGFyYW1zKSwgdmFsdWUsIG5leHRQYXJhbXMucGF0aCwgb3ZlcnJpZGVzLnR5cGUgfHwgbmFtZSwgKF9vdmVycmlkZXMkZGlzYWJsZVN0YSA9IG92ZXJyaWRlcy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vdmVycmlkZXMkZGlzYWJsZVN0YSA6IGRpc2FibGVTdGFja1RyYWNlKTtcbiAgICAgIGVycm9yLnBhcmFtcyA9IG5leHRQYXJhbXM7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWQgPSBhYm9ydEVhcmx5ID8gcGFuaWMgOiBuZXh0O1xuICAgIGxldCBjdHggPSB7XG4gICAgICBwYXRoLFxuICAgICAgcGFyZW50LFxuICAgICAgdHlwZTogbmFtZSxcbiAgICAgIGZyb206IG9wdGlvbnMuZnJvbSxcbiAgICAgIGNyZWF0ZUVycm9yLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgc2NoZW1hXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVSZXN1bHQgPSB2YWxpZE9yRXJyb3IgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKHZhbGlkT3JFcnJvcikpIGludmFsaWQodmFsaWRPckVycm9yKTtlbHNlIGlmICghdmFsaWRPckVycm9yKSBpbnZhbGlkKGNyZWF0ZUVycm9yKCkpO2Vsc2UgbmV4dChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSBpbnZhbGlkKGVycik7ZWxzZSBwYW5pYyhlcnIpO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IHNraXBBYnNlbnQgJiYgaXNBYnNlbnQodmFsdWUpO1xuICAgIGlmIChzaG91bGRTa2lwKSB7XG4gICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHRydWUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3Jlc3VsdDtcbiAgICAgIHJlc3VsdCA9IHRlc3QuY2FsbChjdHgsIHZhbHVlLCBjdHgpO1xuICAgICAgaWYgKHR5cGVvZiAoKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0LnRoZW4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN5bmMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRpb24gdGVzdCBvZiB0eXBlOiBcIiR7Y3R4LnR5cGV9XCIgcmV0dXJuZWQgYSBQcm9taXNlIGR1cmluZyBhIHN5bmNocm9ub3VzIHZhbGlkYXRlLiBgICsgYFRoaXMgdGVzdCB3aWxsIGZpbmlzaCBhZnRlciB0aGUgdmFsaWRhdGUgY2FsbCBoYXMgcmV0dXJuZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihoYW5kbGVSZXN1bHQsIGhhbmRsZUVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICB9XG4gIHZhbGlkYXRlLk9QVElPTlMgPSBjb25maWc7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW4oc2NoZW1hLCBwYXRoLCB2YWx1ZSwgY29udGV4dCA9IHZhbHVlKSB7XG4gIGxldCBwYXJlbnQsIGxhc3RQYXJ0LCBsYXN0UGFydERlYnVnO1xuXG4gIC8vIHJvb3QgcGF0aDogJydcbiAgaWYgKCFwYXRoKSByZXR1cm4ge1xuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoOiBwYXRoLFxuICAgIHNjaGVtYVxuICB9O1xuICBmb3JFYWNoKHBhdGgsIChfcGFydCwgaXNCcmFja2V0LCBpc0FycmF5KSA9PiB7XG4gICAgbGV0IHBhcnQgPSBpc0JyYWNrZXQgPyBfcGFydC5zbGljZSgxLCBfcGFydC5sZW5ndGggLSAxKSA6IF9wYXJ0O1xuICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBwYXJlbnQsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIGxldCBpc1R1cGxlID0gc2NoZW1hLnR5cGUgPT09ICd0dXBsZSc7XG4gICAgbGV0IGlkeCA9IGlzQXJyYXkgPyBwYXJzZUludChwYXJ0LCAxMCkgOiAwO1xuICAgIGlmIChzY2hlbWEuaW5uZXJUeXBlIHx8IGlzVHVwbGUpIHtcbiAgICAgIGlmIChpc1R1cGxlICYmICFpc0FycmF5KSB0aHJvdyBuZXcgRXJyb3IoYFl1cC5yZWFjaCBjYW5ub3QgaW1wbGljaXRseSBpbmRleCBpbnRvIGEgdHVwbGUgdHlwZS4gdGhlIHBhdGggcGFydCBcIiR7bGFzdFBhcnREZWJ1Z31cIiBtdXN0IGNvbnRhaW4gYW4gaW5kZXggdG8gdGhlIHR1cGxlIGVsZW1lbnQsIGUuZy4gXCIke2xhc3RQYXJ0RGVidWd9WzBdXCJgKTtcbiAgICAgIGlmICh2YWx1ZSAmJiBpZHggPj0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWXVwLnJlYWNoIGNhbm5vdCByZXNvbHZlIGFuIGFycmF5IGl0ZW0gYXQgaW5kZXg6ICR7X3BhcnR9LCBpbiB0aGUgcGF0aDogJHtwYXRofS4gYCArIGBiZWNhdXNlIHRoZXJlIGlzIG5vIHZhbHVlIGF0IHRoYXQgaW5kZXguIGApO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW2lkeF07XG4gICAgICBzY2hlbWEgPSBpc1R1cGxlID8gc2NoZW1hLnNwZWMudHlwZXNbaWR4XSA6IHNjaGVtYS5pbm5lclR5cGU7XG4gICAgfVxuXG4gICAgLy8gc29tZXRpbWVzIHRoZSBhcnJheSBpbmRleCBwYXJ0IG9mIGEgcGF0aCBkb2Vzbid0IGV4aXN0OiBcIm5lc3RlZC5hcnIuY2hpbGRcIlxuICAgIC8vIGluIHRoZXNlIGNhc2VzIHRoZSBjdXJyZW50IHBhcnQgaXMgdGhlIG5leHQgc2NoZW1hIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkXG4gICAgLy8gaW4gdGhpcyBpdGVyYXRpb24uIEZvciBjYXNlcyB3aGVyZSB0aGUgaW5kZXggc2lnbmF0dXJlIGlzIGluY2x1ZGVkIHRoaXNcbiAgICAvLyBjaGVjayB3aWxsIGZhaWwgYW5kIHdlJ2xsIGhhbmRsZSB0aGUgYGNoaWxkYCBwYXJ0IG9uIHRoZSBuZXh0IGl0ZXJhdGlvbiBsaWtlIG5vcm1hbFxuICAgIGlmICghaXNBcnJheSkge1xuICAgICAgaWYgKCFzY2hlbWEuZmllbGRzIHx8ICFzY2hlbWEuZmllbGRzW3BhcnRdKSB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzY2hlbWEgZG9lcyBub3QgY29udGFpbiB0aGUgcGF0aDogJHtwYXRofS4gYCArIGAoZmFpbGVkIGF0OiAke2xhc3RQYXJ0RGVidWd9IHdoaWNoIGlzIGEgdHlwZTogXCIke3NjaGVtYS50eXBlfVwiKWApO1xuICAgICAgcGFyZW50ID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW3BhcnRdO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmZpZWxkc1twYXJ0XTtcbiAgICB9XG4gICAgbGFzdFBhcnQgPSBwYXJ0O1xuICAgIGxhc3RQYXJ0RGVidWcgPSBpc0JyYWNrZXQgPyAnWycgKyBfcGFydCArICddJyA6ICcuJyArIF9wYXJ0O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWEsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGg6IGxhc3RQYXJ0XG4gIH07XG59XG5mdW5jdGlvbiByZWFjaChvYmosIHBhdGgsIHZhbHVlLCBjb250ZXh0KSB7XG4gIHJldHVybiBnZXRJbihvYmosIHBhdGgsIHZhbHVlLCBjb250ZXh0KS5zY2hlbWE7XG59XG5cbmNsYXNzIFJlZmVyZW5jZVNldCBleHRlbmRzIFNldCB7XG4gIGRlc2NyaWJlKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goUmVmZXJlbmNlLmlzUmVmKGl0ZW0pID8gaXRlbS5kZXNjcmliZSgpIDogaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgfVxuICByZXNvbHZlQWxsKHJlc29sdmUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHJlc29sdmUoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlU2V0KHRoaXMudmFsdWVzKCkpO1xuICB9XG4gIG1lcmdlKG5ld0l0ZW1zLCByZW1vdmVJdGVtcykge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV3SXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmFkZCh2YWx1ZSkpO1xuICAgIHJlbW92ZUl0ZW1zLmZvckVhY2godmFsdWUgPT4gbmV4dC5kZWxldGUodmFsdWUpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufVxuXG4vLyB0d2Vha2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0tlbGluMjAyNS9uYW5vY2xvbmUvYmxvYi8wYWJlYjc2MzViZGE5YjY4ZWYyMjc3MDkzZjc2ZGJlM2JmMzk0OGUxL3NyYy9pbmRleC5qc1xuZnVuY3Rpb24gY2xvbmUoc3JjLCBzZWVuID0gbmV3IE1hcCgpKSB7XG4gIGlmIChpc1NjaGVtYShzcmMpIHx8ICFzcmMgfHwgdHlwZW9mIHNyYyAhPT0gJ29iamVjdCcpIHJldHVybiBzcmM7XG4gIGlmIChzZWVuLmhhcyhzcmMpKSByZXR1cm4gc2Vlbi5nZXQoc3JjKTtcbiAgbGV0IGNvcHk7XG4gIGlmIChzcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgLy8gRGF0ZVxuICAgIGNvcHkgPSBuZXcgRGF0ZShzcmMuZ2V0VGltZSgpKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIFJlZ0V4cFxuICAgIGNvcHkgPSBuZXcgUmVnRXhwKHNyYyk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAvLyBBcnJheVxuICAgIGNvcHkgPSBuZXcgQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykgY29weVtpXSA9IGNsb25lKHNyY1tpXSwgc2Vlbik7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgLy8gTWFwXG4gICAgY29weSA9IG5ldyBNYXAoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHNyYy5lbnRyaWVzKCkpIGNvcHkuc2V0KGssIGNsb25lKHYsIHNlZW4pKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAvLyBTZXRcbiAgICBjb3B5ID0gbmV3IFNldCgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCB2IG9mIHNyYykgY29weS5hZGQoY2xvbmUodiwgc2VlbikpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIE9iamVjdFxuICAgIGNvcHkgPSB7fTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNyYykpIGNvcHlba10gPSBjbG9uZSh2LCBzZWVuKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGNsb25lICR7c3JjfWApO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBJZiBgQ3VzdG9tU2NoZW1hTWV0YWAgaXNuJ3QgZXh0ZW5kZWQgd2l0aCBhbnkga2V5cywgd2UnbGwgZmFsbCBiYWNrIHRvIGFcbi8vIGxvb3NlIFJlY29yZCBkZWZpbml0aW9uIGFsbG93aW5nIGZyZWUgZm9ybSB1c2FnZS5cbmNsYXNzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy50ZXN0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25kaXRpb25zID0gW107XG4gICAgdGhpcy5fbXV0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJuYWxUZXN0cyA9IHt9O1xuICAgIHRoaXMuX3doaXRlbGlzdCA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcbiAgICB0aGlzLl9ibGFja2xpc3QgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgdGhpcy5leGNsdXNpdmVUZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fdHlwZUNoZWNrID0gdm9pZCAwO1xuICAgIHRoaXMuc3BlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnRlc3RzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50eXBlRXJyb3IobWl4ZWQubm90VHlwZSk7XG4gICAgfSk7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHRoaXMuX3R5cGVDaGVjayA9IG9wdGlvbnMuY2hlY2s7XG4gICAgdGhpcy5zcGVjID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzdHJpcDogZmFsc2UsXG4gICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgIGRpc2FibGVTdGFja1RyYWNlOiBmYWxzZSxcbiAgICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY29lcmNlOiB0cnVlXG4gICAgfSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zcGVjKTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbihzID0+IHtcbiAgICAgIHMubm9uTnVsbGFibGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlbW92ZVxuICBnZXQgX3R5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgaWYgKHRoaXMuX211dGF0ZSkge1xuICAgICAgaWYgKHNwZWMpIE9iamVjdC5hc3NpZ24odGhpcy5zcGVjLCBzcGVjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBuZXN0ZWQgdmFsdWUgaXMgYSBzY2hlbWEgd2UgY2FuIHNraXAgY2xvbmluZywgc2luY2VcbiAgICAvLyB0aGV5IGFyZSBhbHJlYWR5IGltbXV0YWJsZVxuICAgIGNvbnN0IG5leHQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgcmVhZG9ubHlcbiAgICBuZXh0LnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgbmV4dC5fdHlwZUNoZWNrID0gdGhpcy5fdHlwZUNoZWNrO1xuICAgIG5leHQuX3doaXRlbGlzdCA9IHRoaXMuX3doaXRlbGlzdC5jbG9uZSgpO1xuICAgIG5leHQuX2JsYWNrbGlzdCA9IHRoaXMuX2JsYWNrbGlzdC5jbG9uZSgpO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxUZXN0cyk7XG4gICAgbmV4dC5leGNsdXNpdmVUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXhjbHVzaXZlVGVzdHMpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIHJlYWRvbmx5XG4gICAgbmV4dC5kZXBzID0gWy4uLnRoaXMuZGVwc107XG4gICAgbmV4dC5jb25kaXRpb25zID0gWy4uLnRoaXMuY29uZGl0aW9uc107XG4gICAgbmV4dC50ZXN0cyA9IFsuLi50aGlzLnRlc3RzXTtcbiAgICBuZXh0LnRyYW5zZm9ybXMgPSBbLi4udGhpcy50cmFuc2Zvcm1zXTtcbiAgICBuZXh0LnNwZWMgPSBjbG9uZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNwZWMsIHNwZWMpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBsYWJlbChsYWJlbCkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5sYWJlbCA9IGxhYmVsO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG1ldGEoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuc3BlYy5tZXRhO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5tZXRhID0gT2JqZWN0LmFzc2lnbihuZXh0LnNwZWMubWV0YSB8fCB7fSwgYXJnc1swXSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgd2l0aE11dGF0aW9uKGZuKSB7XG4gICAgbGV0IGJlZm9yZSA9IHRoaXMuX211dGF0ZTtcbiAgICB0aGlzLl9tdXRhdGUgPSB0cnVlO1xuICAgIGxldCByZXN1bHQgPSBmbih0aGlzKTtcbiAgICB0aGlzLl9tdXRhdGUgPSBiZWZvcmU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25jYXQoc2NoZW1hKSB7XG4gICAgaWYgKCFzY2hlbWEgfHwgc2NoZW1hID09PSB0aGlzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoc2NoZW1hLnR5cGUgIT09IHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBjYW5ub3QgXFxgY29uY2F0KClcXGAgc2NoZW1hJ3Mgb2YgZGlmZmVyZW50IHR5cGVzOiAke3RoaXMudHlwZX0gYW5kICR7c2NoZW1hLnR5cGV9YCk7XG4gICAgbGV0IGJhc2UgPSB0aGlzO1xuICAgIGxldCBjb21iaW5lZCA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIGNvbnN0IG1lcmdlZFNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlLnNwZWMsIGNvbWJpbmVkLnNwZWMpO1xuICAgIGNvbWJpbmVkLnNwZWMgPSBtZXJnZWRTcGVjO1xuICAgIGNvbWJpbmVkLmludGVybmFsVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlLmludGVybmFsVGVzdHMsIGNvbWJpbmVkLmludGVybmFsVGVzdHMpO1xuXG4gICAgLy8gbWFudWFsbHkgbWVyZ2UgdGhlIGJsYWNrbGlzdC93aGl0ZWxpc3QgKHRoZSBvdGhlciBgc2NoZW1hYCB0YWtlc1xuICAgIC8vIHByZWNlZGVuY2UgaW4gY2FzZSBvZiBjb25mbGljdHMpXG4gICAgY29tYmluZWQuX3doaXRlbGlzdCA9IGJhc2UuX3doaXRlbGlzdC5tZXJnZShzY2hlbWEuX3doaXRlbGlzdCwgc2NoZW1hLl9ibGFja2xpc3QpO1xuICAgIGNvbWJpbmVkLl9ibGFja2xpc3QgPSBiYXNlLl9ibGFja2xpc3QubWVyZ2Uoc2NoZW1hLl9ibGFja2xpc3QsIHNjaGVtYS5fd2hpdGVsaXN0KTtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGN1cnJlbnQgdGVzdHNcbiAgICBjb21iaW5lZC50ZXN0cyA9IGJhc2UudGVzdHM7XG4gICAgY29tYmluZWQuZXhjbHVzaXZlVGVzdHMgPSBiYXNlLmV4Y2x1c2l2ZVRlc3RzO1xuXG4gICAgLy8gbWFudWFsbHkgYWRkIHRoZSBuZXcgdGVzdHMgdG8gZW5zdXJlXG4gICAgLy8gdGhlIGRlZHVwaW5nIGxvZ2ljIGlzIGNvbnNpc3RlbnRcbiAgICBjb21iaW5lZC53aXRoTXV0YXRpb24obmV4dCA9PiB7XG4gICAgICBzY2hlbWEudGVzdHMuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgIG5leHQudGVzdChmbi5PUFRJT05TKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbWJpbmVkLnRyYW5zZm9ybXMgPSBbLi4uYmFzZS50cmFuc2Zvcm1zLCAuLi5jb21iaW5lZC50cmFuc2Zvcm1zXTtcbiAgICByZXR1cm4gY29tYmluZWQ7XG4gIH1cbiAgaXNUeXBlKHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5zcGVjLm51bGxhYmxlICYmIHYgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCAmJiB2ID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHlwZUNoZWNrKHYpO1xuICB9XG4gIHJlc29sdmUob3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSB0aGlzO1xuICAgIGlmIChzY2hlbWEuY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGxldCBjb25kaXRpb25zID0gc2NoZW1hLmNvbmRpdGlvbnM7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgICAgIHNjaGVtYS5jb25kaXRpb25zID0gW107XG4gICAgICBzY2hlbWEgPSBjb25kaXRpb25zLnJlZHVjZSgocHJldlNjaGVtYSwgY29uZGl0aW9uKSA9PiBjb25kaXRpb24ucmVzb2x2ZShwcmV2U2NoZW1hLCBvcHRpb25zKSwgc2NoZW1hKTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIHJlc29sdmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkc3RyaWN0LCBfb3B0aW9ucyRhYm9ydEVhcmx5LCBfb3B0aW9ucyRyZWN1cnNpdmUsIF9vcHRpb25zJGRpc2FibGVTdGFjaztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgZnJvbTogb3B0aW9ucy5mcm9tIHx8IFtdLFxuICAgICAgc3RyaWN0OiAoX29wdGlvbnMkc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QpICE9IG51bGwgPyBfb3B0aW9ucyRzdHJpY3QgOiB0aGlzLnNwZWMuc3RyaWN0LFxuICAgICAgYWJvcnRFYXJseTogKF9vcHRpb25zJGFib3J0RWFybHkgPSBvcHRpb25zLmFib3J0RWFybHkpICE9IG51bGwgPyBfb3B0aW9ucyRhYm9ydEVhcmx5IDogdGhpcy5zcGVjLmFib3J0RWFybHksXG4gICAgICByZWN1cnNpdmU6IChfb3B0aW9ucyRyZWN1cnNpdmUgPSBvcHRpb25zLnJlY3Vyc2l2ZSkgIT0gbnVsbCA/IF9vcHRpb25zJHJlY3Vyc2l2ZSA6IHRoaXMuc3BlYy5yZWN1cnNpdmUsXG4gICAgICBkaXNhYmxlU3RhY2tUcmFjZTogKF9vcHRpb25zJGRpc2FibGVTdGFjayA9IG9wdGlvbnMuZGlzYWJsZVN0YWNrVHJhY2UpICE9IG51bGwgPyBfb3B0aW9ucyRkaXNhYmxlU3RhY2sgOiB0aGlzLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIGNvbmZpZ3VyZWQgdHJhbnNmb3JtIHBpcGVsaW5lIG92ZXIgYW4gaW5wdXQgdmFsdWUuXG4gICAqL1xuXG4gIGNhc3QodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCByZXNvbHZlZFNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHZhbHVlXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIGxldCBhbGxvd09wdGlvbmFsaXR5ID0gb3B0aW9ucy5hc3NlcnQgPT09ICdpZ25vcmUtb3B0aW9uYWxpdHknO1xuICAgIGxldCByZXN1bHQgPSByZXNvbHZlZFNjaGVtYS5fY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuYXNzZXJ0ICE9PSBmYWxzZSAmJiAhcmVzb2x2ZWRTY2hlbWEuaXNUeXBlKHJlc3VsdCkpIHtcbiAgICAgIGlmIChhbGxvd09wdGlvbmFsaXR5ICYmIGlzQWJzZW50KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXR0ZWRWYWx1ZSA9IHByaW50VmFsdWUodmFsdWUpO1xuICAgICAgbGV0IGZvcm1hdHRlZFJlc3VsdCA9IHByaW50VmFsdWUocmVzdWx0KTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSB2YWx1ZSBvZiAke29wdGlvbnMucGF0aCB8fCAnZmllbGQnfSBjb3VsZCBub3QgYmUgY2FzdCB0byBhIHZhbHVlIGAgKyBgdGhhdCBzYXRpc2ZpZXMgdGhlIHNjaGVtYSB0eXBlOiBcIiR7cmVzb2x2ZWRTY2hlbWEudHlwZX1cIi4gXFxuXFxuYCArIGBhdHRlbXB0ZWQgdmFsdWU6ICR7Zm9ybWF0dGVkVmFsdWV9IFxcbmAgKyAoZm9ybWF0dGVkUmVzdWx0ICE9PSBmb3JtYXR0ZWRWYWx1ZSA/IGByZXN1bHQgb2YgY2FzdDogJHtmb3JtYXR0ZWRSZXN1bHR9YCA6ICcnKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX2Nhc3QocmF3VmFsdWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWUgPSByYXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gcmF3VmFsdWUgOiB0aGlzLnRyYW5zZm9ybXMucmVkdWNlKChwcmV2VmFsdWUsIGZuKSA9PiBmbi5jYWxsKHRoaXMsIHByZXZWYWx1ZSwgcmF3VmFsdWUsIHRoaXMpLCByYXdWYWx1ZSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCB7XG4gICAgICBwYXRoLFxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IF92YWx1ZSxcbiAgICAgIHN0cmljdCA9IHRoaXMuc3BlYy5zdHJpY3RcbiAgICB9ID0gb3B0aW9ucztcbiAgICBsZXQgdmFsdWUgPSBfdmFsdWU7XG4gICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY2FzdCh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGFzc2VydDogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgbGV0IGluaXRpYWxUZXN0cyA9IFtdO1xuICAgIGZvciAobGV0IHRlc3Qgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmludGVybmFsVGVzdHMpKSB7XG4gICAgICBpZiAodGVzdCkgaW5pdGlhbFRlc3RzLnB1c2godGVzdCk7XG4gICAgfVxuICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB0ZXN0czogaW5pdGlhbFRlc3RzXG4gICAgfSwgcGFuaWMsIGluaXRpYWxFcnJvcnMgPT4ge1xuICAgICAgLy8gZXZlbiBpZiB3ZSBhcmVuJ3QgZW5kaW5nIGVhcmx5IHdlIGNhbid0IHByb2NlZWQgZnVydGhlciBpZiB0aGUgdHlwZXMgYXJlbid0IGNvcnJlY3RcbiAgICAgIGlmIChpbml0aWFsRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV4dChpbml0aWFsRXJyb3JzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHRlc3RzOiB0aGlzLnRlc3RzXG4gICAgICB9LCBwYW5pYywgbmV4dCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBzZXQgb2YgdmFsaWRhdGlvbnMsIGVpdGhlciBzY2hlbWEsIHByb2R1Y2VkIFRlc3RzIG9yIGEgbmVzdGVkXG4gICAqIHNjaGVtYSB2YWxpZGF0ZSByZXN1bHQuXG4gICAqL1xuICBydW5UZXN0cyhydW5PcHRpb25zLCBwYW5pYywgbmV4dCkge1xuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xuICAgIGxldCB7XG4gICAgICB0ZXN0cyxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIHBhdGgsXG4gICAgICBvcHRpb25zXG4gICAgfSA9IHJ1bk9wdGlvbnM7XG4gICAgbGV0IHBhbmljT25jZSA9IGFyZyA9PiB7XG4gICAgICBpZiAoZmlyZWQpIHJldHVybjtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIHBhbmljKGFyZywgdmFsdWUpO1xuICAgIH07XG4gICAgbGV0IG5leHRPbmNlID0gYXJnID0+IHtcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbmV4dChhcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGxldCBjb3VudCA9IHRlc3RzLmxlbmd0aDtcbiAgICBsZXQgbmVzdGVkRXJyb3JzID0gW107XG4gICAgaWYgKCFjb3VudCkgcmV0dXJuIG5leHRPbmNlKFtdKTtcbiAgICBsZXQgYXJncyA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIHBhdGgsXG4gICAgICBvcHRpb25zLFxuICAgICAgc2NoZW1hOiB0aGlzXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXN0ID0gdGVzdHNbaV07XG4gICAgICB0ZXN0KGFyZ3MsIHBhbmljT25jZSwgZnVuY3Rpb24gZmluaXNoVGVzdFJ1bihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkoZXJyKSA/IG5lc3RlZEVycm9ycy5wdXNoKC4uLmVycikgOiBuZXN0ZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgtLWNvdW50IDw9IDApIHtcbiAgICAgICAgICBuZXh0T25jZShuZXN0ZWRFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXNOZXN0ZWRUZXN0KHtcbiAgICBrZXksXG4gICAgaW5kZXgsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgb3JpZ2luYWxQYXJlbnQsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgY29uc3QgayA9IGtleSAhPSBudWxsID8ga2V5IDogaW5kZXg7XG4gICAgaWYgKGsgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdNdXN0IGluY2x1ZGUgYGtleWAgb3IgYGluZGV4YCBmb3IgbmVzdGVkIHZhbGlkYXRpb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW5kZXggPSB0eXBlb2YgayA9PT0gJ251bWJlcic7XG4gICAgbGV0IHZhbHVlID0gcGFyZW50W2tdO1xuICAgIGNvbnN0IHRlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgLy8gTmVzdGVkIHZhbGlkYXRpb25zIGZpZWxkcyBhcmUgYWx3YXlzIHN0cmljdDpcbiAgICAgIC8vICAgIDEuIHBhcmVudCBpc24ndCBzdHJpY3Qgc28gdGhlIGNhc3Rpbmcgd2lsbCBhbHNvIGhhdmUgY2FzdCBpbm5lciB2YWx1ZXNcbiAgICAgIC8vICAgIDIuIHBhcmVudCBpcyBzdHJpY3QgaW4gd2hpY2ggY2FzZSB0aGUgbmVzdGVkIHZhbHVlcyB3ZXJlbid0IGNhc3QgZWl0aGVyXG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBwYXJlbnQsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9yaWdpbmFsVmFsdWU6IG9yaWdpbmFsUGFyZW50W2tdLFxuICAgICAgLy8gRklYTUU6IHRlc3RzIGRlcGVuZCBvbiBgaW5kZXhgIGJlaW5nIHBhc3NlZCBhcm91bmQgZGVlcGx5LFxuICAgICAgLy8gICB3ZSBzaG91bGQgbm90IGxldCB0aGUgb3B0aW9ucy5rZXkvaW5kZXggYmxlZWQgdGhyb3VnaFxuICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAvLyBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgW2lzSW5kZXggPyAnaW5kZXgnIDogJ2tleSddOiBrLFxuICAgICAgcGF0aDogaXNJbmRleCB8fCBrLmluY2x1ZGVzKCcuJykgPyBgJHtwYXJlbnRQYXRoIHx8ICcnfVske3ZhbHVlID8gayA6IGBcIiR7a31cImB9XWAgOiAocGFyZW50UGF0aCA/IGAke3BhcmVudFBhdGh9LmAgOiAnJykgKyBrZXlcbiAgICB9KTtcbiAgICByZXR1cm4gKF8sIHBhbmljLCBuZXh0KSA9PiB0aGlzLnJlc29sdmUodGVzdE9wdGlvbnMpLl92YWxpZGF0ZSh2YWx1ZSwgdGVzdE9wdGlvbnMsIHBhbmljLCBuZXh0KTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRkaXNhYmxlU3RhY2syO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVcbiAgICB9KSk7XG4gICAgbGV0IGRpc2FibGVTdGFja1RyYWNlID0gKF9vcHRpb25zJGRpc2FibGVTdGFjazIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVTdGFja1RyYWNlKSAhPSBudWxsID8gX29wdGlvbnMkZGlzYWJsZVN0YWNrMiA6IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBvcHRpb25zLCAoZXJyb3IsIHBhcnNlZCkgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycm9yKSkgZXJyb3IudmFsdWUgPSBwYXJzZWQ7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0sIChlcnJvcnMsIHZhbGlkYXRlZCkgPT4ge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHJlamVjdChuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9ycywgdmFsaWRhdGVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGlzYWJsZVN0YWNrVHJhY2UpKTtlbHNlIHJlc29sdmUodmFsaWRhdGVkKTtcbiAgICB9KSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJGRpc2FibGVTdGFjazM7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZVxuICAgIH0pKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBkaXNhYmxlU3RhY2tUcmFjZSA9IChfb3B0aW9ucyRkaXNhYmxlU3RhY2szID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjazMgOiBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZTtcbiAgICBzY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBzeW5jOiB0cnVlXG4gICAgfSksIChlcnJvciwgcGFyc2VkKSA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyb3IpKSBlcnJvci52YWx1ZSA9IHBhcnNlZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0sIChlcnJvcnMsIHZhbGlkYXRlZCkgPT4ge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCB2YWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRpc2FibGVTdGFja1RyYWNlKTtcbiAgICAgIHJlc3VsdCA9IHZhbGlkYXRlZDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykudGhlbigoKSA9PiB0cnVlLCBlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuICBpc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIF9nZXREZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gdGhpcy5zcGVjLmRlZmF1bHQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRWYWx1ZS5jYWxsKHRoaXMsIG9wdGlvbnMpIDogY2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgfVxuICBnZXREZWZhdWx0KG9wdGlvbnNcbiAgLy8gSWYgc2NoZW1hIGlzIGRlZmF1bHRlZCB3ZSBrbm93IGl0J3MgYXQgbGVhc3Qgbm90IHVuZGVmaW5lZFxuICApIHtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKG9wdGlvbnMgfHwge30pO1xuICAgIHJldHVybiBzY2hlbWEuX2dldERlZmF1bHQob3B0aW9ucyk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldERlZmF1bHQoKTtcbiAgICB9XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIGRlZmF1bHQ6IGRlZlxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHN0cmljdChpc1N0cmljdCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XG4gICAgICBzdHJpY3Q6IGlzU3RyaWN0XG4gICAgfSk7XG4gIH1cbiAgbnVsbGFiaWxpdHkobnVsbGFibGUsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBudWxsYWJsZVxuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5udWxsYWJsZSA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdudWxsYWJsZScsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHRoaXMuc2NoZW1hLnNwZWMubnVsbGFibGUgOiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsaXR5KG9wdGlvbmFsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgb3B0aW9uYWxcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMub3B0aW9uYWxpdHkgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnb3B0aW9uYWxpdHknLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuc2NoZW1hLnNwZWMub3B0aW9uYWwgOiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xuICB9XG4gIGRlZmluZWQobWVzc2FnZSA9IG1peGVkLmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eShmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbiAgbnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFiaWxpdHkodHJ1ZSk7XG4gIH1cbiAgbm9uTnVsbGFibGUobWVzc2FnZSA9IG1peGVkLm5vdE51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5udWxsYWJpbGl0eShmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbiAgcmVxdWlyZWQobWVzc2FnZSA9IG1peGVkLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS53aXRoTXV0YXRpb24obmV4dCA9PiBuZXh0Lm5vbk51bGxhYmxlKG1lc3NhZ2UpLmRlZmluZWQobWVzc2FnZSkpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4gbmV4dC5udWxsYWJsZSgpLm9wdGlvbmFsKCkpO1xuICB9XG4gIHRyYW5zZm9ybShmbikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQudHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdGVzdCBmdW5jdGlvbiB0byB0aGUgc2NoZW1hJ3MgcXVldWUgb2YgdGVzdHMuXG4gICAqIHRlc3RzIGNhbiBiZSBleGNsdXNpdmUgb3Igbm9uLWV4Y2x1c2l2ZS5cbiAgICpcbiAgICogLSBleGNsdXNpdmUgdGVzdHMsIHdpbGwgcmVwbGFjZSBhbnkgZXhpc3RpbmcgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICogLSBub24tZXhjbHVzaXZlOiBjYW4gYmUgc3RhY2tlZFxuICAgKlxuICAgKiBJZiBhIG5vbi1leGNsdXNpdmUgdGVzdCBpcyBhZGRlZCB0byBhIHNjaGVtYSB3aXRoIGFuIGV4Y2x1c2l2ZSB0ZXN0IG9mIHRoZSBzYW1lIG5hbWVcbiAgICogdGhlIGV4Y2x1c2l2ZSB0ZXN0IGlzIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIGJlIHN0YWNrZWQuXG4gICAqXG4gICAqIElmIGFuIGV4Y2x1c2l2ZSB0ZXN0IGlzIGFkZGVkIHRvIGEgc2NoZW1hIHdpdGggbm9uLWV4Y2x1c2l2ZSB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIHRoZSBwcmV2aW91cyB0ZXN0cyBhcmUgcmVtb3ZlZCBhbmQgZnVydGhlciB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lIHdpbGwgcmVwbGFjZSBlYWNoIG90aGVyLlxuICAgKi9cblxuICB0ZXN0KC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0cztcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIHRlc3Q6IGFyZ3NbMF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMgPSBhcmdzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIHRlc3Q6IGFyZ3NbMV1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIG1lc3NhZ2U6IGFyZ3NbMV0sXG4gICAgICAgIHRlc3Q6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRzLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCkgb3B0cy5tZXNzYWdlID0gbWl4ZWQuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignYHRlc3RgIGlzIGEgcmVxdWlyZWQgcGFyYW1ldGVycycpO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCB2YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRpb24ob3B0cyk7XG4gICAgbGV0IGlzRXhjbHVzaXZlID0gb3B0cy5leGNsdXNpdmUgfHwgb3B0cy5uYW1lICYmIG5leHQuZXhjbHVzaXZlVGVzdHNbb3B0cy5uYW1lXSA9PT0gdHJ1ZTtcbiAgICBpZiAob3B0cy5leGNsdXNpdmUpIHtcbiAgICAgIGlmICghb3B0cy5uYW1lKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNsdXNpdmUgdGVzdHMgbXVzdCBwcm92aWRlIGEgdW5pcXVlIGBuYW1lYCBpZGVudGlmeWluZyB0aGUgdGVzdCcpO1xuICAgIH1cbiAgICBpZiAob3B0cy5uYW1lKSBuZXh0LmV4Y2x1c2l2ZVRlc3RzW29wdHMubmFtZV0gPSAhIW9wdHMuZXhjbHVzaXZlO1xuICAgIG5leHQudGVzdHMgPSBuZXh0LnRlc3RzLmZpbHRlcihmbiA9PiB7XG4gICAgICBpZiAoZm4uT1BUSU9OUy5uYW1lID09PSBvcHRzLm5hbWUpIHtcbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChmbi5PUFRJT05TLnRlc3QgPT09IHZhbGlkYXRlLk9QVElPTlMudGVzdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgbmV4dC50ZXN0cy5wdXNoKHZhbGlkYXRlKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB3aGVuKGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykgJiYgdHlwZW9mIGtleXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ga2V5cztcbiAgICAgIGtleXMgPSAnLic7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCBkZXBzID0gdG9BcnJheShrZXlzKS5tYXAoa2V5ID0+IG5ldyBSZWZlcmVuY2Uoa2V5KSk7XG4gICAgZGVwcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlIHJlYWRvbmx5IGFycmF5XG4gICAgICBpZiAoZGVwLmlzU2libGluZykgbmV4dC5kZXBzLnB1c2goZGVwLmtleSk7XG4gICAgfSk7XG4gICAgbmV4dC5jb25kaXRpb25zLnB1c2godHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29uZGl0aW9uKGRlcHMsIG9wdGlvbnMpIDogQ29uZGl0aW9uLmZyb21PcHRpb25zKGRlcHMsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB0eXBlRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy50eXBlRXJyb3IgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHlwZUVycm9yJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2hlbWEuX3R5cGVDaGVjayh2YWx1ZSkpIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuc2NoZW1hLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvbmVPZihlbnVtcywgbWVzc2FnZSA9IG1peGVkLm9uZU9mKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgZW51bXMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgbmV4dC5fd2hpdGVsaXN0LmFkZCh2YWwpO1xuICAgICAgbmV4dC5fYmxhY2tsaXN0LmRlbGV0ZSh2YWwpO1xuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy53aGl0ZUxpc3QgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnb25lT2YnLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbGlkcyA9IHRoaXMuc2NoZW1hLl93aGl0ZWxpc3Q7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHZhbGlkcy5yZXNvbHZlQWxsKHRoaXMucmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkgPyB0cnVlIDogdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IEFycmF5LmZyb20odmFsaWRzKS5qb2luKCcsICcpLFxuICAgICAgICAgICAgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG5vdE9uZU9mKGVudW1zLCBtZXNzYWdlID0gbWl4ZWQubm90T25lT2YpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBlbnVtcy5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICBuZXh0Ll9ibGFja2xpc3QuYWRkKHZhbCk7XG4gICAgICBuZXh0Ll93aGl0ZWxpc3QuZGVsZXRlKHZhbCk7XG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLmJsYWNrbGlzdCA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdub3RPbmVPZicsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnZhbGlkcyA9IHRoaXMuc2NoZW1hLl9ibGFja2xpc3Q7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IGludmFsaWRzLnJlc29sdmVBbGwodGhpcy5yZXNvbHZlKTtcbiAgICAgICAgaWYgKHJlc29sdmVkLmluY2x1ZGVzKHZhbHVlKSkgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKGludmFsaWRzKS5qb2luKCcsICcpLFxuICAgICAgICAgICAgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzdHJpcChzdHJpcCA9IHRydWUpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMuc3RyaXAgPSBzdHJpcDtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzZXJpYWxpemVkIGRlc2NyaXB0aW9uIG9mIHRoZSBzY2hlbWEgaW5jbHVkaW5nIHZhbGlkYXRpb25zLCBmbGFncywgdHlwZXMgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBQcm92aWRlIGFueSBuZWVkZWQgY29udGV4dCBmb3IgcmVzb2x2aW5nIHJ1bnRpbWUgc2NoZW1hIGFsdGVyYXRpb25zIChsYXp5LCB3aGVuIGNvbmRpdGlvbnMsIGV0YykuXG4gICAqL1xuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIG1ldGEsXG4gICAgICBvcHRpb25hbCxcbiAgICAgIG51bGxhYmxlXG4gICAgfSA9IG5leHQuc3BlYztcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBsYWJlbCxcbiAgICAgIG9wdGlvbmFsLFxuICAgICAgbnVsbGFibGUsXG4gICAgICBkZWZhdWx0OiBuZXh0LmdldERlZmF1bHQob3B0aW9ucyksXG4gICAgICB0eXBlOiBuZXh0LnR5cGUsXG4gICAgICBvbmVPZjogbmV4dC5fd2hpdGVsaXN0LmRlc2NyaWJlKCksXG4gICAgICBub3RPbmVPZjogbmV4dC5fYmxhY2tsaXN0LmRlc2NyaWJlKCksXG4gICAgICB0ZXN0czogbmV4dC50ZXN0cy5tYXAoZm4gPT4gKHtcbiAgICAgICAgbmFtZTogZm4uT1BUSU9OUy5uYW1lLFxuICAgICAgICBwYXJhbXM6IGZuLk9QVElPTlMucGFyYW1zXG4gICAgICB9KSkuZmlsdGVyKChuLCBpZHgsIGxpc3QpID0+IGxpc3QuZmluZEluZGV4KGMgPT4gYy5uYW1lID09PSBuLm5hbWUpID09PSBpZHgpXG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH1cbn1cbi8vIEB0cy1leHBlY3QtZXJyb3JcblNjaGVtYS5wcm90b3R5cGUuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIFsndmFsaWRhdGUnLCAndmFsaWRhdGVTeW5jJ10pIFNjaGVtYS5wcm90b3R5cGVbYCR7bWV0aG9kfUF0YF0gPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgc2NoZW1hXG4gIH0gPSBnZXRJbih0aGlzLCBwYXRoLCB2YWx1ZSwgb3B0aW9ucy5jb250ZXh0KTtcbiAgcmV0dXJuIHNjaGVtYVttZXRob2RdKHBhcmVudCAmJiBwYXJlbnRbcGFyZW50UGF0aF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBwYXJlbnQsXG4gICAgcGF0aFxuICB9KSk7XG59O1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ2VxdWFscycsICdpcyddKSBTY2hlbWEucHJvdG90eXBlW2FsaWFzXSA9IFNjaGVtYS5wcm90b3R5cGUub25lT2Y7XG5mb3IgKGNvbnN0IGFsaWFzIG9mIFsnbm90JywgJ25vcGUnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm5vdE9uZU9mO1xuXG5jb25zdCByZXR1cm5zVHJ1ZSA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBjcmVhdGUkOChzcGVjKSB7XG4gIHJldHVybiBuZXcgTWl4ZWRTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBNaXhlZFNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBzdXBlcih0eXBlb2Ygc3BlYyA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogc3BlY1xuICAgIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogcmV0dXJuc1RydWVcbiAgICB9LCBzcGVjKSk7XG4gIH1cbn1cbmNyZWF0ZSQ4LnByb3RvdHlwZSA9IE1peGVkU2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlJDcoKSB7XG4gIHJldHVybiBuZXcgQm9vbGVhblNjaGVtYSgpO1xufVxuY2xhc3MgQm9vbGVhblNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBCb29sZWFuKSB2ID0gdi52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguc3BlYy5jb2VyY2UgJiYgIWN0eC5pc1R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKC9eKHRydWV8MSkkL2kudGVzdChTdHJpbmcodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKC9eKGZhbHNlfDApJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpc1RydWUobWVzc2FnZSA9IGJvb2xlYW4uaXNWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdpcy12YWx1ZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0ZhbHNlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAnZmFsc2UnXG4gICAgICB9LFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWZhdWx0KGRlZikge1xuICAgIHJldHVybiBzdXBlci5kZWZhdWx0KGRlZik7XG4gIH1cbiAgZGVmaW5lZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmaW5lZChtc2cpO1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBzdXBlci5vcHRpb25hbCgpO1xuICB9XG4gIHJlcXVpcmVkKG1zZykge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtc2cpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci5udWxsYWJsZSgpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1zZykge1xuICAgIHJldHVybiBzdXBlci5ub25OdWxsYWJsZShtc2cpO1xuICB9XG4gIHN0cmlwKHYpIHtcbiAgICByZXR1cm4gc3VwZXIuc3RyaXAodik7XG4gIH1cbn1cbmNyZWF0ZSQ3LnByb3RvdHlwZSA9IEJvb2xlYW5TY2hlbWEucHJvdG90eXBlO1xuXG4vLyBUYWtlbiBmcm9tIEhUTUwgc3BlYzogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xubGV0IHJFbWFpbCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xubGV0IHJVcmwgPVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vXigoaHR0cHM/fGZ0cCk6KT9cXC9cXC8oKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/KSg6XFxkKik/KShcXC8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKyhcXC8oKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkqKSopPyk/KFxcPygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8W1xcdUUwMDAtXFx1RjhGRl18XFwvfFxcPykqKT8oXFwjKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxcXC98XFw/KSopPyQvaTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5sZXQgclVVSUQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5sZXQgaXNUcmltbWVkID0gdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50cmltKCk7XG5sZXQgb2JqU3RyaW5nVGFnID0ge30udG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGNyZWF0ZSQ2KCkge1xuICByZXR1cm4gbmV3IFN0cmluZ1NjaGVtYSgpO1xufVxuY2xhc3MgU3RyaW5nU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgodmFsdWUsIF9yYXcsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoIWN0eC5zcGVjLmNvZXJjZSB8fCBjdHguaXNUeXBlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8vIGRvbid0IGV2ZXIgY29udmVydCBhcnJheXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS50b1N0cmluZyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcblxuICAgICAgICAvLyBubyBvbmUgd2FudHMgcGxhaW4gb2JqZWN0cyBjb252ZXJ0ZWQgdG8gW09iamVjdCBvYmplY3RdXG4gICAgICAgIGlmIChzdHJWYWx1ZSA9PT0gb2JqU3RyaW5nVGFnKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlcXVpcmVkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWQobWVzc2FnZSkud2l0aE11dGF0aW9uKHNjaGVtYSA9PiBzY2hlbWEudGVzdCh7XG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IG1peGVkLnJlcXVpcmVkLFxuICAgICAgbmFtZTogJ3JlcXVpcmVkJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiAhIXZhbHVlLmxlbmd0aFxuICAgIH0pKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gc3VwZXIubm90UmVxdWlyZWQoKS53aXRoTXV0YXRpb24oc2NoZW1hID0+IHtcbiAgICAgIHNjaGVtYS50ZXN0cyA9IHNjaGVtYS50ZXN0cy5maWx0ZXIodCA9PiB0Lk9QVElPTlMubmFtZSAhPT0gJ3JlcXVpcmVkJyk7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH0pO1xuICB9XG4gIGxlbmd0aChsZW5ndGgsIG1lc3NhZ2UgPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gdGhpcy5yZXNvbHZlKGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IHN0cmluZy5taW4pIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IHRoaXMucmVzb2x2ZShtaW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UgPSBzdHJpbmcubWF4KSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXRjaGVzKHJlZ2V4LCBvcHRpb25zKSB7XG4gICAgbGV0IGV4Y2x1ZGVFbXB0eVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGxldCBuYW1lO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICh7XG4gICAgICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0gPSBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6IG5hbWUgfHwgJ21hdGNoZXMnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcubWF0Y2hlcyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICByZWdleFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gJycgJiYgZXhjbHVkZUVtcHR5U3RyaW5nIHx8IHZhbHVlLnNlYXJjaChyZWdleCkgIT09IC0xXG4gICAgfSk7XG4gIH1cbiAgZW1haWwobWVzc2FnZSA9IHN0cmluZy5lbWFpbCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMockVtYWlsLCB7XG4gICAgICBuYW1lOiAnZW1haWwnLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHVybChtZXNzYWdlID0gc3RyaW5nLnVybCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoclVybCwge1xuICAgICAgbmFtZTogJ3VybCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdXVpZChtZXNzYWdlID0gc3RyaW5nLnV1aWQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHJVVUlELCB7XG4gICAgICBuYW1lOiAndXVpZCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLy8tLSB0cmFuc2Zvcm1zIC0tXG4gIGVuc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0KCcnKS50cmFuc2Zvcm0odmFsID0+IHZhbCA9PT0gbnVsbCA/ICcnIDogdmFsKTtcbiAgfVxuICB0cmltKG1lc3NhZ2UgPSBzdHJpbmcudHJpbSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWwgPT4gdmFsICE9IG51bGwgPyB2YWwudHJpbSgpIDogdmFsKS50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHJpbScsXG4gICAgICB0ZXN0OiBpc1RyaW1tZWRcbiAgICB9KTtcbiAgfVxuICBsb3dlcmNhc2UobWVzc2FnZSA9IHN0cmluZy5sb3dlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICB9KTtcbiAgfVxuICB1cHBlcmNhc2UobWVzc2FnZSA9IHN0cmluZy51cHBlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICB9KTtcbiAgfVxufVxuY3JlYXRlJDYucHJvdG90eXBlID0gU3RyaW5nU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIFN0cmluZyBJbnRlcmZhY2VzXG4vL1xuXG5sZXQgaXNOYU4kMSA9IHZhbHVlID0+IHZhbHVlICE9ICt2YWx1ZTtcbmZ1bmN0aW9uIGNyZWF0ZSQ1KCkge1xuICByZXR1cm4gbmV3IE51bWJlclNjaGVtYSgpO1xufVxuY2xhc3MgTnVtYmVyU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4kMSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZWQucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgICBpZiAocGFyc2VkID09PSAnJykgcmV0dXJuIE5hTjtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgcGFyc2VGbG9hdCB0byBhdm9pZCBwb3NpdGl2ZXMgb24gYWxwaGEtbnVtZXJpYyBzdHJpbmdzXG4gICAgICAgICAgcGFyc2VkID0gK3BhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG51bGwgLT4gTmFOIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXG4gICAgICAgIC8vIG51bGxhYmlsaXR5IGNoZWNrIHZzIFR5cGVFcnJvcnNcbiAgICAgICAgaWYgKGN0eC5pc1R5cGUocGFyc2VkKSB8fCBwYXJzZWQgPT09IG51bGwpIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gbnVtYmVyLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gbnVtYmVyLm1heCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXNzVGhhbihsZXNzLCBtZXNzYWdlID0gbnVtYmVyLmxlc3NUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVzc1xuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IHRoaXMucmVzb2x2ZShsZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtb3JlVGhhbihtb3JlLCBtZXNzYWdlID0gbnVtYmVyLm1vcmVUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9yZVxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+IHRoaXMucmVzb2x2ZShtb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwb3NpdGl2ZShtc2cgPSBudW1iZXIucG9zaXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5tb3JlVGhhbigwLCBtc2cpO1xuICB9XG4gIG5lZ2F0aXZlKG1zZyA9IG51bWJlci5uZWdhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKDAsIG1zZyk7XG4gIH1cbiAgaW50ZWdlcihtZXNzYWdlID0gbnVtYmVyLmludGVnZXIpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdpbnRlZ2VyJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsID0+IE51bWJlci5pc0ludGVnZXIodmFsKVxuICAgIH0pO1xuICB9XG4gIHRydW5jYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gdmFsdWUgfCAwIDogdmFsdWUpO1xuICB9XG4gIHJvdW5kKG1ldGhvZCkge1xuICAgIHZhciBfbWV0aG9kO1xuICAgIGxldCBhdmFpbCA9IFsnY2VpbCcsICdmbG9vcicsICdyb3VuZCcsICd0cnVuYyddO1xuICAgIG1ldGhvZCA9ICgoX21ldGhvZCA9IG1ldGhvZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZXRob2QudG9Mb3dlckNhc2UoKSkgfHwgJ3JvdW5kJztcblxuICAgIC8vIHRoaXMgZXhpc3RzIGZvciBzeW1lbXRyeSB3aXRoIHRoZSBuZXcgTWF0aC50cnVuY1xuICAgIGlmIChtZXRob2QgPT09ICd0cnVuYycpIHJldHVybiB0aGlzLnRydW5jYXRlKCk7XG4gICAgaWYgKGF2YWlsLmluZGV4T2YobWV0aG9kLnRvTG93ZXJDYXNlKCkpID09PSAtMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignT25seSB2YWxpZCBvcHRpb25zIGZvciByb3VuZCgpIGFyZTogJyArIGF2YWlsLmpvaW4oJywgJykpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gTWF0aFttZXRob2RdKHZhbHVlKSA6IHZhbHVlKTtcbiAgfVxufVxuY3JlYXRlJDUucHJvdG90eXBlID0gTnVtYmVyU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIE51bWJlciBJbnRlcmZhY2VzXG4vL1xuXG4vKipcbiAqIFRoaXMgZmlsZSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGZpbGUgZnJvbSB0aGUgZm9sbG93aW5nIHJlcG9zaXRvcnk6XG4gKiBEYXRlLnBhcnNlIHdpdGggcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQgZm9yIElTTyA4NjAxIDxodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9qcy1pc284NjAxPlxuICogTk9OLUNPTkZPUk1BTlQgRURJVElPTi5cbiAqIMKpIDIwMTEgQ29saW4gU25vdmVyIDxodHRwOi8vemV0YWZsZWV0LmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICovXG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gICAgICAgICAgICAgICAgMSBZWVlZICAgICAgICAgICAgICAgIDIgTU0gICAgICAgIDMgREQgICAgICAgICAgICAgIDQgSEggICAgIDUgbW0gICAgICAgIDYgc3MgICAgICAgICAgIDcgbXNlYyAgICAgICAgIDggWiA5IMKxICAgMTAgdHpISCAgICAxMSB0em1tXG5jb25zdCBpc29SZWcgPSAvXihcXGR7NH18WystXVxcZHs2fSkoPzotPyhcXGR7Mn0pKD86LT8oXFxkezJ9KSk/KT8oPzpbIFRdPyhcXGR7Mn0pOj8oXFxkezJ9KSg/Ojo/KFxcZHsyfSkoPzpbLC5dKFxcZHsxLH0pKT8pPyg/OihaKXwoWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyk/KT8kLztcbmZ1bmN0aW9uIHRvTnVtYmVyKHN0ciwgZGVmYXVsdFZhbHVlID0gMCkge1xuICByZXR1cm4gTnVtYmVyKHN0cikgfHwgZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gcGFyc2VJc29EYXRlKGRhdGUpIHtcbiAgY29uc3QgcmVnZXhSZXN1bHQgPSBpc29SZWcuZXhlYyhkYXRlKTtcbiAgaWYgKCFyZWdleFJlc3VsdCkgcmV0dXJuIERhdGUucGFyc2UgPyBEYXRlLnBhcnNlKGRhdGUpIDogTnVtYmVyLk5hTjtcblxuICAvLyB1c2Ugb2YgdG9OdW1iZXIoKSBhdm9pZHMgTmFOIHRpbWVzdGFtcHMgY2F1c2VkIGJ5IOKAnHVuZGVmaW5lZOKAnVxuICAvLyB2YWx1ZXMgYmVpbmcgcGFzc2VkIHRvIERhdGUgY29uc3RydWN0b3JcbiAgY29uc3Qgc3RydWN0ID0ge1xuICAgIHllYXI6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzFdKSxcbiAgICBtb250aDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMl0sIDEpIC0gMSxcbiAgICBkYXk6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzNdLCAxKSxcbiAgICBob3VyOiB0b051bWJlcihyZWdleFJlc3VsdFs0XSksXG4gICAgbWludXRlOiB0b051bWJlcihyZWdleFJlc3VsdFs1XSksXG4gICAgc2Vjb25kOiB0b051bWJlcihyZWdleFJlc3VsdFs2XSksXG4gICAgbWlsbGlzZWNvbmQ6IHJlZ2V4UmVzdWx0WzddID9cbiAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3ViLXNlY29uZCBwcmVjaXNpb24gYmV5b25kIG1pbGxpc2Vjb25kc1xuICAgIHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzddLnN1YnN0cmluZygwLCAzKSkgOiAwLFxuICAgIHo6IHJlZ2V4UmVzdWx0WzhdIHx8IHVuZGVmaW5lZCxcbiAgICBwbHVzTWludXM6IHJlZ2V4UmVzdWx0WzldIHx8IHVuZGVmaW5lZCxcbiAgICBob3VyT2Zmc2V0OiB0b051bWJlcihyZWdleFJlc3VsdFsxMF0pLFxuICAgIG1pbnV0ZU9mZnNldDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMTFdKVxuICB9O1xuXG4gIC8vIHRpbWVzdGFtcHMgd2l0aG91dCB0aW1lem9uZSBpZGVudGlmaWVycyBzaG91bGQgYmUgY29uc2lkZXJlZCBsb2NhbCB0aW1lXG4gIGlmIChzdHJ1Y3QueiA9PT0gdW5kZWZpbmVkICYmIHN0cnVjdC5wbHVzTWludXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHJ1Y3QueWVhciwgc3RydWN0Lm1vbnRoLCBzdHJ1Y3QuZGF5LCBzdHJ1Y3QuaG91ciwgc3RydWN0Lm1pbnV0ZSwgc3RydWN0LnNlY29uZCwgc3RydWN0Lm1pbGxpc2Vjb25kKS52YWx1ZU9mKCk7XG4gIH1cbiAgbGV0IHRvdGFsTWludXRlc09mZnNldCA9IDA7XG4gIGlmIChzdHJ1Y3QueiAhPT0gJ1onICYmIHN0cnVjdC5wbHVzTWludXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTWludXRlc09mZnNldCA9IHN0cnVjdC5ob3VyT2Zmc2V0ICogNjAgKyBzdHJ1Y3QubWludXRlT2Zmc2V0O1xuICAgIGlmIChzdHJ1Y3QucGx1c01pbnVzID09PSAnKycpIHRvdGFsTWludXRlc09mZnNldCA9IDAgLSB0b3RhbE1pbnV0ZXNPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIERhdGUuVVRDKHN0cnVjdC55ZWFyLCBzdHJ1Y3QubW9udGgsIHN0cnVjdC5kYXksIHN0cnVjdC5ob3VyLCBzdHJ1Y3QubWludXRlICsgdG90YWxNaW51dGVzT2Zmc2V0LCBzdHJ1Y3Quc2Vjb25kLCBzdHJ1Y3QubWlsbGlzZWNvbmQpO1xufVxuXG5sZXQgaW52YWxpZERhdGUgPSBuZXcgRGF0ZSgnJyk7XG5sZXQgaXNEYXRlID0gb2JqID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG5mdW5jdGlvbiBjcmVhdGUkNCgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlU2NoZW1hKCk7XG59XG5jbGFzcyBEYXRlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgY2hlY2sodikge1xuICAgICAgICByZXR1cm4gaXNEYXRlKHYpICYmICFpc05hTih2LmdldFRpbWUoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgLy8gbnVsbCAtPiBJbnZhbGlkRGF0ZSBpc24ndCB1c2VmdWw7IHRyZWF0IGFsbCBudWxscyBhcyBudWxsIGFuZCBsZXQgaXQgZmFpbCBvblxuICAgICAgICAvLyBudWxsYWJpbGl0eSBjaGVjayB2cyBUeXBlRXJyb3JzXG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJc29EYXRlKHZhbHVlKTtcblxuICAgICAgICAvLyAwIGlzIGEgdmFsaWQgdGltZXN0YW1wIGVxdWl2YWxlbnQgdG8gMTk3MC0wMS0wMVQwMDowMDowMFoodW5peCBlcG9jaCkgb3IgYmVmb3JlLlxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSA/IG5ldyBEYXRlKHZhbHVlKSA6IERhdGVTY2hlbWEuSU5WQUxJRF9EQVRFO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcHJlcGFyZVBhcmFtKHJlZiwgbmFtZSkge1xuICAgIGxldCBwYXJhbTtcbiAgICBpZiAoIVJlZmVyZW5jZS5pc1JlZihyZWYpKSB7XG4gICAgICBsZXQgY2FzdCA9IHRoaXMuY2FzdChyZWYpO1xuICAgICAgaWYgKCF0aGlzLl90eXBlQ2hlY2soY2FzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcYCR7bmFtZX1cXGAgbXVzdCBiZSBhIERhdGUgb3IgYSB2YWx1ZSB0aGF0IGNhbiBiZSBcXGBjYXN0KClcXGAgdG8gYSBEYXRlYCk7XG4gICAgICBwYXJhbSA9IGNhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtID0gcmVmO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IGRhdGUubWluKSB7XG4gICAgbGV0IGxpbWl0ID0gdGhpcy5wcmVwYXJlUGFyYW0obWluLCAnbWluJyk7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IHRoaXMucmVzb2x2ZShsaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IGRhdGUubWF4KSB7XG4gICAgbGV0IGxpbWl0ID0gdGhpcy5wcmVwYXJlUGFyYW0obWF4LCAnbWF4Jyk7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMucmVzb2x2ZShsaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbkRhdGVTY2hlbWEuSU5WQUxJRF9EQVRFID0gaW52YWxpZERhdGU7XG5jcmVhdGUkNC5wcm90b3R5cGUgPSBEYXRlU2NoZW1hLnByb3RvdHlwZTtcbmNyZWF0ZSQ0LklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5mdW5jdGlvbiBzb3J0RmllbGRzKGZpZWxkcywgZXhjbHVkZWRFZGdlcyA9IFtdKSB7XG4gIGxldCBlZGdlcyA9IFtdO1xuICBsZXQgbm9kZXMgPSBuZXcgU2V0KCk7XG4gIGxldCBleGNsdWRlcyA9IG5ldyBTZXQoZXhjbHVkZWRFZGdlcy5tYXAoKFthLCBiXSkgPT4gYCR7YX0tJHtifWApKTtcbiAgZnVuY3Rpb24gYWRkTm9kZShkZXBQYXRoLCBrZXkpIHtcbiAgICBsZXQgbm9kZSA9IHNwbGl0KGRlcFBhdGgpWzBdO1xuICAgIG5vZGVzLmFkZChub2RlKTtcbiAgICBpZiAoIWV4Y2x1ZGVzLmhhcyhgJHtrZXl9LSR7bm9kZX1gKSkgZWRnZXMucHVzaChba2V5LCBub2RlXSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgIGxldCB2YWx1ZSA9IGZpZWxkc1trZXldO1xuICAgIG5vZGVzLmFkZChrZXkpO1xuICAgIGlmIChSZWZlcmVuY2UuaXNSZWYodmFsdWUpICYmIHZhbHVlLmlzU2libGluZykgYWRkTm9kZSh2YWx1ZS5wYXRoLCBrZXkpO2Vsc2UgaWYgKGlzU2NoZW1hKHZhbHVlKSAmJiAnZGVwcycgaW4gdmFsdWUpIHZhbHVlLmRlcHMuZm9yRWFjaChwYXRoID0+IGFkZE5vZGUocGF0aCwga2V5KSk7XG4gIH1cbiAgcmV0dXJuIHRvcG9zb3J0LmFycmF5KEFycmF5LmZyb20obm9kZXMpLCBlZGdlcykucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBlcnIpIHtcbiAgbGV0IGlkeCA9IEluZmluaXR5O1xuICBhcnIuc29tZSgoa2V5LCBpaSkgPT4ge1xuICAgIHZhciBfZXJyJHBhdGg7XG4gICAgaWYgKChfZXJyJHBhdGggPSBlcnIucGF0aCkgIT0gbnVsbCAmJiBfZXJyJHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgaWR4ID0gaWk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gc29ydEJ5S2V5T3JkZXIoa2V5cykge1xuICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICByZXR1cm4gZmluZEluZGV4KGtleXMsIGEpIC0gZmluZEluZGV4KGtleXMsIGIpO1xuICB9O1xufVxuXG5jb25zdCBwYXJzZUpzb24gPSAodmFsdWUsIF8sIGN0eCkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBsZXQgcGFyc2VkID0gdmFsdWU7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8qICovXG4gIH1cbiAgcmV0dXJuIGN0eC5pc1R5cGUocGFyc2VkKSA/IHBhcnNlZCA6IHZhbHVlO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gZGVlcFBhcnRpYWwoc2NoZW1hKSB7XG4gIGlmICgnZmllbGRzJyBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBmaWVsZFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgIHBhcnRpYWxba2V5XSA9IGRlZXBQYXJ0aWFsKGZpZWxkU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5zZXRGaWVsZHMocGFydGlhbCk7XG4gIH1cbiAgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgbmV4dEFycmF5ID0gc2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgaWYgKG5leHRBcnJheS5pbm5lclR5cGUpIG5leHRBcnJheS5pbm5lclR5cGUgPSBkZWVwUGFydGlhbChuZXh0QXJyYXkuaW5uZXJUeXBlKTtcbiAgICByZXR1cm4gbmV4dEFycmF5O1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKS5jbG9uZSh7XG4gICAgICB0eXBlczogc2NoZW1hLnNwZWMudHlwZXMubWFwKGRlZXBQYXJ0aWFsKVxuICAgIH0pO1xuICB9XG4gIGlmICgnb3B0aW9uYWwnIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuY29uc3QgZGVlcEhhcyA9IChvYmosIHApID0+IHtcbiAgY29uc3QgcGF0aCA9IFsuLi5ub3JtYWxpemVQYXRoKHApXTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSByZXR1cm4gcGF0aFswXSBpbiBvYmo7XG4gIGxldCBsYXN0ID0gcGF0aC5wb3AoKTtcbiAgbGV0IHBhcmVudCA9IGdldHRlcihqb2luKHBhdGgpLCB0cnVlKShvYmopO1xuICByZXR1cm4gISEocGFyZW50ICYmIGxhc3QgaW4gcGFyZW50KTtcbn07XG5sZXQgaXNPYmplY3QgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gdW5rbm93bihjdHgsIHZhbHVlKSB7XG4gIGxldCBrbm93biA9IE9iamVjdC5rZXlzKGN0eC5maWVsZHMpO1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihrZXkgPT4ga25vd24uaW5kZXhPZihrZXkpID09PSAtMSk7XG59XG5jb25zdCBkZWZhdWx0U29ydCA9IHNvcnRCeUtleU9yZGVyKFtdKTtcbmZ1bmN0aW9uIGNyZWF0ZSQzKHNwZWMpIHtcbiAgcmV0dXJuIG5ldyBPYmplY3RTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBPYmplY3RTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZpZWxkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fc29ydEVycm9ycyA9IGRlZmF1bHRTb3J0O1xuICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgdGhpcy5fZXhjbHVkZWRFZGdlcyA9IFtdO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgIHRoaXMuc2hhcGUoc3BlYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2Nhc3QoX3ZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX29wdGlvbnMkc3RyaXBVbmtub3duO1xuICAgIGxldCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAvL3Nob3VsZCBpZ25vcmUgbnVsbHMgaGVyZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIGxldCBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICBsZXQgc3RyaXAgPSAoX29wdGlvbnMkc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd24pICE9IG51bGwgPyBfb3B0aW9ucyRzdHJpcFVua25vd24gOiB0aGlzLnNwZWMubm9Vbmtub3duO1xuICAgIGxldCBwcm9wcyA9IFtdLmNvbmNhdCh0aGlzLl9ub2RlcywgT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcih2ID0+ICF0aGlzLl9ub2Rlcy5pbmNsdWRlcyh2KSkpO1xuICAgIGxldCBpbnRlcm1lZGlhdGVWYWx1ZSA9IHt9OyAvLyBpcyBmaWxsZWQgZHVyaW5nIHRoZSB0cmFuc2Zvcm0gYmVsb3dcbiAgICBsZXQgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiBpbnRlcm1lZGlhdGVWYWx1ZSxcbiAgICAgIF9fdmFsaWRhdGluZzogb3B0aW9ucy5fX3ZhbGlkYXRpbmcgfHwgZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF07XG4gICAgICBsZXQgZXhpc3RzID0gKHByb3AgaW4gdmFsdWUpO1xuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlO1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IHZhbHVlW3Byb3BdO1xuXG4gICAgICAgIC8vIHNhZmUgdG8gbXV0YXRlIHNpbmNlIHRoaXMgaXMgZmlyZWQgaW4gc2VxdWVuY2VcbiAgICAgICAgaW5uZXJPcHRpb25zLnBhdGggPSAob3B0aW9ucy5wYXRoID8gYCR7b3B0aW9ucy5wYXRofS5gIDogJycpICsgcHJvcDtcbiAgICAgICAgZmllbGQgPSBmaWVsZC5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgcGFyZW50OiBpbnRlcm1lZGlhdGVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpZWxkU3BlYyA9IGZpZWxkIGluc3RhbmNlb2YgU2NoZW1hID8gZmllbGQuc3BlYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmljdCA9IGZpZWxkU3BlYyA9PSBudWxsID8gdm9pZCAwIDogZmllbGRTcGVjLnN0cmljdDtcbiAgICAgICAgaWYgKGZpZWxkU3BlYyAhPSBudWxsICYmIGZpZWxkU3BlYy5zdHJpcCkge1xuICAgICAgICAgIGlzQ2hhbmdlZCA9IGlzQ2hhbmdlZCB8fCBwcm9wIGluIHZhbHVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWUgPSAhb3B0aW9ucy5fX3ZhbGlkYXRpbmcgfHwgIXN0cmljdCA/XG4gICAgICAgIC8vIFRPRE86IHVzZSBfY2FzdCwgdGhpcyBpcyBkb3VibGUgcmVzb2x2aW5nXG4gICAgICAgIGZpZWxkLmNhc3QodmFsdWVbcHJvcF0sIGlubmVyT3B0aW9ucykgOiB2YWx1ZVtwcm9wXTtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlW3Byb3BdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdHMgJiYgIXN0cmlwKSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlW3Byb3BdID0gdmFsdWVbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RzICE9PSBwcm9wIGluIGludGVybWVkaWF0ZVZhbHVlIHx8IGludGVybWVkaWF0ZVZhbHVlW3Byb3BdICE9PSB2YWx1ZVtwcm9wXSkge1xuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gaW50ZXJtZWRpYXRlVmFsdWUgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIGZyb20gPSBbXSxcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBfdmFsdWUsXG4gICAgICByZWN1cnNpdmUgPSB0aGlzLnNwZWMucmVjdXJzaXZlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucy5mcm9tID0gW3tcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHZhbHVlOiBvcmlnaW5hbFZhbHVlXG4gICAgfSwgLi4uZnJvbV07XG4gICAgLy8gdGhpcyBmbGFnIGlzIG5lZWRlZCBmb3IgaGFuZGxpbmcgYHN0cmljdGAgY29ycmVjdGx5IGluIHRoZSBjb250ZXh0IG9mXG4gICAgLy8gdmFsaWRhdGlvbiB2cyBqdXN0IGNhc3RpbmcuIGUuZyBzdHJpY3QoKSBvbiBhIGZpZWxkIGlzIG9ubHkgdXNlZCB3aGVuIHZhbGlkYXRpbmdcbiAgICBvcHRpb25zLl9fdmFsaWRhdGluZyA9IHRydWU7XG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxWYWx1ZTtcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKG9iamVjdEVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dChvYmplY3RFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWUgfHwgdmFsdWU7XG4gICAgICBsZXQgdGVzdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl9ub2Rlcykge1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgICBpZiAoIWZpZWxkIHx8IFJlZmVyZW5jZS5pc1JlZihmaWVsZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXN0cy5wdXNoKGZpZWxkLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IG9yaWdpbmFsVmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHRlc3RzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGZpZWxkRXJyb3JzID0+IHtcbiAgICAgICAgbmV4dChmaWVsZEVycm9ycy5zb3J0KHRoaXMuX3NvcnRFcnJvcnMpLmNvbmNhdChvYmplY3RFcnJvcnMpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IHN1cGVyLmNsb25lKHNwZWMpO1xuICAgIG5leHQuZmllbGRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHMpO1xuICAgIG5leHQuX25vZGVzID0gdGhpcy5fbm9kZXM7XG4gICAgbmV4dC5fZXhjbHVkZWRFZGdlcyA9IHRoaXMuX2V4Y2x1ZGVkRWRnZXM7XG4gICAgbmV4dC5fc29ydEVycm9ycyA9IHRoaXMuX3NvcnRFcnJvcnM7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XG4gICAgbGV0IG5leHRGaWVsZHMgPSBuZXh0LmZpZWxkcztcbiAgICBmb3IgKGxldCBbZmllbGQsIHNjaGVtYU9yUmVmXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG5leHRGaWVsZHNbZmllbGRdO1xuICAgICAgbmV4dEZpZWxkc1tmaWVsZF0gPSB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IHNjaGVtYU9yUmVmIDogdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dC53aXRoTXV0YXRpb24ocyA9PlxuICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xuICAgIHMuc2V0RmllbGRzKG5leHRGaWVsZHMsIFsuLi50aGlzLl9leGNsdWRlZEVkZ2VzLCAuLi5zY2hlbWEuX2V4Y2x1ZGVkRWRnZXNdKSk7XG4gIH1cbiAgX2dldERlZmF1bHQob3B0aW9ucykge1xuICAgIGlmICgnZGVmYXVsdCcgaW4gdGhpcy5zcGVjKSB7XG4gICAgICByZXR1cm4gc3VwZXIuX2dldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBzZXQgaW52ZW50IG9uZVxuICAgIGlmICghdGhpcy5fbm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZGZ0ID0ge307XG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRmdFtrZXldID0gZmllbGQgJiYgJ2dldERlZmF1bHQnIGluIGZpZWxkID8gZmllbGQuZ2V0RGVmYXVsdChpbm5lck9wdGlvbnMpIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHJldHVybiBkZnQ7XG4gIH1cbiAgc2V0RmllbGRzKHNoYXBlLCBleGNsdWRlZEVkZ2VzKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5maWVsZHMgPSBzaGFwZTtcbiAgICBuZXh0Ll9ub2RlcyA9IHNvcnRGaWVsZHMoc2hhcGUsIGV4Y2x1ZGVkRWRnZXMpO1xuICAgIG5leHQuX3NvcnRFcnJvcnMgPSBzb3J0QnlLZXlPcmRlcihPYmplY3Qua2V5cyhzaGFwZSkpO1xuICAgIC8vIFhYWDogdGhpcyBjYXJyaWVzIG92ZXIgZWRnZXMgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50XG4gICAgaWYgKGV4Y2x1ZGVkRWRnZXMpIG5leHQuX2V4Y2x1ZGVkRWRnZXMgPSBleGNsdWRlZEVkZ2VzO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHNoYXBlKGFkZGl0aW9ucywgZXhjbHVkZXMgPSBbXSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4ge1xuICAgICAgbGV0IGVkZ2VzID0gbmV4dC5fZXhjbHVkZWRFZGdlcztcbiAgICAgIGlmIChleGNsdWRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4Y2x1ZGVzWzBdKSkgZXhjbHVkZXMgPSBbZXhjbHVkZXNdO1xuICAgICAgICBlZGdlcyA9IFsuLi5uZXh0Ll9leGNsdWRlZEVkZ2VzLCAuLi5leGNsdWRlc107XG4gICAgICB9XG5cbiAgICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xuICAgICAgcmV0dXJuIG5leHQuc2V0RmllbGRzKE9iamVjdC5hc3NpZ24obmV4dC5maWVsZHMsIGFkZGl0aW9ucyksIGVkZ2VzKTtcbiAgICB9KTtcbiAgfVxuICBwYXJ0aWFsKCkge1xuICAgIGNvbnN0IHBhcnRpYWwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBwYXJ0aWFsW2tleV0gPSAnb3B0aW9uYWwnIGluIHNjaGVtYSAmJiBzY2hlbWEub3B0aW9uYWwgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHNjaGVtYS5vcHRpb25hbCgpIDogc2NoZW1hO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGFydGlhbCk7XG4gIH1cbiAgZGVlcFBhcnRpYWwoKSB7XG4gICAgY29uc3QgbmV4dCA9IGRlZXBQYXJ0aWFsKHRoaXMpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHBpY2soa2V5cykge1xuICAgIGNvbnN0IHBpY2tlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICh0aGlzLmZpZWxkc1trZXldKSBwaWNrZWRba2V5XSA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNldEZpZWxkcyhwaWNrZWQsIHRoaXMuX2V4Y2x1ZGVkRWRnZXMuZmlsdGVyKChbYSwgYl0pID0+IGtleXMuaW5jbHVkZXMoYSkgJiYga2V5cy5pbmNsdWRlcyhiKSkpO1xuICB9XG4gIG9taXQoa2V5cykge1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSkge1xuICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICByZW1haW5pbmcucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5waWNrKHJlbWFpbmluZyk7XG4gIH1cbiAgZnJvbShmcm9tLCB0bywgYWxpYXMpIHtcbiAgICBsZXQgZnJvbUdldHRlciA9IGdldHRlcihmcm9tLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuICAgICAgbGV0IG5ld09iaiA9IG9iajtcbiAgICAgIGlmIChkZWVwSGFzKG9iaiwgZnJvbSkpIHtcbiAgICAgICAgbmV3T2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgaWYgKCFhbGlhcykgZGVsZXRlIG5ld09ialtmcm9tXTtcbiAgICAgICAgbmV3T2JqW3RvXSA9IGZyb21HZXR0ZXIob2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSk7XG4gIH1cblxuICAvKiogUGFyc2UgYW4gaW5wdXQgSlNPTiBzdHJpbmcgdG8gYW4gb2JqZWN0ICovXG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XG4gIH1cbiAgbm9Vbmtub3duKG5vQWxsb3cgPSB0cnVlLCBtZXNzYWdlID0gb2JqZWN0Lm5vVW5rbm93bikge1xuICAgIGlmICh0eXBlb2Ygbm9BbGxvdyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtZXNzYWdlID0gbm9BbGxvdztcbiAgICAgIG5vQWxsb3cgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnbm9Vbmtub3duJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB1bmtub3duKHRoaXMuc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhbm9BbGxvdyB8fCB1bmtub3duS2V5cy5sZW5ndGggPT09IDAgfHwgdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB1bmtub3duOiB1bmtub3duS2V5cy5qb2luKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBuZXh0LnNwZWMubm9Vbmtub3duID0gbm9BbGxvdztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB1bmtub3duKGFsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcbiAgICByZXR1cm4gdGhpcy5ub1Vua25vd24oIWFsbG93LCBtZXNzYWdlKTtcbiAgfVxuICB0cmFuc2Zvcm1LZXlzKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkgcmVzdWx0W2ZuKGtleSldID0gb2JqW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIGNhbWVsQ2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKGNhbWVsQ2FzZSk7XG4gIH1cbiAgc25ha2VDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoc25ha2VDYXNlKTtcbiAgfVxuICBjb25zdGFudENhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhrZXkgPT4gc25ha2VDYXNlKGtleSkudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGJhc2UuZmllbGRzID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobmV4dC5maWVsZHMpKSB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9uczI7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9uczIgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9uczIudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmFzZS5maWVsZHNba2V5XSA9IHZhbHVlLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMy5wcm90b3R5cGUgPSBPYmplY3RTY2hlbWEucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGUkMih0eXBlKSB7XG4gIHJldHVybiBuZXcgQXJyYXlTY2hlbWEodHlwZSk7XG59XG5jbGFzcyBBcnJheVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgc3BlYzoge1xuICAgICAgICB0eXBlczogdHlwZVxuICAgICAgfSxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBgdW5kZWZpbmVkYCBzcGVjaWZpY2FsbHkgbWVhbnMgdW5pbml0aWFsaXplZCwgYXMgb3Bwb3NlZCB0byBcIm5vIHN1YnR5cGVcIlxuICAgIHRoaXMuaW5uZXJUeXBlID0gdm9pZCAwO1xuICAgIHRoaXMuaW5uZXJUeXBlID0gdHlwZTtcbiAgfVxuICBfY2FzdChfdmFsdWUsIF9vcHRzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdXBlci5fY2FzdChfdmFsdWUsIF9vcHRzKTtcblxuICAgIC8vIHNob3VsZCBpZ25vcmUgbnVsbHMgaGVyZVxuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSB8fCAhdGhpcy5pbm5lclR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhc3RBcnJheSA9IHZhbHVlLm1hcCgodiwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBjYXN0RWxlbWVudCA9IHRoaXMuaW5uZXJUeXBlLmNhc3QodiwgT2JqZWN0LmFzc2lnbih7fSwgX29wdHMsIHtcbiAgICAgICAgcGF0aDogYCR7X29wdHMucGF0aCB8fCAnJ31bJHtpZHh9XWBcbiAgICAgIH0pKTtcbiAgICAgIGlmIChjYXN0RWxlbWVudCAhPT0gdikge1xuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhc3RFbGVtZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBpc0NoYW5nZWQgPyBjYXN0QXJyYXkgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgdmFyIF9vcHRpb25zJHJlY3Vyc2l2ZTtcbiAgICAvLyBsZXQgc3luYyA9IG9wdGlvbnMuc3luYztcbiAgICAvLyBsZXQgcGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgLy8gbGV0IGVuZEVhcmx5ID0gb3B0aW9ucy5hYm9ydEVhcmx5ID8/IHRoaXMuc3BlYy5hYm9ydEVhcmx5O1xuICAgIGxldCByZWN1cnNpdmUgPSAoX29wdGlvbnMkcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmUpICE9IG51bGwgPyBfb3B0aW9ucyRyZWN1cnNpdmUgOiB0aGlzLnNwZWMucmVjdXJzaXZlO1xuICAgIG9wdGlvbnMub3JpZ2luYWxWYWx1ZSAhPSBudWxsID8gb3B0aW9ucy5vcmlnaW5hbFZhbHVlIDogX3ZhbHVlO1xuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAoYXJyYXlFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1MjtcbiAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFpbm5lclR5cGUgfHwgIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dChhcnJheUVycm9ycywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vICM5NTAgRW5zdXJlIHRoYXQgc3BhcnNlIGFycmF5IGVtcHR5IHNsb3RzIGFyZSB2YWxpZGF0ZWRcbiAgICAgIGxldCB0ZXN0cyA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xuICAgICAgICB0ZXN0c1tpbmRleF0gPSBpbm5lclR5cGUuYXNOZXN0ZWRUZXN0KHtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1ID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1IDogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0ZXN0cyxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZTogKF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIDogX3ZhbHVlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBwYW5pYywgaW5uZXJUeXBlRXJyb3JzID0+IG5leHQoaW5uZXJUeXBlRXJyb3JzLmNvbmNhdChhcnJheUVycm9ycyksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBzdXBlci5jbG9uZShzcGVjKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgbmV4dC5pbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKiBQYXJzZSBhbiBpbnB1dCBKU09OIHN0cmluZyB0byBhbiBvYmplY3QgKi9cbiAganNvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ocGFyc2VKc29uKTtcbiAgfVxuICBjb25jYXQoc2NoZW1hKSB7XG4gICAgbGV0IG5leHQgPSBzdXBlci5jb25jYXQoc2NoZW1hKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIGlmIChzY2hlbWEuaW5uZXJUeXBlKVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgICAgbmV4dC5pbm5lclR5cGUgPSBuZXh0LmlubmVyVHlwZSA/XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExhenkgZG9lc24ndCBoYXZlIGNvbmNhdCBhbmQgd2lsbCBicmVha1xuICAgICAgbmV4dC5pbm5lclR5cGUuY29uY2F0KHNjaGVtYS5pbm5lclR5cGUpIDogc2NoZW1hLmlubmVyVHlwZTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvZihzY2hlbWEpIHtcbiAgICAvLyBGSVhNRTogdGhpcyBzaG91bGQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGFycmF5IHdpdGhvdXQgdGhlIGRlZmF1bHQgdG8gYmVcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhcnJheS5vZigpYCBzdWItc2NoZW1hIG11c3QgYmUgYSB2YWxpZCB5dXAgc2NoZW1hIG5vdDogJyArIHByaW50VmFsdWUoc2NoZW1hKSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgbmV4dC5pbm5lclR5cGUgPSBzY2hlbWE7XG4gICAgbmV4dC5zcGVjID0gT2JqZWN0LmFzc2lnbih7fSwgbmV4dC5zcGVjLCB7XG4gICAgICB0eXBlczogc2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbGVuZ3RoKGxlbmd0aCwgbWVzc2FnZSA9IGFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IHRoaXMucmVzb2x2ZShsZW5ndGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBhcnJheS5taW47XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIC8vIEZJWE1FKHRzKTogQXJyYXk8dHlwZW9mIFQ+XG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGFycmF5Lm1heDtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVuc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0KCgpID0+IFtdKS50cmFuc2Zvcm0oKHZhbCwgb3JpZ2luYWwpID0+IHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGBudWxsYCBmb3IgbnVsbGFibGUgc2NoZW1hXG4gICAgICBpZiAodGhpcy5fdHlwZUNoZWNrKHZhbCkpIHJldHVybiB2YWw7XG4gICAgICByZXR1cm4gb3JpZ2luYWwgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KG9yaWdpbmFsKTtcbiAgICB9KTtcbiAgfVxuICBjb21wYWN0KHJlamVjdG9yKSB7XG4gICAgbGV0IHJlamVjdCA9ICFyZWplY3RvciA/IHYgPT4gISF2IDogKHYsIGksIGEpID0+ICFyZWplY3Rvcih2LCBpLCBhKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWVzID0+IHZhbHVlcyAhPSBudWxsID8gdmFsdWVzLmZpbHRlcihyZWplY3QpIDogdmFsdWVzKTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgaWYgKG5leHQuaW5uZXJUeXBlKSB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9ucztcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJhc2UuaW5uZXJUeXBlID0gbmV4dC5pbm5lclR5cGUuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQyLnByb3RvdHlwZSA9IEFycmF5U2NoZW1hLnByb3RvdHlwZTtcblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gY3JlYXRlJDEoc2NoZW1hcykge1xuICByZXR1cm4gbmV3IFR1cGxlU2NoZW1hKHNjaGVtYXMpO1xufVxuY2xhc3MgVHVwbGVTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzY2hlbWFzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgIHNwZWM6IHtcbiAgICAgICAgdHlwZXM6IHNjaGVtYXNcbiAgICAgIH0sXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5zcGVjLnR5cGVzO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gdHlwZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHlwZUVycm9yKHR1cGxlLm5vdFR5cGUpO1xuICAgIH0pO1xuICB9XG4gIF9jYXN0KGlucHV0VmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlc1xuICAgIH0gPSB0aGlzLnNwZWM7XG4gICAgY29uc3QgdmFsdWUgPSBzdXBlci5fY2FzdChpbnB1dFZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhc3RBcnJheSA9IHR5cGVzLm1hcCgodHlwZSwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBjYXN0RWxlbWVudCA9IHR5cGUuY2FzdCh2YWx1ZVtpZHhdLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhdGg6IGAke29wdGlvbnMucGF0aCB8fCAnJ31bJHtpZHh9XWBcbiAgICAgIH0pKTtcbiAgICAgIGlmIChjYXN0RWxlbWVudCAhPT0gdmFsdWVbaWR4XSkgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjYXN0RWxlbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gY2FzdEFycmF5IDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCBpdGVtVHlwZXMgPSB0aGlzLnNwZWMudHlwZXM7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsICh0dXBsZUVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyO1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBub3QgcmVzcGVjdGluZyByZWN1cnNpdmVcbiAgICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgICBuZXh0KHR1cGxlRXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXN0cyA9IFtdO1xuICAgICAgZm9yIChsZXQgW2luZGV4LCBpdGVtU2NoZW1hXSBvZiBpdGVtVHlwZXMuZW50cmllcygpKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHU7XG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGl0ZW1TY2hlbWEuYXNOZXN0ZWRUZXN0KHtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1ID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1IDogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0ZXN0cyxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZTogKF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIDogX3ZhbHVlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBwYW5pYywgaW5uZXJUeXBlRXJyb3JzID0+IG5leHQoaW5uZXJUeXBlRXJyb3JzLmNvbmNhdCh0dXBsZUVycm9ycyksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGJhc2UuaW5uZXJUeXBlID0gbmV4dC5zcGVjLnR5cGVzLm1hcCgoc2NoZW1hLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVbaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMS5wcm90b3R5cGUgPSBUdXBsZVNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZShidWlsZGVyKSB7XG4gIHJldHVybiBuZXcgTGF6eShidWlsZGVyKTtcbn1cbmNsYXNzIExhenkge1xuICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgdGhpcy50eXBlID0gJ2xhenknO1xuICAgIHRoaXMuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbiAgICB0aGlzLnNwZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVzb2x2ZSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBsZXQgc2NoZW1hID0gdGhpcy5idWlsZGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF6eSgpIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYScpO1xuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCkgc2NoZW1hID0gc2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIHRoaXMuc3BlYyA9IHtcbiAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBuZXcgTGF6eSh0aGlzLmJ1aWxkZXIpO1xuICAgIG5leHQuc3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3BlYywgc3BlYyk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWxpdHkob3B0aW9uYWwpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBvcHRpb25hbFxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xuICB9XG4gIHJlc29sdmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGNhc3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgYXNOZXN0ZWRUZXN0KGNvbmZpZykge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBpbmRleCxcbiAgICAgIHBhcmVudCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtpbmRleCAhPSBudWxsID8gaW5kZXggOiBrZXldO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHBhcmVudFxuICAgIH0pKS5hc05lc3RlZFRlc3QoY29uZmlnKTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZUF0KHBhdGgsIHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICB2YWxpZGF0ZVN5bmNBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZVN5bmNBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5pc1ZhbGlkKHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBpc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5pc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpLmRlc2NyaWJlKG9wdGlvbnMpIDoge1xuICAgICAgdHlwZTogJ2xhenknLFxuICAgICAgbWV0YTogdGhpcy5zcGVjLm1ldGEsXG4gICAgICBsYWJlbDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICBtZXRhKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubWV0YSA9IE9iamVjdC5hc3NpZ24obmV4dC5zcGVjLm1ldGEgfHwge30sIGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExvY2FsZShjdXN0b20pIHtcbiAgT2JqZWN0LmtleXMoY3VzdG9tKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3Qua2V5cyhjdXN0b21bdHlwZV0pLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxvY2FsZVt0eXBlXVttZXRob2RdID0gY3VzdG9tW3R5cGVdW21ldGhvZF07XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRNZXRob2Qoc2NoZW1hVHlwZSwgbmFtZSwgZm4pIHtcbiAgaWYgKCFzY2hlbWFUeXBlIHx8ICFpc1NjaGVtYShzY2hlbWFUeXBlLnByb3RvdHlwZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB5dXAgc2NoZW1hIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgTWV0aG9kIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXRob2QgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCcpO1xuICBzY2hlbWFUeXBlLnByb3RvdHlwZVtuYW1lXSA9IGZuO1xufVxuXG5leHBvcnQgeyBBcnJheVNjaGVtYSwgQm9vbGVhblNjaGVtYSwgRGF0ZVNjaGVtYSwgTWl4ZWRTY2hlbWEsIE51bWJlclNjaGVtYSwgT2JqZWN0U2NoZW1hLCBTY2hlbWEsIFN0cmluZ1NjaGVtYSwgVHVwbGVTY2hlbWEsIFZhbGlkYXRpb25FcnJvciwgYWRkTWV0aG9kLCBjcmVhdGUkMiBhcyBhcnJheSwgY3JlYXRlJDcgYXMgYm9vbCwgY3JlYXRlJDcgYXMgYm9vbGVhbiwgY3JlYXRlJDQgYXMgZGF0ZSwgbG9jYWxlIGFzIGRlZmF1bHRMb2NhbGUsIGdldEluLCBpc1NjaGVtYSwgY3JlYXRlIGFzIGxhenksIGNyZWF0ZSQ4IGFzIG1peGVkLCBjcmVhdGUkNSBhcyBudW1iZXIsIGNyZWF0ZSQzIGFzIG9iamVjdCwgcHJpbnRWYWx1ZSwgcmVhY2gsIGNyZWF0ZSQ5IGFzIHJlZiwgc2V0TG9jYWxlLCBjcmVhdGUkNiBhcyBzdHJpbmcsIGNyZWF0ZSQxIGFzIHR1cGxlIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfZG9tX187IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH0iLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCAqIGZyb20gXCIuL2NvbXBvbmVudHNcIjtcbiJdLCJuYW1lcyI6WyJjbiIsImpzeCIsIl9qc3giLCJBdmF0YXJTaXplIiwiQmlnIiwiTWVkaXVtIiwiU21hbGwiLCJTbWFsbGVzdCIsIkF2YXRhciIsIl9yZWYiLCJzcmMiLCJjbGFzc05hbWUiLCJyb3VuZGVkIiwic2l6ZSIsInByb3BzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwiY2xhc3NOYW1lcyIsIl9kZWZpbmVQcm9wZXJ0eSIsImF2YXRhcl9yb3VuZGVkIiwiY29uY2F0IiwiY2hpbGRyZW4iLCJfb2JqZWN0U3ByZWFkIiwianN4cyIsIl9qc3hzIiwiQmFkZ2VWYXJpYW50IiwiU3VjY2VzcyIsIkVycm9yIiwiV2FybmluZyIsIkRhbmdlciIsIlRyYW5zcGFyZW50IiwiQmFkZ2VNYXhXaWR0aDI1MCIsIkJhZGdlIiwiaWNvbiIsInZhcmlhbnQiLCJyb3VuZCIsIm1heFdpZHRoIiwiY2xvc2VhYmxlIiwib25DbG9zZSIsImhyZWYiLCJ0eXBlIiwib25DbGljayIsIlByb3BUeXBlcyIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJCdXR0b25WYXJpYW50IiwiU2Vjb25kYXJ5IiwiUGxhaW4iLCJCdXR0b25UaGVtZSIsIkRlc3RydWN0IiwiQnV0dG9uUHJvcFR5cGVzIiwidGhlbWUiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwiQnV0dG9uIiwicmVmIiwid2lkZSIsIl9yZWYkdHlwZSIsImJ1dHRvblByb3BzIiwiY29uc29sZSIsImxvZyIsIkNhcmQiLCJDYXJkRm9vdGVyIiwiX3JlZjIiLCJfZXhjbHVkZWQyIiwiRm9vdGVyIiwibWVtbyIsInVzZUNvbnRleHQiLCJ1c2VGb3JtQ29udHJvbFJlZiIsIkNoZWNrYm94R3JvdXBDb250ZXh0IiwiQ2hlY2tib3hHcm91cCIsIkNoZWNrYm94VmFyaWFudCIsIkNoZWNrYm94IiwiU3dpdGNoIiwiZXh0UmVmIiwibGFiZWwiLCJ0aXRsZSIsImVycm9yIiwib25DaGFuZ2UiLCJvdGhlclByb3BzIiwiY2hlY2tib3hQcm9wcyIsIl91c2VGb3JtQ29udHJvbFJlZiIsImVsIiwiZ2V0VmFsdWUiLCJjaGVja2VkIiwic2V0VmFsdWUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJjYWxsYmFja1JlZiIsIm9uQ2hlY2tib3hDaGFuZ2UiLCJldmVudCIsImN1cnJlbnQiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0Q2hlY2tlZCIsImdyb3VwQ29udGV4dCIsIl9wcm9wcyRkaXNhYmxlZCIsIl9wcm9wcyR2YXJpYW50IiwibmFtZSIsImRpc2FibGVkIiwiX2dyb3VwQ29udGV4dCRvbkNoYW5nIiwiY2FsbCIsInZhbHVlIiwiaW5jbHVkZXMiLCJfY2hlY2tib3hQcm9wcyR2YXJpYW4iLCJsYWJlbENsYXNzTmFtZXMiLCJjaGVja2JveF9lcnJvciIsIkdyb3VwIiwiVmFyaWFudCIsIlJlYWN0IiwiX3Byb3BzJGNvbXBvbmVudCIsImNvbXBvbmVudCIsIkNvbXBvbmVudCIsImNoZWNrYm94Tm9kZXMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwidmFsdWVzIiwibWFwIiwiZmlsdGVyIiwiQm9vbGVhbiIsImZvckVhY2giLCJub2RlIiwiX3Byb3BzJG9uQ2hhbmdlIiwiUHJvdmlkZXIiLCJjcmVhdGVDb250ZXh0IiwiSW5wdXQiLCJ1c2VEYXRlcGlja2VyIiwiRGF0ZUlucHV0IiwiX3VzZURhdGVwaWNrZXIiLCJoYW5kbGVDaGFuZ2UiLCJjbGFzc2VzIiwiaW5wdXRQcm9wcyIsIl8iLCJvbWl0IiwiaXNFcXVhbCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwiREVGQVVMVF9EQVRFX0ZPUk1NQVQiLCJERUZBVUxUX01VTFRJUExFX0RBVEVTX1NFUEFSQVRPUiIsIkRBVEVfU0VMRUNUX0VWRU5UIiwiZGVmYXVsdE9wdGlvbnMiLCJhdXRvQ2xvc2UiLCJrZXlib2FyZE5hdiIsIm11bHRpcGxlRGF0ZXNTZXBhcmF0b3IiLCJvbkJsdXIiLCJfcmVmJGRhdGVwaWNrZXJPcHRpb24iLCJkYXRlcGlja2VyT3B0aW9ucyIsIm9wdGlvbnMiLCJfcmVmJGZvcm1hdCIsImZvcm1hdCIsImNvbnRleHQiLCJwYXJzZWREYXRlVmFsdWUiLCJnZXREYXRlVmFsdWVGcm9tU3RyaW5nIiwiX2dldFZhbGlkYXRlZERhdGUiLCJnZXRWYWxpZGF0ZWREYXRlIiwiZGF0ZVZhbHVlIiwic2V0RGF0ZSIsIiRlbCIsIiQiLCJkYXRlcGlja2VyIiwib25TZWxlY3QiLCJzaWxlbnQiLCJkYXRlU2VsZWN0RXZlbnQiLCJ0YXJnZXQiLCJvbkhpZGUiLCJpbnN0IiwiaXNGaW5pc2hlZCIsInZhbCIsInBhcnNlIiwiZGF0YSIsImRlc3Ryb3kiLCJKU09OIiwic3RyaW5naWZ5Iiwib3Blbk9uSW5pdCIsImRwIiwic2hvdyIsImRhdGUiLCJzZXBhcmF0b3IiLCJyYW5nZSIsInNwbGl0IiwiaXNSYW5nZSIsIkFycmF5IiwiaXNBcnJheSIsImdldFZhbGlkYXRlZERhdGVSYW5nZSIsImdldFZhbGlkYXRlZERhdGVTaW5nbGUiLCJpc1ZhbGlkIiwiZGF0ZU9iaiIsIm1EYXRlIiwibW9tZW50IiwidG9EYXRlIiwiX3ZhbHVlIiwiX3NsaWNlZFRvQXJyYXkiLCJ2YWx1ZUJlZ2luIiwidmFsdWVFbmQiLCJtRGF0ZUJlZ2luIiwibURhdGVFbmQiLCJpc0RhdGVCZWdpblZhbGlkIiwiaXNEYXRlRW5kVmFsaWQiLCJfcmVmMyIsIl9yZWYzJHBhcnNlIiwic2VsZWN0RGF0ZSIsIl9nZXRWYWxpZGF0ZWREYXRlMiIsImNsZWFyIiwiX2RhdGUiLCJmaXJzdERhdGUiLCJzZWNvbmREYXRlIiwiaXNTYW1lIiwiaXNCZWZvcmUiLCJpc1NhbWVPckJlZm9yZSIsIkRlZmluaXRpb25zVmFyaWFudCIsIlJvdyIsIlJvd1RhYmxlIiwiRGVmaW5pdGlvbnNXaWR0aCIsIlcxNTAiLCJXMjAwIiwiVzI1MCIsIlczMDAiLCJEZWZpbml0aW9ucyIsIl9yZWYkaXRlbXMiLCJpdGVtcyIsImZpeFdpZHRoIiwiX3JlZiRyZXZlcnNlIiwicmV2ZXJzZSIsIml0ZW0iLCJpbmRleCIsIkRlZmluaXRpb25zSXRlbSIsIldpZHRoIiwidGVybSIsImRlc2MiLCJEcm9wZG93bkl0ZW0iLCJEcm9wZG93biIsIl9yZWYkb3B0aW9ucyIsInRvZ2dsZSIsIiR0b2dnbGUiLCJkcm9wZG93biIsImlkIiwiaXRlbVByb3BzIiwiRnJhZ21lbnQiLCJfRnJhZ21lbnQiLCJEcm9wZG93bkl0ZW1UeXBlIiwiTGluayIsIml0ZW1DbGFzcyIsInRleHQiLCJjb250ZW50IiwiZWxlbWVudCIsInVzZVN0YXRlIiwiRmlsZVByZXZpZXciLCJGaWxlQWN0aW9uIiwiRmlsZSIsIl9yZWYkbGFiZWxJY29uIiwibGFiZWxJY29uIiwiX3JlZiRsYWJlbFRleHQiLCJsYWJlbFRleHQiLCJkZXNjcmlwdGlvbiIsIl9yZWYkZmlsZSIsImZpbGUiLCJpbml0RmlsZSIsIl91c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJzZXRGaWxlIiwiY3VyckZpbGVSZWYiLCJhY3Rpb25SZWYiLCJpbnB1dFJlZiIsIl9lbCRmaWxlcyQiLCJDaGFuZ2UiLCJmaWxlcyIsImhhbmRsZUFjdGlvbiIsImlucHV0RWwiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImFjdGlvbiIsImRhdGFzZXQiLCJBZGQiLCJjbGljayIsIlJlbW92ZSIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsImJ1YmJsZXMiLCJlZGl0IiwicmVtb3ZlIiwiRG93bmxvYWRCdXR0b24iLCJ1cmwiLCJfcmVmJGRvd25sb2FkTmFtZSIsImRvd25sb2FkTmFtZSIsImRvd25sb2FkIiwiRWRpdEJ1dHRvbiIsIlJlbW92ZUJ1dHRvbiIsIkFjdGlvbkJ1dHRvbnMiLCJfcHJvcHMkZWRpdCIsIl9wcm9wcyRyZW1vdmUiLCJfcHJvcHMkZmlsZSR1cmwiLCJDb21wb25lbnRzIiwiaGFzQWN0aW9ucyIsIk9iamVjdCIsImtleXMiLCJlbnRyaWVzIiwia2V5IiwiSW5mbyIsIl9yZWY0IiwiX3JlZjQkZmlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiYWx0IiwiZ2V0SWQiLCJNYXRoIiwiY2VpbCIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0RmlsZUluZm8iLCJwaWNrIiwibW9ja0ZpbGUiLCJGaWxlTGlzdCIsIl9yZWYkZmlsZXMiLCJpbml0RmlsZXMiLCJfcmVmJG1heCIsIm1heCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwic2V0RmlsZXMiLCJmIiwiY2FuQWRkIiwiZmlsZXNUb1JlbmRlciIsImlzRmlyc3QiLCJuZXdGaWxlIiwiRm9ybSIsIkZvcm1TZWN0aW9uIiwiRm9ybURlc2NyaXB0aW9uIiwiX2V4Y2x1ZGVkMyIsIkZvcm1GaWVsZHNldCIsIl9leGNsdWRlZDQiLCJGb3JtVGl0bGUiLCJfcmVmNSIsInJlcXVpcmVkIiwiX3JlZjUkdGFnIiwidGFnIiwiVGFnIiwiX2V4Y2x1ZGVkNSIsIm1haW5DbGFzc05hbWUiLCJhc3NpZ24iLCJTZWN0aW9uIiwiRGVzY3JpcHRpb24iLCJGaWVsZHNldCIsIlRpdGxlIiwiY29sV2lkdGhzIiwiZ2V0Q29sdW1uU2l6ZUNsYXNzIiwiaXNYcyIsImNvbFdpZHRoIiwiY29sU2l6ZSIsImdldENvbHVtbkNsYXNzZXMiLCJhdHRyaWJ1dGVzIiwid2lkdGhzIiwibW9kaWZpZWRBdHRyaWJ1dGVzIiwiY29sQ2xhc3NlcyIsImkiLCJjb2x1bW5Qcm9wIiwiaXNPYmplY3QiLCJjb2xTaXplSW50ZXJmaXgiLCJjb2xDbGFzcyIsInB1c2giLCJvcmRlciIsIm9mZnNldCIsIkNvbCIsImNzc01vZHVsZSIsIl9yZWYkd2lkdGhzIiwiX3JlZiR0YWciLCJfZ2V0Q29sdW1uQ2xhc3NlcyIsIkNvbnRhaW5lciIsImZsdWlkIiwiY29udGFpbmVyQ2xhc3MiLCJyb3dDb2xXaWR0aHMiLCJub0d1dHRlcnMiLCJfcHJvcHMkdGFnIiwiX3Byb3BzJHdpZHRocyIsIkdyb3VwQ29udGFpbmVyIiwibW9kaWZ5Q2hpbGRyZW4iLCJjaGlsZCIsImNsb25lRWxlbWVudCIsIkNoaWxkcmVuIiwiSW5wdXRtYXNrIiwibWFza09wdGlvbnMiLCJwbGFjZWhvbGRlciIsIm9uU3VibWl0IiwiaW5wdXRPcHRpb25zIiwiaW0iLCJtYXNrIiwiX2ltIiwiX3JlZiRjdXJyZW50IiwiaGFuZGxlS2V5RG93biIsImhhbmRsZUJsdXIiLCJpc1NlYXJjaCIsImlucHV0X2Vycm9yIiwiaW5wdXRfc2VhcmNoIiwib25LZXlEb3duIiwiYXV0b0NvbXBsZXRlIiwiX0lucHV0IiwiTGlzdFR5cGUiLCJPcmRlcmVkIiwiVW5vcmRlcmVkIiwiT3JkZXJlZExpc3RUeXBlIiwiQnJhY2tlZCIsIkxldHRlciIsIkl0ZW0iLCJMaXN0IiwiX3JlZjIkdHlwZSIsImxldHRlciIsImJyYWNrZXQiLCJpc09yZGVyZWQiLCJsaXN0X29yZGVyZWQiLCJPTGlzdCIsIlVMaXN0IiwiTG9hZGVyIiwiUG9ydGFsIiwiTW9kYWxWYXJpYW50IiwiTW9kYWwiLCJEaWFsb2ciLCJNb2RhbEV2ZW50IiwiSGlkZSIsIkRlZmF1bHRIZWFkZXJDb250ZW50IiwiRGVmYXVsdEZvb3RlckNvbnRlbnQiLCJfcmVmMiRjb25maXJtTGFiZWwiLCJjb25maXJtTGFiZWwiLCJfcmVmMiRjYW5jZWxMYWJlbCIsImNhbmNlbExhYmVsIiwib25Db25maXJtIiwicmVuZGVySGVhZGVyIiwiX3Byb3BzJGhhc0hlYWRlciIsImhhc0hlYWRlciIsInJlbmRlckZvb3RlciIsIl9wcm9wcyRoYXNGb290ZXIiLCJoYXNGb290ZXIiLCJyZW5kZXJCb2R5Iiwib3BlbiIsIl9wcm9wcyRsYXp5IiwibGF6eSIsImlzTW91bnRlZCIsInNldElzTW91bnRlZCIsIiRtb2RhbCIsIm9uIiwibW9kYWwiLCJvZmYiLCJtb2RhbENsYXNzTmFtZXMiLCJ0YWJJbmRleCIsIkFsZXJ0IiwiQ29uZmlybSIsIk5vdGlmaWNhdGlvbiIsIl9yZWYkdmlzaWJsZUNsb3NlQnV0dCIsInZpc2libGVDbG9zZUJ1dHRvbiIsIlR5cGUiLCJBY2NlbnQiLCJmbiIsImFkZEl0ZW0iLCJEYXRlIiwiZ2V0VGltZSIsIm5vdGlmaWNhdGlvbiIsImluZm8iLCJzdWNjZXNzIiwiZGFuZ2VyIiwid2FybmluZyIsIk5vdGlmaWNhdGlvbkNvbnRhaW5lciIsInNldEl0ZW1zIiwicmVtb3ZlSXRlbSIsImhhbmRsZUNsb3NlIiwiXyQkZGF0YSIsInBhZ2luYXRpb24iLCJQcmV2QnV0dG9uIiwicGFnZSIsInBhZ2VzIiwiaXNDdXJyZW50Rmlyc3QiLCJmaXJzdCIsInBhZ2luYXRpb25fX2l0ZW1fZGlzYWJsZWQiLCJOZXh0QnV0dG9uIiwiaXNDdXJyZW50TGFzdCIsImxhc3QiLCJQYWdlcyIsImN1cnJQYWdlIiwicGFnaW5hdGlvbl9faXRlbV9hY3RpdmUiLCJQYWdpbmF0aW9uIiwicGFnZVNpemUiLCJ0b3RhbCIsImRlbHRhIiwiX3JlZjQkYXJyb3dzIiwiYXJyb3dzIiwib25QYWdlQ2hhbmdlIiwiaGFuZGxlQ2xpY2siLCJzZWxlY3RlZFBhZ2UiLCJ0YWlsIiwid2FybiIsImxQYXJ0IiwiclBhcnQiLCJTcGFjZSIsImxUYWlsIiwibERlbHRhIiwiclRhaWwiLCJyRGVsdGEiLCJjcmVhdGVQb3J0YWwiLCJfcmVmJGVsZW1lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJjb21wb3NlUmVmIiwiUmFkaW9Hcm91cCIsIlJhZGlvR3JvdXBDb250ZXh0IiwiUmFkaW8iLCJpbm5lclJlZiIsIm1lcmdlZFJlZiIsIm9uUmFkaW9DaGFuZ2UiLCJlIiwicmFkaW9Qcm9wcyIsInJhZGlvX2Vycm9yIiwiY2hlY2tlZEVsIiwicXVlcnlTZWxlY3RvciIsIm5vZGVzIiwiU2VsZWN0RXZlbnQiLCJzZWxlY3RwaWNrZXJFdmVudEhhbmRsZXJzIiwiZGVmYXVsdFNlbGVjdHBpY2tlck9wdGlvbnMiLCJkZWZhdWx0SXRlbXMiLCJyZW5kZXJPcHRpb25zIiwiZ3JvdXBJdGVtcyIsIl9yZWYkdG9rZW4iLCJ0b2tlbiIsIl9yZWYkdGl0bGUiLCJfcmVmJGNvbnRlbnQiLCJfcmVmJHN1YnRleHQiLCJzdWJ0ZXh0IiwiX3JlZiRjbGFzc05hbWUiLCJkaXZpZGVyIiwic3R5bGUiLCJTZWxlY3QiLCJfcmVmMiRpdGVtcyIsIl9yZWYyJHNlbGVjdHBpY2tlck9wdCIsInNlbGVjdHBpY2tlck9wdGlvbnMiLCJtdWx0aXBsZSIsIm5vRGVjb3IiLCJzZWxlY3RPcHRpb25zIiwiYWpheE9wdGlvbnMiLCJhZGRJdGVtc09wdGlvbnMiLCJzZWxlY3RwaWNrZXIiLCJmcm9tIiwic2VsZWN0ZWQiLCIkc2VsZWN0Iiwid2luZG93IiwiaW5pdEJvb3RzdHJhcFNlbGVjdCIsImFqYXhTZWxlY3RQaWNrZXIiLCJhZGRTZWxlY3RQaWNrZXIiLCJfcmVmNiIsInByb3BOYW1lIiwiX3Byb3BOYW1lJHNwbGl0IiwiX3Byb3BOYW1lJHNwbGl0MiIsImV2ZW50TmFtZSIsImV2ZW50TmFtZVVwcGVyY2FzZSIsInRvVXBwZXJDYXNlIiwic2VsZWN0cGlja2VyRXZlbnROYW1lIiwiXyRzZWxlY3QkZGF0YSIsIl9ldmVudCR0YXJnZXQiLCJfcmVmNyIsIl9yZWY4Iiwic2VsZWN0Q2xhc3NOYW1lcyIsImRyb3B1cCIsImRyb3B1cEF1dG8iLCJpc0Rpc2FibGVkIiwiU0hPVyIsIlNIT1dOIiwiSElERSIsIkhJRERFTiIsIkxPQURFRCIsIlJFTkRFUkVEIiwiUkVGUkVTSEVEIiwiQ0hBTkdFRCIsImxjTmFtZSIsInRvTG93ZXJDYXNlIiwic2xpY2UiLCJTZXBhcmF0b3IiLCJ2ZXJ0aWNhbCIsIm1haW5DbGFzcyIsIlNwYW4iLCJTdGF0dXNUeXBlIiwiTXV0ZWQiLCJTdGF0dXMiLCJOb3JtYWwiLCJUYWJsZUhlYWRlciIsIlRhYmxlQm9keSIsIlRhYmxlIiwiY29sdW1ucyIsInNvcnRDb2x1bW4iLCJvblNvcnQiLCJfcmVmJGlkRmllbGROYW1lIiwiaWRGaWVsZE5hbWUiLCJjb2wiLCJyZW5kZXJDZWxsIiwicGF0aCIsImdldCIsIm9iaiIsImxlbiIsInJlbmRlckNvbHVtbiIsImNvbHVtbiIsImhhbmRsZVNvcnQiLCJkaXJlY3Rpb24iLCJTdWJ0aXRsZSIsIlNlY3Rpb25UaXRsZSIsIlNlY3Rpb25TdWJ0aXRsZSIsIlBhcmFncmFwaCIsIlRhZ0NsYXNzTmFtZSIsIlRleHRDb2xvciIsIlBvc2l0aXZlIiwiQnJhbmQiLCJJbXBvcnRhbnQiLCJBcHByb3ZlZCIsIlBhbGUiLCJUZXh0U2l6ZSIsIlNtYWxsZXIiLCJUZXh0IiwiX3JlZiR2YXJpYW50IiwiY29sb3IiLCJzdHJvbmciLCJ1cHBlciIsIlRhZ05hbWUiLCJ0YWdDbGFzc05hbWUiLCJUZXh0YXJlYSIsInd5c2l3eWciLCJ0ZXh0YXJlYVByb3BzIiwiJHRleHRhcmVhIiwiaW5pdFdZU0lXWUciLCJ0ZXh0YXJlYV9lcnJvciIsIlRvb2x0aXAiLCJ0b29sdGlwIiwiX3JlZiRwbGFjZW1lbnQiLCJwbGFjZW1lbnQiLCJoYW5kbGVyIiwiY29udGFpbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNob3dUb29sdGlwIiwiaW5pdFRvb2xUaXAiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXR0cnMiLCJ0b29sdGlwX19oYW5kbGVyIiwiVlN0YWNrIiwiX3JlZiRnYXAiLCJnYXAiLCJjaGlsZHJlbldpdGhHYXAiLCJfcHJvcHMkY2xhc3NOYW1lIiwiY291bnQiLCJpc0xhc3QiLCJ1c2VGb3JtIiwidXNlUHJveHlTdGF0ZSIsImZpbGxSZWYiLCJfdHlwZW9mIiwiX2xlbiIsInJlZnMiLCJfa2V5IiwicmVmTGlzdCIsInVzZUVsZW1lbnRSZWYiLCJyZWZDYWxsYmFjayIsImhhc093biIsImRlZmluZVByb3BlcnR5IiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsInQiLCJyIiwicHJvdG90eXBlIiwibiIsImhhc093blByb3BlcnR5IiwibyIsIlN5bWJvbCIsImEiLCJpdGVyYXRvciIsImMiLCJhc3luY0l0ZXJhdG9yIiwidSIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwid3JhcCIsIkdlbmVyYXRvciIsImNyZWF0ZSIsIkNvbnRleHQiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJhcmciLCJoIiwibCIsInMiLCJ5IiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsInAiLCJkIiwiZ2V0UHJvdG90eXBlT2YiLCJ2IiwiZyIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsIl9pbnZva2UiLCJBc3luY0l0ZXJhdG9yIiwiaW52b2tlIiwicmVzb2x2ZSIsIl9fYXdhaXQiLCJ0aGVuIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJkb25lIiwibWV0aG9kIiwiZGVsZWdhdGUiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZXR1cm4iLCJUeXBlRXJyb3IiLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXNOYU4iLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJjb25zdHJ1Y3RvciIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXN5bmMiLCJQcm9taXNlIiwicG9wIiwicHJldiIsImNoYXJBdCIsInN0b3AiLCJydmFsIiwiaGFuZGxlIiwiY29tcGxldGUiLCJmaW5pc2giLCJjYXRjaCIsIl9jYXRjaCIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsIl9hc3luY1RvR2VuZXJhdG9yIiwic2VsZiIsImFyZ3MiLCJhcHBseSIsImVyciIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwidG9QcmltaXRpdmUiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0ZXN0IiwiYXJyMiIsInl1cCIsInVzZU1lbW8iLCJpc1VuZGVmaW5lZCIsIl9yZWYkZGVmYXVsdFZhbHVlcyIsImRlZmF1bHRWYWx1ZXMiLCJzY2hlbWEiLCJyZWZTdG9yZSIsInNldFZhbHVlcyIsIl91c2VTdGF0ZTMiLCJfdXNlU3RhdGU0IiwiZXJyb3JzIiwic2V0RXJyb3JzIiwiX25hbWVzIiwid2F0Y2giLCJTZXQiLCJ3YXRjaEFsbCIsIl91c2VQcm94eVN0YXRlIiwiaXNTdWJtaXR0ZWQiLCJwcm94eUZvcm1TdGF0ZSIsInByb3h5U3RhdGUiLCJ1cGRhdGVGb3JtU3RhdGUiLCJ1cGRhdGVTdGF0ZSIsInNldERlZmF1bHRWYWx1ZXMiLCJpbml0IiwiX3JlZjIkaW5pdCIsIl9pIiwiX09iamVjdCRrZXlzIiwiX3JlZlN0b3JlJGN1cnJlbnQkbmFtIiwiaGFzRXh0ZXJuYWxEZWZhdWx0VmFsdWUiLCJzaG91bGRTZXREZWZhdWx0VmFsdWUiLCJyZXNldFZhbHVlcyIsIl9pMiIsIl9PYmplY3Qka2V5czIiLCJyZXNldEVycm9ycyIsImdldERhdGEiLCJyZWR1Y2UiLCJhY2MiLCJnZXRTY2hlbWEiLCJ2YWxpZGF0ZSIsIm9iamVjdCIsImFib3J0RWFybHkiLCJ2YWxpZGF0ZUZpZWxkIiwiX2NhbGxlZSIsIl9yZWY4JHNob3VsZFVwZGF0ZVZhbCIsInNob3VsZFVwZGF0ZVZhbHVlIiwiX3JlZlN0b3JlJGN1cnJlbnQkbmFtMiIsImVycm9yTWVzc2FnZSIsInZhbHVlT2JqIiwic2NoZW1hT2JqIiwibWVzc2FnZSIsIl9hcmdzIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInQwIiwicHJldkVycm9ycyIsImN1cnJFcnJvck1lc3NhZ2UiLCJzaG91bGRVcGRhdGVFcnJvciIsImhhc0Vycm9ycyIsIl94IiwiX3JlZjEwIiwiX2NhbGxlZTIiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJoYXMiLCJfeDIiLCJfeDMiLCJnZXRDYWxsYmFja1JlZiIsIl9zY2hlbWEkbmFtZSIsImV4dGVybmFsRGVmYXVsdFZhbHVlIiwiaW5uZXJEZWZhdWx0VmFsdWUiLCJyZWdpc3RlciIsImFkZCIsInJlZ2lzdGVyUHJvcHMiLCJoYW5kbGVTdWJtaXQiLCJzdWJtaXRIYW5kbGVyIiwiX3JlZjExIiwiX2NhbGxlZTMiLCJwcm9taXNlcyIsInJlc3VsdCIsIl9jYWxsZWUzJCIsIl9jb250ZXh0MyIsImZpZWxkRGF0YSIsImZpZWxkU2NoZW1hIiwiYWxsU2V0dGxlZCIsIl9yZWYxMiIsInN0YXR1cyIsIl9yZWYxMyIsInJlYXNvbiIsIl9yZWYxNCIsIl94NCIsImhhc0tleXMiLCJuYW1lc0FyciIsInJlcyIsIl9yZWZTdG9yZSRjdXJyZW50IiwiZm9ybVN0YXRlIiwiZ2V0UmVmUHJvcHMiLCJyZWZQYXJhbSIsImluaXRTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGUiLCJ3YXRjaEZpZWxkc1JlZiIsInByb3h5U3RhdGVSZWYiLCJfbG9vcCIsIl9yZWYkc2hvdWxkUmVuZGVyIiwic2hvdWxkUmVuZGVyIiwiY3VycmVudFZhbHVlIiwiaXNTYW1lVmFsdWUiLCJpc1dhdGNoZWQiLCJzaG91bGRTZXRTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=